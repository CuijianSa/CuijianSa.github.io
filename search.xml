<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++11智能指针</title>
      <link href="/2019/12/22/C++/C++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2019/12/22/C++/C++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h1><p>C++支持4中指针类型转换：</p><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul><li>取消const属性</li><li>可以用常量初始化常引用，但不能用常量初始化普通引用</li></ul><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ul><li>基本类型转换，不能用于基本类型指针间转换</li><li>可用于有继承关系的类之间对象间(父子对象)的转换和指针之间(父子指针)的转换</li></ul><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul><li>用于有继承关系的基类与派生类指针之间的转换，前提视必须有多态存在<ul><li>向上转型  基类指针对象=派生类指针对象</li><li>向下转型  派生类指针对象=基类指针对象</li></ul></li></ul><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul><li>普通类型之间的转换(不安全)</li><li>整数和指针之间的转换</li></ul><h1 id="为什么使用智能指针"><a href="#为什么使用智能指针" class="headerlink" title="为什么使用智能指针"></a>为什么使用智能指针</h1><h1 id="智能指针如何使用"><a href="#智能指针如何使用" class="headerlink" title="智能指针如何使用"></a>智能指针如何使用</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr指向相同的对象，shared_ptr使用引用计数，每个shared_ptr的拷贝都指向相同的内存。每使用一次，内部的引用计数+1,每析构一次，内部的引用计数-1,减为0时自动删除所指向的堆内存.shared_ptr引用计数线程安全的，但对象的读取需要加锁</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique’唯一’拥有其所指对象，同一时刻只能有一个unique_ptr指向给定的对象（通过禁止拷贝语义、只有移动语义来实现）.</p><p>unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)<br>unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p><h1 id="指针指针的设计与实现"><a href="#指针指针的设计与实现" class="headerlink" title="指针指针的设计与实现"></a>指针指针的设计与实现</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>chromium概述</title>
      <link href="/2019/11/28/chromium/chromium%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/11/28/chromium/chromium%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="NPAPI-plugin"><a href="#NPAPI-plugin" class="headerlink" title="NPAPI plugin"></a>NPAPI plugin</h1><ul><li>NPP: 由插件来实现，被浏览器调用，主要包括一些插件创建，初始化，关闭，销毁，信息查询及事件处理，数据流，窗口设置，URL等</li><li>NPN: 由浏览器来实现，被插件所调用，主要包括图形绘制，数据流处理，浏览器信息查询，内存分配和释放，浏览器的插件设置，URL等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          Render </span><br><span class="line">    IPC  /         \IPC</span><br><span class="line">Browser   Render   Plugin</span><br><span class="line">    IPC  \         /IPC    </span><br><span class="line">          Render</span><br></pre></td></tr></table></figure><ul><li>每一种类型的plugin只有一个进程，这就是说，如果有两个或者多个renderer进程同时使用同一个插件，那么该插件会共享同一个进程。因为多个renderer进程共享同一种的plugin进程，那么plugin进程如何为它们服务呢？答案是为每个插件使用点在plugin进程中创建一个插件实例(PluginInstance).</li><li>plugin进程是由browser进程来负责创建和销毁, 而不是renderer进程。 原因在于renderer进程没有创建的权限，而且plugin进程由browser进程来统一管理也更方便。 当plugin进程创建成功时，browser进程会返回IPCchannel handle用于创建和plugin进程通讯的PluginChannelHost. 那它什么时候被销毁呢？当没有任何插件实例并且空闲一段事件后，它才会被销毁，这样做的好处是避免频繁的创建和销毁plugin进程。</li></ul><h1 id="Content-Shell"><a href="#Content-Shell" class="headerlink" title="Content Shell"></a>Content Shell</h1><p>content shell是一个基于content api的简单测试程序, 它仅仅是一个壳，调用了content API并实现了部分必需的回调接口，可以用来测试和其他一些简单的功能。</p><ul><li><p>app<br>这部分主要是跟应用程序或者进程的创建和初始化相关。<br>第一类，主要包括创建进程的初始化函数，content的初始化和关闭；<br>第二类，主要是实现回调函数，告诉嵌入者启动完成，进程启动，进程推出，沙盒模型初始化开始和结束等等。</p></li><li><p>browser<br>第一类包括，对一些HTML5功能和其他一些高级功能实现的参与，例如resource，sensor，notification，speech recognition， web worker，download， web intents，等等;</p></li></ul><p>第二类包括ContentBrowserClient，主要是实现部分逻辑，被Browser端（或者进程）调用，还有就是一些事件的回调函数.</p><ul><li><p>common<br>主要定义一些公共的接口，被render和browser共享，例如一些进程相关，参数，gpu相关等等</p></li><li><p>render<br>一类包含获取RenderThread的消息循环，注册v8 extension，计算JavaScript表达式等等</p></li></ul><p>第二类包括ContentRendererClient，主要是实现部分逻辑，被Browser端（或者进程）调用，还有就是一些事件的回调函数</p><ul><li><p>utility<br>工具类接口，主要包括让嵌入者参与content API中的线程创建和消息的过滤。</p></li><li><p>gpu<br>创建gpu进程进行gpu加速</p></li><li><p>child</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> chromium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-解释器模式</title>
      <link href="/2019/09/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p><p>主要优点如下。</p><ul><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易</li></ul><p>主要缺点如下。</p><ul><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li><li>终结符表达式（Terminal    Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li><li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li><li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ul><p><img src="/2019/09/29/设计模式/软件设计模式-解释器模式/expression.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * rule:</span><br><span class="line"> * &lt;expression&gt; :: = &lt;city&gt;|&lt;persion&gt;</span><br><span class="line"> * &lt;city&gt; ::= nanjing | hanzhou</span><br><span class="line"> * &lt;persion&gt; ::= old | woman | child</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Expression</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual bool Interpret(string info) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TerminalExpression : public Expression</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    TerminalExpression(const string info[], int n)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.insert(info[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool Interpret(string info)</span><br><span class="line">    &#123;</span><br><span class="line">        return s.find(info) != s.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    set&lt;string&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AndExpression : public Expression</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AndExpression(Expression *city, Expression *person)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;city = city;</span><br><span class="line">        this-&gt;person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool Interpret(string info)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t pos = info.find(&apos;|&apos;);</span><br><span class="line">        if (pos == string::npos)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        string s1(info, 0, pos);</span><br><span class="line">        string s2(info, pos + 1, string::npos);</span><br><span class="line">        cout &lt;&lt; &quot;S1:&quot; &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;S2:&quot; &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return city-&gt;Interpret(string(info, 0, pos)) &amp;&amp; person-&gt;Interpret(string(info, pos + 1, string::npos));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Expression *city;</span><br><span class="line">    Expression *person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Context()</span><br><span class="line">    &#123;</span><br><span class="line">        string citys[] = &#123;&quot;hangzhou&quot;, &quot;nanjing&quot;, &quot;shanghai&quot;&#125;;</span><br><span class="line">        string persions[] = &#123;&quot;old&quot;, &quot;woman&quot;&#125;;</span><br><span class="line">        city = new TerminalExpression(citys, 3);</span><br><span class="line">        persion = new TerminalExpression(persions, 2);</span><br><span class="line">        cityPersion = new AndExpression(city, persion);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Context()</span><br><span class="line">    &#123;</span><br><span class="line">        delete city;</span><br><span class="line">        delete persion;</span><br><span class="line">        delete cityPersion;</span><br><span class="line">    &#125;</span><br><span class="line">    void FreeRide(string info)</span><br><span class="line">    &#123;</span><br><span class="line">        if (cityPersion-&gt;Interpret(info))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; info &lt;&lt; &quot;:&quot;</span><br><span class="line">                 &lt;&lt; &quot;You are a cared for, you can travel for free&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; info &lt;&lt; &quot;:&quot;</span><br><span class="line">                 &lt;&lt; &quot;shoud pay 2$&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Expression *cityPersion;</span><br><span class="line">    Expression *city;</span><br><span class="line">    Expression *persion;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Context *bus = new Context();</span><br><span class="line">    bus-&gt;FreeRide(&quot;hangzhou|old&quot;);</span><br><span class="line">    bus-&gt;FreeRide(&quot;hangzhou|young&quot;);</span><br><span class="line">    bus-&gt;FreeRide(&quot;hangzhou|woman&quot;);</span><br><span class="line">    bus-&gt;FreeRide(&quot;nanjing|old&quot;);</span><br><span class="line">    bus-&gt;FreeRide(&quot;nanjing|young&quot;);</span><br><span class="line">    bus-&gt;FreeRide(&quot;nanjing|woman&quot;);</span><br><span class="line">    delete bus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">S1:hangzhou</span><br><span class="line">S2:old</span><br><span class="line">hangzhou|old:You are a cared for, you can travel for free</span><br><span class="line">S1:hangzhou</span><br><span class="line">S2:young</span><br><span class="line">hangzhou|young:shoud pay 2$</span><br><span class="line">S1:hangzhou</span><br><span class="line">S2:woman</span><br><span class="line">hangzhou|woman:You are a cared for, you can travel for free</span><br><span class="line">S1:nanjing</span><br><span class="line">S2:old</span><br><span class="line">nanjing|old:You are a cared for, you can travel for free</span><br><span class="line">S1:nanjing</span><br><span class="line">S2:young</span><br><span class="line">nanjing|young:shoud pay 2$</span><br><span class="line">S1:nanjing</span><br><span class="line">S2:woman</span><br><span class="line">nanjing|woman:You are a cared for, you can travel for free</span><br></pre></td></tr></table></figure><p>以公交免费条件为例， 南京、上海、杭州本地老人及妇女免费</p><p>类图如下:</p><ul><li>Expression: 抽象表达式接口，包含解释方法Interpret</li><li>终结符表达式类: 用set接口匹配是否包含目标字符串</li><li>非中介表达式类: 包含满足条件的城市的终结符表达式对象和满足条件的人员的终结符表达式对象，并实现 interpret(String info) 方法，用来判断被分析的字符串是否是满足条件的城市中的满足条件的人员</li><li>环境类:定义一个环境（Context）类，它包含解释器需要的数据，完成对终结符表达式的初始化，并定义一个方法 freeRide(String info) 调用表达式对象的解释方法来对被分析的字符串进行解释</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>当语言的文法较为简单，且执行效率不是关键问题时。<br>当问题重复出现，且可以用一种简单的语言来进行表达时。<br>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</p><p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-备忘录模式</title>
      <link href="/2019/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特定">定义和特定</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义和特定"><a href="#定义和特定" class="headerlink" title="定义和特定"></a>定义和特定</h1><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫<strong>快照模式</strong></p><p>优点如下。</p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则</li></ul><p>主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><p><img src="/2019/09/28/设计模式/软件设计模式-备忘录模式/memento.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Memento</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Memento(string state)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    void SetState(string state)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    string GetState()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Caretaker</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void SetMemento(Memento *m)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;memento = m;</span><br><span class="line">    &#125;</span><br><span class="line">    Memento *GetMemento()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Memento *memento;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Originator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void SetState(string state)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    string GetState()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;state;</span><br><span class="line">    &#125;</span><br><span class="line">    Memento *CreateMemento()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    void RestoreMemento(Memento *m)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;SetState(m-&gt;GetState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Originator *ori = new Originator();</span><br><span class="line">    Caretaker *cr = new Caretaker();</span><br><span class="line"></span><br><span class="line">    ori-&gt;SetState(&quot;S0&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;origin:&quot; &lt;&lt; ori-&gt;GetState() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Memento *temp = ori-&gt;CreateMemento();</span><br><span class="line">    cr-&gt;SetMemento(temp);</span><br><span class="line">    ori-&gt;SetState(&quot;S1&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;new:&quot; &lt;&lt; ori-&gt;GetState() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ori-&gt;RestoreMemento(cr-&gt;GetMemento());</span><br><span class="line">    cout &lt;&lt; &quot;restore:&quot; &lt;&lt; ori-&gt;GetState() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    delete ori;</span><br><span class="line">    delete cr;</span><br><span class="line">    delete temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">origin:S0</span><br><span class="line">new:S1</span><br><span class="line">restore:S0</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li><li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-访问者模式</title>
      <link href="/2019/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离</p><p>优点如下</p><ul><li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li><li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li><li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一</li></ul><p>缺点如下</p><ul><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li><li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li><li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类</p><ul><li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li><li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li><li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li><li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li><li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现</li></ul><p><img src="/2019/09/28/设计模式/软件设计模式-访问者模式/visitor.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Visitor;</span><br><span class="line">class ConcreteElementA;</span><br><span class="line">class ConcreteElementB;</span><br><span class="line"></span><br><span class="line">class Element</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Element() &#123;&#125;</span><br><span class="line">    virtual ~Element() &#123;&#125;</span><br><span class="line">    virtual void Accpet(Visitor *visitor) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Visitor() &#123;&#125;</span><br><span class="line">    virtual ~Visitor() &#123;&#125;</span><br><span class="line">    virtual void Visit(ConcreteElementA *ele) = 0;</span><br><span class="line">    virtual void Visit(ConcreteElementB *ele) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteElementA : public Element</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Accpet(Visitor *visitor)</span><br><span class="line">    &#123;</span><br><span class="line">        visitor-&gt;Visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">    void OperationA()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call operationA()&quot; &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteElementB : public Element</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Accpet(Visitor *visitor)</span><br><span class="line">    &#123;</span><br><span class="line">        visitor-&gt;Visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">    void OperationB()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call OperationB()&quot; &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ObjectStructure</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Accpet(Visitor *v)</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;Element *&gt;::iterator it = l.begin();</span><br><span class="line">        while (it != l.end())</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;Accpet(v);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Add(Element *e)</span><br><span class="line">    &#123;</span><br><span class="line">        l.push_back(e);</span><br><span class="line">    &#125;</span><br><span class="line">    void Remove(Element *e)</span><br><span class="line">    &#123;</span><br><span class="line">        l.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;Element *&gt; l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteVistorA : public Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Visit(ConcreteElementA *ele)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;concreteVistorA call&quot; &lt;&lt; endl;</span><br><span class="line">        ele-&gt;OperationA();</span><br><span class="line">    &#125;</span><br><span class="line">    void Visit(ConcreteElementB *ele)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;concreteVistorA call&quot; &lt;&lt; endl;</span><br><span class="line">        ele-&gt;OperationB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class ConcreteVistorB : public Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Visit(ConcreteElementA *ele)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;concreteVistorB call&quot; &lt;&lt; endl;</span><br><span class="line">        ele-&gt;OperationA();</span><br><span class="line">    &#125;</span><br><span class="line">    void Visit(ConcreteElementB *ele)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;concreteVistorB call&quot; &lt;&lt; endl;</span><br><span class="line">        ele-&gt;OperationB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ObjectStructure *obj = new ObjectStructure();</span><br><span class="line">    Element *e1 = new ConcreteElementA();</span><br><span class="line">    Element *e2 = new ConcreteElementB();</span><br><span class="line">    obj-&gt;Add(e1);</span><br><span class="line">    obj-&gt;Add(e2);</span><br><span class="line"></span><br><span class="line">    Visitor *vistor1 = new ConcreteVistorA();</span><br><span class="line">    Visitor *vistor2 = new ConcreteVistorB();</span><br><span class="line">    obj-&gt;Accpet(vistor1);</span><br><span class="line">    obj-&gt;Accpet(vistor2);</span><br><span class="line"></span><br><span class="line">    delete obj;</span><br><span class="line">    delete e1;</span><br><span class="line">    delete e2;</span><br><span class="line">    delete vistor1;</span><br><span class="line">    delete vistor2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">concreteVistorA call</span><br><span class="line">call operationA()</span><br><span class="line">concreteVistorA call</span><br><span class="line">call OperationB()</span><br><span class="line">concreteVistorB call</span><br><span class="line">call operationA()</span><br><span class="line">concreteVistorB call</span><br><span class="line">call OperationB()</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>对象结构相对稳定，但其操作算法经常变化的程序。</li><li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li><li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-迭代器模式</title>
      <link href="/2019/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%ae%9a%e4%b9%89%e5%92%8c%e7%89%b9%e7%82%b9">定义和特点</a></li><li><a href="#%e7%bb%93%e6%9e%84%e5%92%8c%e5%ae%9e%e7%8e%b0">结构和实现</a></li></ul><!-- /TOC --><h1 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h1><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式</p><p>优点</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示</li><li>遍历任务交由迭代器完成， 简化了聚合类</li><li>支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历</li><li>增加新的聚合类和迭代器很方便，无需修改原有接口</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口</li></ul><p>缺点: 增加了类的个数，增加了系统的复杂性</p><h1 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h1><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据</p><p>象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。<br>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。<br>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。<br>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</p><p><img src="/2019/09/28/设计模式/软件设计模式-迭代器模式/iterator.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class Item&gt;</span><br><span class="line">class Iterator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Iterator()&#123;&#125;;</span><br><span class="line">    virtual ~Iterator()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    virtual void First() = 0;</span><br><span class="line">    virtual void Next() = 0;</span><br><span class="line">    virtual Item *CurItem() = 0;</span><br><span class="line">    virtual bool IsDone() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class Item&gt;</span><br><span class="line">class Aggregate</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Aggregate()&#123;&#125;;</span><br><span class="line">    virtual ~Aggregate()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    virtual void PushData(Item item) = 0;</span><br><span class="line">    virtual Iterator&lt;Item&gt; *CreateIterator() = 0;</span><br><span class="line">    virtual Item &amp;operator[](int index) = 0;</span><br><span class="line">    virtual int GetSize() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class Item&gt;</span><br><span class="line">class ConcreteIterator : public Iterator&lt;Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ConcreteIterator(Aggregate&lt;Item&gt; *a) : aggr(a), cur(0)&#123;&#125;;</span><br><span class="line">    virtual ~ConcreteIterator()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    virtual void First()</span><br><span class="line">    &#123;</span><br><span class="line">        cur = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Next()</span><br><span class="line">    &#123;</span><br><span class="line">        if (cur &lt; aggr-&gt;GetSize())</span><br><span class="line">        &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Item *CurItem()</span><br><span class="line">    &#123;</span><br><span class="line">        if (cur &lt; aggr-&gt;GetSize())</span><br><span class="line">        &#123;</span><br><span class="line">            return &amp;(*aggr)[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual bool IsDone()</span><br><span class="line">    &#123;</span><br><span class="line">        return cur &gt;= aggr-&gt;GetSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Aggregate&lt;Item&gt; *aggr;</span><br><span class="line">    int cur;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class Item&gt;</span><br><span class="line">class ConcreteAggregate : public Aggregate&lt;Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void PushData(Item item)</span><br><span class="line">    &#123;</span><br><span class="line">        data.push_back(item);</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Item&gt; *CreateIterator()</span><br><span class="line">    &#123;</span><br><span class="line">        return new ConcreteIterator&lt;Item&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line">    Item &amp;operator[](int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    int GetSize()</span><br><span class="line">    &#123;</span><br><span class="line">        return data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;Item&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Aggregate&lt;int&gt; *aggr = new ConcreteAggregate&lt;int&gt;();</span><br><span class="line">    aggr-&gt;PushData(3);</span><br><span class="line">    aggr-&gt;PushData(2);</span><br><span class="line">    aggr-&gt;PushData(1);</span><br><span class="line">    Iterator&lt;int&gt; *it = aggr-&gt;CreateIterator();</span><br><span class="line">    for (it-&gt;First(); !it-&gt;IsDone(); it-&gt;Next())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it-&gt;CurItem() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete aggr;</span><br><span class="line">    delete it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-中介者模式</title>
      <link href="/2019/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li><li><a href="#拓展">拓展</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互</p><p>主要优点如下</p><ul><li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li><li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li></ul><p>缺点:当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul><p><img src="/2019/09/24/设计模式/软件设计模式-中介者模式/mediator.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Mediator;</span><br><span class="line"></span><br><span class="line">class Colleague</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void SetMediator(Mediator *mediator)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Send() = 0;</span><br><span class="line">    virtual void Receive() = 0;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    Mediator *mediator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Mediator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Register(Colleague *c) = 0;</span><br><span class="line">    virtual void Replay(Colleague *c) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Colleague1 : public Colleague</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Send()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;colleague1 send msg&quot; &lt;&lt; endl;</span><br><span class="line">        mediator-&gt;Replay(this);</span><br><span class="line">    &#125;</span><br><span class="line">    void Receive()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;colleague1 receive msg&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Colleague2 : public Colleague</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Send()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;colleague2 send msg&quot; &lt;&lt; endl;</span><br><span class="line">        mediator-&gt;Replay(this);</span><br><span class="line">    &#125;</span><br><span class="line">    void Receive()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;colleague2 receive msg&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteMediator : public Mediator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Register(Colleague *c)</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;Colleague *&gt;::iterator it = colleagues.begin();</span><br><span class="line">        while (it != colleagues.end())</span><br><span class="line">        &#123;</span><br><span class="line">            if (*(it) == c)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        colleagues.push_back(c);</span><br><span class="line">        c-&gt;SetMediator(this);</span><br><span class="line">    &#125;</span><br><span class="line">    void Replay(Colleague *c)</span><br><span class="line">    &#123;</span><br><span class="line">        for (list&lt;Colleague *&gt;::iterator it = colleagues.begin(); it != colleagues.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((*it) != c)</span><br><span class="line">            &#123;</span><br><span class="line">                (*it)-&gt;Receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    list&lt;Colleague *&gt; colleagues;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Mediator *md = new ConcreteMediator();</span><br><span class="line"></span><br><span class="line">    Colleague *c1 = new Colleague1();</span><br><span class="line">    Colleague *c2 = new Colleague2();</span><br><span class="line"></span><br><span class="line">    md-&gt;Register(c1);</span><br><span class="line">    md-&gt;Register(c2);</span><br><span class="line">    c1-&gt;Send();</span><br><span class="line">    cout &lt;&lt; &quot;----&quot; &lt;&lt; endl;</span><br><span class="line">    c2-&gt;Send();</span><br><span class="line"></span><br><span class="line">    delete md;</span><br><span class="line">    delete c1;</span><br><span class="line">    delete c2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">colleague1 send msg</span><br><span class="line">colleague2 receive msg</span><br><span class="line">----</span><br><span class="line">colleague2 send msg</span><br><span class="line">colleague1 receive msg</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时<br>当想创建一个运行于多个类之间的对象，又不想生成新的子类时</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>通常采用以下两种方法来简化中介者模式，使开发变得更简单。<br>不定义中介者接口，把具体中介者对象实现成为单例。<br>同事对象不持有中介者，而是在需要的时f矣直接获取中介者对象并调用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-观察者模式</title>
      <link href="/2019/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式</p><p>优点:</p><ul><li>降低了目标和观察者之间耦合关系，二者师抽象耦合关系</li><li>目标和观察者之间建立了一套触发机制</li></ul><p>缺点:</p><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>具体主题（Concrete    Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><p><img src="/2019/09/24/设计模式/软件设计模式-观察者模式/observer.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Response(string msg) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteObserver1 : public Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Response(string msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;notify observer1:&quot; + msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteObserver2 : public Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Response(string msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;notify observer2:&quot; + msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Subject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Add(Observer *observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.push_back(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    void Remove(Observer *observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void NotifyObserver(string msg)</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator it;</span><br><span class="line">        for (it = observers.begin(); it != observers.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;Response(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    list&lt;Observer *&gt; observers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Subject *sub = new Subject();</span><br><span class="line">    Observer *obs1 = new ConcreteObserver1();</span><br><span class="line">    Observer *obs2 = new ConcreteObserver2();</span><br><span class="line">    sub-&gt;Add(obs1);</span><br><span class="line">    sub-&gt;Add(obs2);</span><br><span class="line"></span><br><span class="line">    sub-&gt;NotifyObserver(&quot;SIGHUP&quot;);</span><br><span class="line"></span><br><span class="line">    delete sub;</span><br><span class="line">    delete obs1;</span><br><span class="line">    delete obs2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notify observer1:SIGHUP</span><br><span class="line">notify observer2:SIGHUP</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>观察者模式适合以下几种情形。</p><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-状态模式</title>
      <link href="/2019/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为</p><p>优点:</p><ul><li>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li></ul><p>缺点如下。</p><ul><li>状态模式的使用必然会增加系统的类与对象的个数</li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete    State）角色：实现抽象状态所对应的行为</li></ul><p><img src="/2019/09/22/设计模式/软件设计模式-状态模式/state.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Context;</span><br><span class="line"></span><br><span class="line">class State</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Handle(Context *c) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStateA : public State</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Handle(Context *c)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;current state:A&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStateB : public State</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Handle(Context *c)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;current state:B&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void SetState(State *s)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;state = s;</span><br><span class="line">    &#125;</span><br><span class="line">    State *GetState()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;state;</span><br><span class="line">    &#125;</span><br><span class="line">    void Handle()</span><br><span class="line">    &#123;</span><br><span class="line">        state-&gt;Handle(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    State *state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    State *stateA = new ConcreteStateA();</span><br><span class="line">    State *stateB = new ConcreteStateB();</span><br><span class="line">    Context *c = new Context();</span><br><span class="line">    c-&gt;SetState(stateA);</span><br><span class="line">    c-&gt;Handle();</span><br><span class="line">    c-&gt;SetState(stateB);</span><br><span class="line">    c-&gt;Handle();</span><br><span class="line"></span><br><span class="line">    delete stateA;</span><br><span class="line">    delete stateB;</span><br><span class="line">    delete c;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current state:A</span><br><span class="line">current state:B</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-责任链模式</title>
      <link href="/2019/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#模式的应用场景">模式的应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了</p><p>优点:</p><ul><li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li><li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li><li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><p>缺点如下:</p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程</li></ul><p><img src="/2019/09/22/设计模式/软件设计模式-责任链模式/responsibility.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Handler() : next(nullptr) &#123;&#125;</span><br><span class="line">    void SetNext(Handler *next)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    Handler *GetNext()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void HandleRequest(string request) = 0;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Handler *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteHandler1 : public Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void HandleRequest(string request)</span><br><span class="line">    &#123;</span><br><span class="line">        if (request == &quot;one&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;concrete handler1 do it&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (GetNext())</span><br><span class="line">            &#123;</span><br><span class="line">                GetNext()-&gt;HandleRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;no one handle &quot; + request &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteHandler2 : public Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void HandleRequest(string request)</span><br><span class="line">    &#123;</span><br><span class="line">        if (request == &quot;two&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;concrete handler2 do it&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (GetNext())</span><br><span class="line">            &#123;</span><br><span class="line">                GetNext()-&gt;HandleRequest(request);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;no one handle &quot; + request &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Handler *handler1 = new ConcreteHandler1();</span><br><span class="line">    Handler *handler2 = new ConcreteHandler2();</span><br><span class="line"></span><br><span class="line">    handler1-&gt;SetNext(handler2);</span><br><span class="line"></span><br><span class="line">    handler1-&gt;HandleRequest(&quot;two&quot;);</span><br><span class="line">    handler1-&gt;HandleRequest(&quot;three&quot;);</span><br><span class="line"></span><br><span class="line">    delete handler1;</span><br><span class="line">    delete handler2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concrete handler2 do it</span><br><span class="line">no one handle three</span><br></pre></td></tr></table></figure></p><h1 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h1><ul><li>有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。</li><li>可动态指定一组对象处理请求，或添加新的处理者。</li><li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-命令模式</title>
      <link href="/2019/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理</p><p>优点:</p><ul><li>降低系统的耦合度</li><li>增加或删除命令非常方便</li><li>可以实现宏命令</li><li>便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复</li></ul><p>其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()</li><li>具体命令角色（Concrete    Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作</li><li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者</li><li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者</li></ul><p><img src="/2019/09/21/设计模式/软件设计模式-命令模式/command.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class ReceiverA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Action()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call reciverA Action()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ReceiverB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Action()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call reciverB Action()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Command</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Command() &#123;&#125;</span><br><span class="line">    virtual ~Command() &#123;&#125;</span><br><span class="line">    virtual void Execute() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteCommandA : public Command</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ConcreteCommandA()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver = new ReceiverA();</span><br><span class="line">    &#125;</span><br><span class="line">    ~ConcreteCommandA()</span><br><span class="line">    &#123;</span><br><span class="line">        delete receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver-&gt;Action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ReceiverA *receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteCommandB : public Command</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ConcreteCommandB()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver = new ReceiverB();</span><br><span class="line">    &#125;</span><br><span class="line">    ~ConcreteCommandB()</span><br><span class="line">    &#123;</span><br><span class="line">        delete receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver-&gt;Action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ReceiverB *receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Invoker</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Invoker(Command *cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;cmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    void SetCommand(Command *cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;cmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Call()</span><br><span class="line">    &#123;</span><br><span class="line">        cmd-&gt;Execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Command *cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Command *cmdA = new ConcreteCommandA();</span><br><span class="line">    Command *cmdB = new ConcreteCommandB();</span><br><span class="line">    Invoker *ir = new Invoker(cmdA);</span><br><span class="line">    ir-&gt;Call();</span><br><span class="line">    ir-&gt;SetCommand(cmdB);</span><br><span class="line">    ir-&gt;Call();</span><br><span class="line">    delete cmdA;</span><br><span class="line">    delete cmdB;</span><br><span class="line">    delete ir;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。</li><li>当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。</li><li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li><li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-策略模式</title>
      <link href="/2019/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</p><p>优点:</p><ul><li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li><li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li><li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li><li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li><li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li></ul><p>缺点:</p><ul><li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类</li><li>策略模式造成很多的策略类</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性</p><ul><li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><p><img src="/2019/09/21/设计模式/软件设计模式-策略模式/strategy.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Strategy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void StrategyMethod() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStrategyA : public Strategy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void StrategyMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;strategyA is called&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteStrategyB : public Strategy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void StrategyMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;strategyB is called&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Context</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Context() : strategy(nullptr) &#123;&#125;</span><br><span class="line">    void SetStrategy(Strategy *st)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;strategy = st;</span><br><span class="line">    &#125;</span><br><span class="line">    Strategy *GetStrategy()</span><br><span class="line">    &#123;</span><br><span class="line">        return strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    void StrategyMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        strategy-&gt;StrategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Strategy *strategy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Context *c = new Context();</span><br><span class="line">    Strategy *stA = new ConcreteStrategyA();</span><br><span class="line">    Strategy *stB = new ConcreteStrategyB();</span><br><span class="line"></span><br><span class="line">    c-&gt;SetStrategy(stA);</span><br><span class="line">    c-&gt;StrategyMethod();</span><br><span class="line"></span><br><span class="line">    c-&gt;SetStrategy(stB);</span><br><span class="line">    c-&gt;StrategyMethod();</span><br><span class="line"></span><br><span class="line">    delete stA;</span><br><span class="line">    delete stB;</span><br><span class="line">    delete c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strategyA is called</span><br><span class="line">strategyB is called</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。<br>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-模板方法模式</title>
      <link href="/2019/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特点">定义和特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h1><p>定义一个算法骨架,而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤</p><p>优点：</p><ul><li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展</li><li>它在父类中提取了公共的部分代码，便于代码复用</li><li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则</li></ul><p>缺点:</p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下</p><ul><li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法</li><li>基本方法：是整个算法中的一个步骤，包含以下几种类型。<ul><li>抽象方法：在抽象类中申明，由具体子类实现。</li><li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li><li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种</li></ul></li></ul></li><li><p>具体子类:实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤</p></li></ul><p><img src="/2019/09/21/设计模式/软件设计模式-模板方法模式/template.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class AbstractClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AbstractClass() &#123;&#125;</span><br><span class="line">    virtual ~AbstractClass() &#123;&#125;</span><br><span class="line">    void TemplateMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        AbstractMethod1();</span><br><span class="line">        AbstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    void SpecificMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;abstract special method&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void AbstractMethod1() &#123;&#125;</span><br><span class="line">    virtual void AbstractMethod2() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteClass : public AbstractClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void AbstractMethod1()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;concrete method1 is called&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void AbstractMethod2()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;concrete method2 is called&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    AbstractClass *abs = new ConcreteClass();</span><br><span class="line">    abs-&gt;TemplateMethod();</span><br><span class="line">    delete abs;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract special method</span><br><span class="line">concrete method1 is called</span><br><span class="line">concrete method2 is called</span><br></pre></td></tr></table></figure><p>通过调用接口TemplateMethod(), 将算法的一些步骤延迟到子类，</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-组合模式</title>
      <link href="/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性</p><p>优点:</p><ul><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”</li></ul><p>缺点:</p><ul><li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li><li>不容易限制容器中的构件；</li><li>不容易用继承的方法来增加构件的新功能；</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li><li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li><li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法</li></ul><p>组合模式分为透明式的组合模式和安全式的组合模式</p><ul><li>透明方式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题</li><li>安全方式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性</li></ul><p><img src="/2019/09/20/设计模式/软件设计模式-组合模式/composite.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Component</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Add(Component *c) = 0;</span><br><span class="line">    virtual void Remove(Component *c) = 0;</span><br><span class="line">    virtual Component *GetChild(int c) = 0;</span><br><span class="line">    virtual void Operation() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Leaf : public Component</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Leaf(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    void Add(Component *c)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Remove(Component *c)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Component *GetChild(int c)</span><br><span class="line">    &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;leaf &quot; + name + &quot; was be call&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Composite : public Component</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Add(Component *c)</span><br><span class="line">    &#123;</span><br><span class="line">        children.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    void Remove(Component *c)</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;Component *&gt;::iterator it;</span><br><span class="line">        for (it = children.begin(); it != children.end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            if (*it == c)</span><br><span class="line">            &#123;</span><br><span class="line">                children.erase(it);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Component *GetChild(int c)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        list&lt;Component *&gt;::iterator it;</span><br><span class="line">        for (it = children.begin(); it != children.end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i++ == c)</span><br><span class="line">            &#123;</span><br><span class="line">                return *it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        list&lt;Component *&gt;::iterator it;</span><br><span class="line">        for (it = children.begin(); it != children.end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;Operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    list&lt;Component *&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Component *c0 = new Composite();</span><br><span class="line">    Component *c1 = new Composite();</span><br><span class="line"></span><br><span class="line">    Component *leaf1 = new Leaf(&quot;1&quot;);</span><br><span class="line">    Component *leaf2 = new Leaf(&quot;2&quot;);</span><br><span class="line">    Component *leaf3 = new Leaf(&quot;3&quot;);</span><br><span class="line"></span><br><span class="line">    c0-&gt;Add(leaf1);</span><br><span class="line">    c0-&gt;Add(c1);</span><br><span class="line">    c1-&gt;Add(leaf2);</span><br><span class="line">    c1-&gt;Add(leaf3);</span><br><span class="line">    c0-&gt;Operation();</span><br><span class="line"></span><br><span class="line">    delete c0;</span><br><span class="line">    delete c1;</span><br><span class="line">    delete leaf1;</span><br><span class="line">    delete leaf2;</span><br><span class="line">    delete leaf3;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">leaf 1 was be call</span><br><span class="line">leaf 2 was be call</span><br><span class="line">leaf 3 was be call</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol><li>在需要表示一个对象整体与部分的层次结构的场合</li><li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-享元模式</title>
      <link href="/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率</p><p>优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><p>缺点是：</p><ul><li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li><li>读取享元模式的外部状态会使得运行时间稍微变长。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>享元模式中存在以下两种状态：</p><ul><li>内部状态，即不会随着环境的改变而改变的可共享部分；</li><li><p>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。</p></li><li><p>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入</p></li><li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li><li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li><li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class UnsharedConcreteFlyweight</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    UnsharedConcreteFlyweight(string s) : info(s)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void SetInfo(string info)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    string GetInfo()</span><br><span class="line">    &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string info;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Flyweight</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Operation(UnsharedConcreteFlyweight *state) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteFlyweight1 : public Flyweight</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ConcreteFlyweight1(string key)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;key = key;</span><br><span class="line">        cout &lt;&lt; &quot;shared key:&quot; + key + &quot; was be created&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Operation(UnsharedConcreteFlyweight *state)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;shared key:&quot; + key + &quot; was be called&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;unshared info:&quot; + state-&gt;GetInfo() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteFlyweight2 : public Flyweight</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ConcreteFlyweight2(string key)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;key = key;</span><br><span class="line">        cout &lt;&lt; &quot;shared key:&quot; + key + &quot; was be created&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Operation(UnsharedConcreteFlyweight *state)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;shared key:&quot; + key + &quot; was be called&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;unshared info:&quot; + state-&gt;GetInfo() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class FlyweightFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Flyweight *GetFlyweight(string key)</span><br><span class="line">    &#123;</span><br><span class="line">        Flyweight *flyweight = nullptr;</span><br><span class="line">        map&lt;string, Flyweight *&gt;::iterator it = flyweights.find(key);</span><br><span class="line">        if (it == flyweights.end())</span><br><span class="line">        &#123;</span><br><span class="line">            flyweight = new ConcreteFlyweight1(key);</span><br><span class="line">            flyweights[key] = flyweight;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            flyweight = it-&gt;second;</span><br><span class="line">            cout &lt;&lt; &quot;shared key:&quot; + key + &quot; was exists&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return flyweight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    map&lt;string, Flyweight *&gt; flyweights;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    FlyweightFactory *facotory = new FlyweightFactory();</span><br><span class="line">    Flyweight *f01 = facotory-&gt;GetFlyweight(&quot;a&quot;);</span><br><span class="line">    Flyweight *f02 = facotory-&gt;GetFlyweight(&quot;a&quot;);</span><br><span class="line">    Flyweight *f03 = facotory-&gt;GetFlyweight(&quot;a&quot;);</span><br><span class="line">    Flyweight *f11 = facotory-&gt;GetFlyweight(&quot;b&quot;);</span><br><span class="line">    Flyweight *f12 = facotory-&gt;GetFlyweight(&quot;b&quot;);</span><br><span class="line">    UnsharedConcreteFlyweight *unshared01 = new UnsharedConcreteFlyweight(&quot;unshared01&quot;);</span><br><span class="line">    UnsharedConcreteFlyweight *unshared02 = new UnsharedConcreteFlyweight(&quot;unshared02&quot;);</span><br><span class="line">    UnsharedConcreteFlyweight *unshared03 = new UnsharedConcreteFlyweight(&quot;unshared03&quot;);</span><br><span class="line">    f01-&gt;Operation(unshared01);</span><br><span class="line">    f02-&gt;Operation(unshared02);</span><br><span class="line">    f03-&gt;Operation(unshared03);</span><br><span class="line">    f11-&gt;Operation(unshared01);</span><br><span class="line">    f12-&gt;Operation(unshared02);</span><br><span class="line"></span><br><span class="line">    delete facotory;</span><br><span class="line">    delete f01;</span><br><span class="line">    delete f11;</span><br><span class="line">    delete unshared01;</span><br><span class="line">    delete unshared02;</span><br><span class="line">    delete unshared03;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">shared key:a was be created</span><br><span class="line">shared key:a was exists</span><br><span class="line">shared key:a was exists</span><br><span class="line">shared key:b was be created</span><br><span class="line">shared key:b was exists</span><br><span class="line">shared key:a was be called</span><br><span class="line">unshared info:unshared01</span><br><span class="line">shared key:a was be called</span><br><span class="line">unshared info:unshared02</span><br><span class="line">shared key:a was be called</span><br><span class="line">unshared info:unshared03</span><br><span class="line">shared key:b was be called</span><br><span class="line">unshared info:unshared01</span><br><span class="line">shared key:b was be called</span><br><span class="line">unshared info:unshared02</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。</p><ul><li>系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。</li><li>大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。</li><li>由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-外观模式</title>
      <link href="/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><p>一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标</p><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>优点:</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ul><p>缺点如下:</p><ul><li>不能很好地限制客户使用子系统类</li><li><p>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</p></li><li><p>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</p></li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li><li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li></ul><p><img src="/2019/09/20/设计模式/软件设计模式-外观模式/facade.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class SubSystem01</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SubSystem01() &#123;&#125;</span><br><span class="line">    void Method()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call subsystem01 method&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SubSystem02</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SubSystem02() &#123;&#125;</span><br><span class="line">    void Method()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call subsystem02 method&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class SubSystem03</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SubSystem03() &#123;&#125;</span><br><span class="line">    void Method()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call subsystem03 method&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Facade</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Facade()</span><br><span class="line">    &#123;</span><br><span class="line">        obj1 = new SubSystem01();</span><br><span class="line">        obj2 = new SubSystem02();</span><br><span class="line">        obj3 = new SubSystem03();</span><br><span class="line">    &#125;</span><br><span class="line">    ~Facade()</span><br><span class="line">    &#123;</span><br><span class="line">        delete obj1;</span><br><span class="line">        delete obj2;</span><br><span class="line">        delete obj3;</span><br><span class="line">    &#125;</span><br><span class="line">    void Method()</span><br><span class="line">    &#123;</span><br><span class="line">        obj1-&gt;Method();</span><br><span class="line">        obj2-&gt;Method();</span><br><span class="line">        obj3-&gt;Method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    SubSystem01 *obj1;</span><br><span class="line">    SubSystem02 *obj2;</span><br><span class="line">    SubSystem03 *obj3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Facade *f = new Facade();</span><br><span class="line">    f-&gt;Method();</span><br><span class="line">    delete f;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">call subsystem01 method</span><br><span class="line">call subsystem02 method</span><br><span class="line">call subsystem03 method</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。<br>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。<br>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-装饰模式</title>
      <link href="/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式</p><p>优点</p><ul><li>采用装饰模式扩展对象的功能比采用继承方式更加灵活</li><li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合</li></ul><p>缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标</p><p>装饰模式主要包含以下角色。</p><ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ul><p><img src="/2019/09/20/设计模式/软件设计模式-装饰模式/decorator.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Component</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Operation() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteComponent : public Component</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;ConcreteComponent: call Operation&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Decorator : public Component</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Decorator(Component *component)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        component-&gt;Operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Component *component;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator1 : public Decorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ConcreteDecorator1(Component *comp) : Decorator(comp)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        Decorator::Operation();</span><br><span class="line">        AddedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    void AddedFunction()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;add extened fucnction1()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator2 : public Decorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ConcreteDecorator2(Component *comp) : Decorator(comp)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Operation()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;call decorator2 operation&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void AddedFunction()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;add extened fucnction2()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Component *component = new ConcreteComponent();</span><br><span class="line">    Component *decorator = new ConcreteDecorator1(component);</span><br><span class="line">    decorator-&gt;Operation();</span><br><span class="line">    delete component;</span><br><span class="line">    delete decorator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">ConcreteComponent: call Operation</span><br><span class="line">add extened fucnction1()</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li><li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。</li><li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-桥接模式</title>
      <link href="/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义与特点">定义与特点</a></li><li><a href="#结构与实现">结构与实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</p><p>桥接（Bridge）模式的优点是：</p><ul><li>由于抽象与实现分离，所以扩展能力强</li><li>其实现细节对客户透明</li></ul><p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><ul><li>抽象化（Abstraction）角色:义抽象类，并包含一个对实现化对象的引用</li><li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法</li><li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用</li><li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现</li></ul><p><img src="/2019/09/19/设计模式/软件设计模式-桥接模式/bridge.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Subject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Subject() &#123;&#125;</span><br><span class="line">    virtual ~Subject() &#123;&#125;</span><br><span class="line">    virtual void Request() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RealSubject : public Subject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;realsubject:request&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Proxy : public Subject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Proxy() : realSubject(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (realSubject == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject = new RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Proxy()</span><br><span class="line">    &#123;</span><br><span class="line">        delete realSubject;</span><br><span class="line">    &#125;</span><br><span class="line">    void PreRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;proxy:pre request&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        PreRequest();</span><br><span class="line">        realSubject-&gt;Request();</span><br><span class="line">        PostRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    void PostRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;proxy:post request&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RealSubject *realSubject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Proxy *proxy = new Proxy();</span><br><span class="line">    proxy-&gt;Request();</span><br><span class="line">    delete proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">Call refined Abstraction </span><br><span class="line">ConcreteImplementorA:call OperationImpl</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>桥接模式通常适用于以下场景</p><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-适配器模式</title>
      <link href="/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特定">定义和特定</a></li><li><a href="#结构和实现">结构和实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义和特定"><a href="#定义和特定" class="headerlink" title="定义和特定"></a>定义和特定</h1><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<strong>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些</strong></p><p>优点:</p><ul><li>客户端通过适配器可以透明地调用目标接口</li><li>复用现存地类，程序员不需要修改原有代码而重用现有的适配类</li></ul><p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂</p><h1 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h1><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者</li></ul><p>类适配器:<br><img src="/2019/09/19/设计模式/软件设计模式-适配器模式/class_adpater.png" alt=""><br>对象适配器:<br><img src="/2019/09/19/设计模式/软件设计模式-适配器模式/object_adapter.png" alt=""></p><p>class_apapter.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Request() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adaptee</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void SpecificRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;adaptee: call specificRequest&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassAdapter : public Adaptee, public Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        SpecificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argvp[])</span><br><span class="line">&#123;</span><br><span class="line">    Target *target = new ClassAdapter();</span><br><span class="line">    target-&gt;Request();</span><br><span class="line">    delete target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>object_adpater.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Adaptee</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void SpecialRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Adaptee: call SepcialRequest&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Request() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ObjectApapter:public Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ObjectApapter(Adaptee *adp):adapter(adp)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Request()&#123;</span><br><span class="line">        adapter-&gt;SpecialRequest();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Adaptee *adapter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Adaptee *adaptee = new Adaptee();</span><br><span class="line">    Target *objAdapter = new ObjectApapter(adaptee);</span><br><span class="line">    objAdapter-&gt;Request();</span><br><span class="line">    delete objAdapter;</span><br><span class="line">    delete adaptee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>适配器模式（Adapter）通常适用于以下场景。<br>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。<br>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-代理模式</title>
      <link href="/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特定">定义和特定</a></li><li><a href="#结构和实现">结构和实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义和特定"><a href="#定义和特定" class="headerlink" title="定义和特定"></a>定义和特定</h1><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介</p><p>主要优点</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul><p>主要缺点是：</p><ul><li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢</li><li>增加了系统的复杂度</li></ul><h1 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h1><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能</li></ul><p><img src="/2019/09/19/设计模式/软件设计模式-代理模式/proxy.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Subject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Subject()&#123;&#125;</span><br><span class="line">    virtual ~Subject()&#123;&#125;</span><br><span class="line">    virtual void Request() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RealSubject:public Subject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;realsubject:request&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Proxy:public Subject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Proxy():realSubject(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(realSubject == nullptr) &#123;</span><br><span class="line">            realSubject = new RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Proxy()</span><br><span class="line">    &#123;</span><br><span class="line">        delete realSubject;</span><br><span class="line">    &#125;</span><br><span class="line">    void PreRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;proxy:pre request&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        PreRequest();</span><br><span class="line">        realSubject-&gt;Request();</span><br><span class="line">        PostRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    void PostRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;proxy:post request&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    RealSubject *realSubject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Proxy *proxy = new Proxy();</span><br><span class="line">    proxy-&gt;Request();</span><br><span class="line">    delete proxy;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">proxy:pre request</span><br><span class="line">realsubject:request</span><br><span class="line">proxy:post request</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li><li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li><li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li><li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li><li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-建造者模式</title>
      <link href="/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特定">定义和特定</a></li><li><a href="#结构和实现">结构和实现</a></li><li><a href="#应用场景">应用场景</a></li><li><a href="#模式的拓展">模式的拓展</a></li></ul><!-- /TOC --><h1 id="定义和特定"><a href="#定义和特定" class="headerlink" title="定义和特定"></a>定义和特定</h1><p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的</p><p>优点:</p><ul><li>各个具体的建造者相互独立，有利于系统的扩展。</li><li>客户端不必知道产品内部组成的细节，便于控制细节风险</li></ul><p>缺点</p><ul><li>产品的组成部分必须相同，这限制了其使用范围</li><li>如果产品的内部变化复杂，该模式会增加很多的建造者类</li></ul><p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程</p><h1 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h1><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成</p><ul><li>产品角色:它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件</li><li>抽象建造者:它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()</li><li>具体建造者:实现 Builder 接口，完成复杂产品的各个部件的具体创建方法</li><li>指挥者:调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。<br>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。<br>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的</p><p>客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。</p><p>这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。</p><p>另外，客厅类中提供了 show() 方法，可以将装修效果图显示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parlour</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void SetWall(string wall)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line">    void SetTV(string tv)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    void SetSoft(string soft)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;soft = soft;</span><br><span class="line">    &#125;</span><br><span class="line">    void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;wall:&quot; &lt;&lt; wall &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;tv:&quot; &lt;&lt; tv &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;soft:&quot; &lt;&lt; soft &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string wall;</span><br><span class="line">    ;</span><br><span class="line">    string tv;</span><br><span class="line">    string soft;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Decorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Decorator()</span><br><span class="line">    &#123;</span><br><span class="line">        product = new Parlour();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Decorator()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuildWall() = 0;</span><br><span class="line">    virtual void BuildTV() = 0;</span><br><span class="line">    virtual void BuildSoft() = 0;</span><br><span class="line">    Parlour *GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    Parlour *product;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator1 : public Decorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void BuildWall()</span><br><span class="line">    &#123;</span><br><span class="line">        product-&gt;SetWall(&quot;wall1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void BuildTV()</span><br><span class="line">    &#123;</span><br><span class="line">        product-&gt;SetTV(&quot;tv1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void BuildSoft()</span><br><span class="line">    &#123;</span><br><span class="line">        product-&gt;SetSoft(&quot;soft1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class ConcreteDecorator2 : public Decorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void BuildWall()</span><br><span class="line">    &#123;</span><br><span class="line">        product-&gt;SetWall(&quot;wall2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void BuildTV()</span><br><span class="line">    &#123;</span><br><span class="line">        product-&gt;SetTV(&quot;tv2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void BuildSoft()</span><br><span class="line">    &#123;</span><br><span class="line">        product-&gt;SetSoft(&quot;soft2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ProjectManager</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ProjectManager(Decorator *builder)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    Parlour *Decorate()</span><br><span class="line">    &#123;</span><br><span class="line">        builder-&gt;BuildWall();</span><br><span class="line">        builder-&gt;BuildTV();</span><br><span class="line">        builder-&gt;BuildSoft();</span><br><span class="line">        return builder-&gt;GetResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Decorator *builder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Decorator *d = new ConcreteDecorator2;</span><br><span class="line">    ProjectManager *m = new ProjectManager(d);</span><br><span class="line">    Parlour *p = m-&gt;Decorate();</span><br><span class="line">    p-&gt;Show();</span><br><span class="line"></span><br><span class="line">    delete d;</span><br><span class="line">    delete m;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">wall:wall2</span><br><span class="line">tv:tv2</span><br><span class="line">soft:soft2</span><br></pre></td></tr></table></figure><h1 id="模式的拓展"><a href="#模式的拓展" class="headerlink" title="模式的拓展"></a>模式的拓展</h1><p>建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-抽象工厂模式</title>
      <link href="/2019/09/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特定">定义和特定</a></li><li><a href="#结构和实现">结构和实现</a></li><li><a href="#应用场景">应用场景</a></li><li><a href="#模式的拓展">模式的拓展</a></li></ul><!-- /TOC --><h1 id="定义和特定"><a href="#定义和特定" class="headerlink" title="定义和特定"></a>定义和特定</h1><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p>使用抽象工厂模式一般要满足以下条件。</p><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用</li></ul><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理</li><li>当增加一个新的产品族时不需要修改原代码，满足开闭原则</li></ul><p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h1 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h1><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同</p><p>抽象工厂模式的主要角色如下。</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><img src="/2019/09/18/设计模式/软件设计模式-抽象工厂模式/abstractFactory.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Animal() &#123;&#125;</span><br><span class="line">    virtual ~Animal() &#123;&#125;</span><br><span class="line">    virtual void Show() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class Plant</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Plant() &#123;&#125;</span><br><span class="line">    virtual ~Plant() &#123;&#125;</span><br><span class="line">    virtual void Show() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Horse:public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Show() </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;horse&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cattle:public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;cattle&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Fruitage:public Plant</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;fruitage&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Vegetables:public Plant</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;vegetables&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Farm</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Farm() &#123;&#125;</span><br><span class="line">    virtual ~Farm() &#123;&#125;</span><br><span class="line">    virtual Animal *NewAnimal() = 0;</span><br><span class="line">    virtual Plant *NewPlant() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SRFarm:public Farm</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Animal *NewAnimal()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Horse();</span><br><span class="line">    &#125;</span><br><span class="line">    Plant *NewPlant() </span><br><span class="line">    &#123;</span><br><span class="line">        return new Fruitage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SGFrame:public Farm</span><br><span class="line">&#123;</span><br><span class="line">    Animal *NewAnimal()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Cattle();</span><br><span class="line">    &#125;</span><br><span class="line">    Plant *NewPlant() </span><br><span class="line">    &#123;</span><br><span class="line">        return new Vegetables();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Farm *srfarm = new SRFarm();</span><br><span class="line">    Farm *sgfram = new SGFrame();</span><br><span class="line">    Animal *horse = srfarm-&gt;NewAnimal();</span><br><span class="line">    Animal *cattle = sgfram-&gt;NewAnimal();</span><br><span class="line">    Plant *fruitage = srfarm-&gt;NewPlant();</span><br><span class="line">    Plant *vegetables = sgfram-&gt;NewPlant();</span><br><span class="line"></span><br><span class="line">    horse-&gt;Show();</span><br><span class="line">    cattle-&gt;Show();</span><br><span class="line">    fruitage-&gt;Show();</span><br><span class="line">    vegetables-&gt;Show();</span><br><span class="line"></span><br><span class="line">    delete srfarm;</span><br><span class="line">    delete sgfram;</span><br><span class="line">    delete horse;</span><br><span class="line">    delete cattle;</span><br><span class="line">    delete fruitage;</span><br><span class="line">    delete vegetables;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">horse</span><br><span class="line">cattle</span><br><span class="line">fruitage</span><br><span class="line">vegetables</span><br></pre></td></tr></table></figure><h1 id="模式的拓展"><a href="#模式的拓展" class="headerlink" title="模式的拓展"></a>模式的拓展</h1><p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p><ul><li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li><li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li></ul><p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-工厂模式</title>
      <link href="/2019/09/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特定">定义和特定</a></li><li><a href="#结构和实现">结构和实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义和特定"><a href="#定义和特定" class="headerlink" title="定义和特定"></a>定义和特定</h1><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中，这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><p>优点:</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><h1 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h1><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成</p><ul><li>抽象工厂: 提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品</li><li>具体工厂: 主要是实现抽象工厂中的抽象方法，完成具体产品的创建</li><li>抽象产品: 定义了产品的规范，描述了产品的主要特性和功能</li><li>具体产品: 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合。</p><p>对养马场和养牛场等具体工厂类，只要定义一个生成动物的方法 newAnimal() 即可。由于要显示马类和牛类等具体产品类的图像，所以它们的构造函数中用到了 JPanel、JLabd 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们</p><p><img src="/2019/09/18/设计模式/软件设计模式-工厂模式/factory.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Animal()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Animal()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Show() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Horse : public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Horse()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Horse()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;show horse&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cattle : public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Cattle()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Cattle()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;show cattle&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class AnimalFarm</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AnimalFarm()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~AnimalFarm()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Animal *NewAnimal() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HorseFarm : public AnimalFarm</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    HorseFarm()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~HorseFarm()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal *NewAnimal()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Horse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class CattleFarm : public AnimalFarm</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CattleFarm()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~CattleFarm()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal *NewAnimal()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Cattle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    AnimalFarm *horsefarm = new HorseFarm();</span><br><span class="line">    AnimalFarm *cattlefarm = new CattleFarm();</span><br><span class="line">    Animal *horse = horsefarm-&gt;NewAnimal();</span><br><span class="line">    Animal *cattle = cattlefarm-&gt;NewAnimal();</span><br><span class="line">    horse-&gt;Show();</span><br><span class="line">    cattle-&gt;Show();</span><br><span class="line"></span><br><span class="line">    delete horse;</span><br><span class="line">    delete cattle;</span><br><span class="line">    delete horsefarm;</span><br><span class="line">    delete cattlefarm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">show horse</span><br><span class="line">show cattle</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-原型模式</title>
      <link href="/2019/09/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特点">定义和特点</a></li><li><a href="#结构和实现">结构和实现</a></li><li><a href="#应用场景">应用场景</a></li><li><a href="#原型模式的拓展">原型模式的拓展</a></li></ul><!-- /TOC --><h1 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h1><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节</p><h1 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h1><p>原型模式包含以下主要角色。</p><ul><li>抽象原型类：规定了具体原型对象必须实现的接口</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>对象之间相同或相似，即只是个别的几个属性不同的时候。<br>对象的创建过程比较麻烦，但复制比较简单的时候。</p><p><img src="/2019/09/17/设计模式/软件设计模式-原型模式/prototype.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Prototype</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    Prototype(int v):value(v)&#123;&#125;</span><br><span class="line">    virtual ~Prototype()&#123;&#125;</span><br><span class="line">    virtual Prototype *clone() = 0;</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Realizetype:public Prototype</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Realizetype(int v):Prototype(v) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Realizetype *clone()&#123;</span><br><span class="line">        return new Realizetype(*this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Prototype *obj1 = new Realizetype(10);</span><br><span class="line">    Prototype *obj2 = obj1-&gt;clone();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;obj1 value:&quot;&lt;&lt;obj1-&gt;value&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;obj2 value:&quot;&lt;&lt;obj2-&gt;value&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    delete obj1, obj2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">obj1 value:10</span><br><span class="line">obj2 value:10</span><br></pre></td></tr></table></figure><h1 id="原型模式的拓展"><a href="#原型模式的拓展" class="headerlink" title="原型模式的拓展"></a>原型模式的拓展</h1><p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型</p><p><img src="/2019/09/17/设计模式/软件设计模式-原型模式/prototype-pro.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Cloneable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual Cloneable *Clone() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shape : public Cloneable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Shape()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Shape()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    virtual Shape *Clone() = 0;</span><br><span class="line">    virtual double CountArea() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Circle : public Shape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Circle *Clone()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Circle(*this);</span><br><span class="line">    &#125;</span><br><span class="line">    double CountArea()</span><br><span class="line">    &#123;</span><br><span class="line">        int r = 0;</span><br><span class="line">        cout &lt;&lt; &quot;input radius:&quot;;</span><br><span class="line">        cin &gt;&gt; r;</span><br><span class="line">        return r * r * 3.1415926;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Square : public Shape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Shape *Clone()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Square(*this);</span><br><span class="line">    &#125;</span><br><span class="line">    double CountArea()</span><br><span class="line">    &#123;</span><br><span class="line">        int w = 0, h = 0;</span><br><span class="line">        cout &lt;&lt; &quot;\ninput width:&quot;;</span><br><span class="line">        cin &gt;&gt; w;</span><br><span class="line">        cout &lt;&lt; &quot;\ninput height:&quot;;</span><br><span class="line">        cin &gt;&gt; h;</span><br><span class="line">        return w * h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ProtoTypeManager</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ProtoTypeManager()</span><br><span class="line">    &#123;</span><br><span class="line">        AddShape(&quot;Circle&quot;, new Circle());</span><br><span class="line">        AddShape(&quot;Square&quot;, new Square());</span><br><span class="line">    &#125;</span><br><span class="line">    ~ProtoTypeManager()</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, Shape *&gt;::iterator it = hp.begin();</span><br><span class="line">        while (it != hp.end())</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;second)</span><br><span class="line">            &#123;</span><br><span class="line">                delete it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void AddShape(string key, Shape *obj)</span><br><span class="line">    &#123;</span><br><span class="line">        hp[key] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    Shape *GetShape(string key)</span><br><span class="line">    &#123;</span><br><span class="line">        Shape *shape = nullptr;</span><br><span class="line">        if (hp.find(key) != hp.end())</span><br><span class="line">        &#123;</span><br><span class="line">            shape = hp[key]-&gt;Clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    map&lt;string, Shape *&gt; hp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ProtoTypeManager *pm = new ProtoTypeManager();</span><br><span class="line">    Shape *circle = pm-&gt;GetShape(&quot;Circle&quot;);</span><br><span class="line">    Shape *square = pm-&gt;GetShape(&quot;Square&quot;);</span><br><span class="line"></span><br><span class="line">    assert(pm != nullptr);</span><br><span class="line">    assert(circle != nullptr);</span><br><span class="line">    assert(square != nullptr);</span><br><span class="line"></span><br><span class="line">    double circleArea = circle-&gt;CountArea();</span><br><span class="line">    double squareArea = square-&gt;CountArea();</span><br><span class="line">    cout &lt;&lt; &quot;circle area:&quot; &lt;&lt;circleArea &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;square area:&quot; &lt;&lt;squareArea &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    delete pm;</span><br><span class="line">    delete circle;</span><br><span class="line">    delete square;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">input radius:1</span><br><span class="line"></span><br><span class="line">input width:1</span><br><span class="line">input height:2</span><br><span class="line"></span><br><span class="line">circle area:3.14159</span><br><span class="line">square area:2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-单例模式</title>
      <link href="/2019/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#定义和特定">定义和特定</a></li><li><a href="#结构和实现">结构和实现</a></li><li><a href="#应用场景">应用场景</a></li></ul><!-- /TOC --><h1 id="定义和特定"><a href="#定义和特定" class="headerlink" title="定义和特定"></a>定义和特定</h1><p>单例模式(Singleton)定义:指一个类只有一个实例，且该类能自行创建这个实例的一种模式;例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例</p><p>单例模式有 3 个特点：</p><ul><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点；</li></ul><h1 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h1><p>单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><img src="/2019/09/16/设计模式/软件设计模式-单例模式/singleton.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Log</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static Log* GetInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        static Log *instance = nullptr;</span><br><span class="line">        if(!instance) &#123;</span><br><span class="line">            instance = new Log();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Log *logInstance1 = Log::GetInstance();</span><br><span class="line">    Log *logInstance2 = Log::GetInstance();</span><br><span class="line">    cout&lt;&lt;&quot;log1 address:&quot;&lt;&lt;logInstance1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;log2 address:&quot;&lt;&lt;logInstance2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    delete logInstance1;</span><br><span class="line">    delete logInstance2;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">log1 address:0x557d8bf20e70</span><br><span class="line">log2 address:0x557d8bf20e70</span><br></pre></td></tr></table></figure><p>代码可见:<a href="https://github.com/CuijianSa/utils/tree/master/design-patterns" target="_blank" rel="noopener">singleton</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-合成服用原则</title>
      <link href="/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/"/>
      <url>/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%ae%9a%e4%b9%89">定义</a></li><li><a href="#%e4%bd%9c%e7%94%a8">作用</a></li><li><a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95">实现方法</a></li></ul><!-- /TOC --><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p><strong>如果要使用继承关系，则必须严格遵循里氏替换原则</strong>。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><ul><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ul><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p><ul><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象</li></ul><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用</p><p><img src="/2019/09/15/设计模式/软件设计模式-合成复用原则/origin.JPG" alt=""><br>以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题</p><p><img src="/2019/09/15/设计模式/软件设计模式-合成复用原则/updated.JPG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-迪米特法则</title>
      <link href="/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
      <url>/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%ae%9a%e4%b9%89">定义</a></li><li><a href="#%e4%bc%98%e7%82%b9">优点</a></li><li><a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95">实现方法</a></li></ul><!-- /TOC --><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><ul><li>降低了类之间的耦合度，提高了模块的相对独立性。</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li></ul><p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰</p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>从迪米特法则的定义和特点可知，它强调以下两点：</p><ul><li>从依赖者的角度来说，只依赖应该依赖的对象。</li><li>从被依赖者的角度说，只暴露应该暴露的方法。</li></ul><p>所以，在运用迪米特法则时要注意以下 6 点。</p><ul><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li><li>谨慎使用序列化（Serializable）功能。</li></ul><p><img src="/2019/09/15/设计模式/软件设计模式-迪米特法则/LOD.JPG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-接口隔离原则</title>
      <link href="/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
      <url>/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%ae%9a%e4%b9%89">定义</a></li><li><a href="#%e4%bd%9c%e7%94%a8">作用</a></li><li><a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95">实现方法</a></li></ul><!-- /TOC --><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法</p><p>客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。</p><p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建</li></ul><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码</li></ul><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情</li></ul><p><img src="/2019/09/15/设计模式/软件设计模式-接口隔离原则/ISP.JPG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-单一职责原则</title>
      <link href="/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
      <url>/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%ae%9a%e4%b9%89">定义</a></li><li><a href="#%e4%bd%9c%e7%94%a8">作用</a></li><li><a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95">实现方法</a></li></ul><!-- /TOC --><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ul><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费</li></ul><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多</li><li>提高类的可读性。复杂性降低，自然其可读性会提高</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响</li></ul><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中</p><p><img src="/2019/09/15/设计模式/软件设计模式-单一职责原则/SRP.JPG" alt=""></p><p>单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-依赖倒置原则</title>
      <link href="/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
      <url>/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%ae%9a%e4%b9%89">定义</a></li><li><a href="#%e4%bd%9c%e7%94%a8">作用</a></li><li><a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95">实现方法</a></li></ul><!-- /TOC --><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>降低类之间的耦合性</li><li>提高系统的稳定性</li><li>减少并行开发引起的风险</li><li>提高代码的可读性和可维护性</li></ul><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则</p><ul><li>每个类尽量提供接口或者抽象类</li><li>变量的声明类型尽量式接口或者抽象类</li><li>任何类都不应该从具体类派生</li><li>使用继承时尽量遵从里氏替换原则</li></ul><p><img src="/2019/09/15/设计模式/软件设计模式-依赖倒置原则/DIP.JPG" alt=""></p><p>这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-里式替换原则</title>
      <link href="/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
      <url>/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%ae%9a%e4%b9%89">定义</a></li><li><a href="#%e4%bd%9c%e7%94%a8">作用</a></li><li><a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95">实现方法</a></li></ul><!-- /TOC --><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects</p><p>主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>里氏替换原则是实现开闭原则的重要方式之一</li><li>它克服了继承中重写父类造成的可复用性变差的缺点</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性</li></ul><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系</p><p><img src="/2019/09/15/设计模式/软件设计模式-里式替换原则/LSP.jpg" alt=""></p><p>燕子和几维鸟都是鸟类， 但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。 可以将Bird和BrownKiwi定义为Animal的子类</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-开闭原则</title>
      <link href="/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
      <url>/2019/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%e5%ae%9a%e4%b9%89">定义</a></li><li><a href="#%e4%bd%9c%e7%94%a8">作用</a></li><li><a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95">实现方法</a></li></ul><!-- /TOC --><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义</p><p>这里的软件实体包括以下几个部分：</p><ul><li>项目中划分出的模块</li><li>类与接口</li><li>方法</li></ul><p><strong>开闭原则的含义是</strong>：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性</p><ul><li>对软件测试的影响<br>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行</li><li>可以提高代码的可复用性<br>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性</li><li>可以提高软件的可维护性<br>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护</li></ul><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了</p><p><img src="/2019/09/15/设计模式/软件设计模式-开闭原则/demo.JPG" alt=""></p><p>抽象一个主题类， 每个主题都有共同的特点display, 可以为其定义一个抽象类（Abstract Subject），而每个具体的主题是其子类，用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-类与类之间的关系</title>
      <link href="/2019/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2019/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#1-%e7%b1%bb">1. 类</a><ul><li><a href="#11-%e7%b1%bb">1.1. 类</a></li><li><a href="#12-%e5%b1%9e%e6%80%a7">1.2. 属性</a></li><li><a href="#13-%e6%93%8d%e4%bd%9c">1.3. 操作</a></li></ul></li><li><a href="#2-%e6%8e%a5%e5%8f%a3">2. 接口</a></li><li><a href="#3-%e7%b1%bb%e5%9b%be">3. 类图</a></li><li><a href="#4-%e7%b1%bb%e4%b8%8e%e7%b1%bb%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb">4. 类与类之间的关系</a><ul><li><a href="#41-%e4%be%9d%e8%b5%96">4.1. 依赖</a></li><li><a href="#42-%e5%85%b3%e8%81%94">4.2. 关联</a></li><li><a href="#43-%e8%81%9a%e5%90%88">4.3. 聚合</a></li><li><a href="#44-%e7%bb%84%e5%90%88">4.4. 组合</a></li><li><a href="#45-%e6%b3%9b%e5%8c%96">4.5. 泛化</a></li><li><a href="#46-%e5%ae%9e%e7%8e%b0">4.6. 实现</a></li></ul></li></ul><!-- /TOC --><h1 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h1><h2 id="1-1-类"><a href="#1-1-类" class="headerlink" title="1.1. 类"></a>1.1. 类</h2><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性</p><h2 id="1-2-属性"><a href="#1-2-属性" class="headerlink" title="1.2. 属性"></a>1.2. 属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性]属性名:类型[=默认值]</span><br></pre></td></tr></table></figure><hr><p>“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。</p><h2 id="1-3-操作"><a href="#1-3-操作" class="headerlink" title="1.3. 操作"></a>1.3. 操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性]名称(参数列表)[:返回类型]</span><br></pre></td></tr></table></figure><h1 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h1><p>接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。<br><img src="/2019/09/13/设计模式/软件设计模式-类与类之间的关系/interface.gif" alt=""></p><h1 id="3-类图"><a href="#3-类图" class="headerlink" title="3. 类图"></a>3. 类图</h1><p>类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。</p><p>类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。图 3 所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用<br><img src="/2019/09/13/设计模式/软件设计模式-类与类之间的关系/class.gif" alt=""></p><h1 id="4-类与类之间的关系"><a href="#4-类与类之间的关系" class="headerlink" title="4. 类与类之间的关系"></a>4. 类与类之间的关系</h1><p>根据类与类之间的耦合度从弱到强排列：赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系</p><h2 id="4-1-依赖"><a href="#4-1-依赖" class="headerlink" title="4.1. 依赖"></a>4.1. 依赖</h2><p>使用一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在类中，某个类的方法通过局部变量、方法的参数或者静态方法的调用来访问另一个类的某一些方法<br><img src="/2019/09/13/设计模式/软件设计模式-类与类之间的关系/dependency.jpg" alt=""></p><h2 id="4-2-关联"><a href="#4-2-关联" class="headerlink" title="4.2. 关联"></a>4.2. 关联</h2><p>对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系<br><img src="/2019/09/13/设计模式/软件设计模式-类与类之间的关系/association.JPG" alt=""></p><h2 id="4-3-聚合"><a href="#4-3-聚合" class="headerlink" title="4.3. 聚合"></a>4.3. 聚合</h2><p>是关联关系的一种，是强关联关系，是整体和部分之间的关系,聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在<br><img src="/2019/09/13/设计模式/软件设计模式-类与类之间的关系/aggregation.JPG" alt=""></p><h2 id="4-4-组合"><a href="#4-4-组合" class="headerlink" title="4.4. 组合"></a>4.4. 组合</h2><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在<br><img src="/2019/09/13/设计模式/软件设计模式-类与类之间的关系/composition.JPG" alt=""></p><h2 id="4-5-泛化"><a href="#4-5-泛化" class="headerlink" title="4.5. 泛化"></a>4.5. 泛化</h2><p>对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系<br><img src="/2019/09/13/设计模式/软件设计模式-类与类之间的关系/generalization.JPG" alt=""></p><h2 id="4-6-实现"><a href="#4-6-实现" class="headerlink" title="4.6. 实现"></a>4.6. 实现</h2><p>是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作</p><p><img src="/2019/09/13/设计模式/软件设计模式-类与类之间的关系/realization.JPG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式-概述</title>
      <link href="/2019/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#1-什么是设计模式">1. 什么是设计模式</a></li><li><a href="#2-可以为我们解决什么问题">2. 可以为我们解决什么问题</a></li><li><a href="#3-应用场景是什么">3. 应用场景是什么</a><ul><li><a href="#31-原则">3.1. 原则</a></li><li><a href="#32-设计模式">3.2. 设计模式</a></li></ul></li><li><a href="#4-相关文档">4. 相关文档</a></li></ul><!-- /TOC --><h1 id="1-什么是设计模式"><a href="#1-什么是设计模式" class="headerlink" title="1. 什么是设计模式"></a>1. 什么是设计模式</h1><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结的一套设计模式，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是</p><h1 id="2-可以为我们解决什么问题"><a href="#2-可以为我们解决什么问题" class="headerlink" title="2. 可以为我们解决什么问题"></a>2. 可以为我们解决什么问题</h1><p>为了提高代码的可重用性、代码的可读性和代码的可靠性</p><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h1 id="3-应用场景是什么"><a href="#3-应用场景是什么" class="headerlink" title="3. 应用场景是什么"></a>3. 应用场景是什么</h1><table><thead><tr><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为模式</th></tr></thead><tbody><tr><td>类模式</td><td>工程方法</td><td>(类)适配器</td><td>模板方法</td></tr><tr><td>对象模式</td><td>单例 原型 抽象工程 建造者</td><td>代理 (对象)适配器 桥接 装饰 外观 享元 组合</td><td>策略 命令 职责链 状态 观察者 中介者 迭代器 访问器 备忘录</td></tr></tbody></table><p>一共分为<strong>23种设计模式</strong>及<strong>7个原则</strong></p><h2 id="3-1-原则"><a href="#3-1-原则" class="headerlink" title="3.1. 原则"></a>3.1. 原则</h2><ul><li>开闭原则:软件实体应当对扩展开放，对修改关闭</li><li>里氏替换原则:子类可以扩展父类的功能，但不能改变父类原有的功能</li><li>依赖倒置原则:高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象</li><li>单一职责原则:单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</li><li>接口隔离原则:一个类对另一个类的依赖应该建立在最小的接口上</li><li>迪米特法则:如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性</li><li>合成服用原则:尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</li></ul><h2 id="3-2-设计模式"><a href="#3-2-设计模式" class="headerlink" title="3.2. 设计模式"></a>3.2. 设计模式</h2><ul><li>单例模式:某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式</li><li>原型模式:将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例</li><li>工厂方法模式:定义一个用于创建产品的接口，由子类决定生产什么产品</li><li>抽象工厂模式:提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品</li><li>建造者模式:将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象</li><li>代理模式:为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性</li><li>适配器模式:将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作</li><li>桥接模式:将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</li><li>装饰模式：动态的给对象增加一些职责，即增加其额外的功能</li><li>外观模式:为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问</li><li>享元模式:运用共享技术来有效地支持大量细粒度对象的复用</li><li>组合模式:将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性</li><li>模板方法模式:定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤</li><li>策略模式:定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户</li><li>命令模式:将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开</li><li>责任链模式:把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合</li><li>状态模式:允许一个对象在其内部状态发生改变时改变其行为能力</li><li>观察者模式:多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为</li><li>中介模式:定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解</li><li>迭代器模式:提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</li><li>访问者模式:在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问</li><li>备忘录模式:在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它</li><li>解释器模式:提供如何定义语言的文法，以及对语言句子的解释方法，即解释器</li></ul><h1 id="4-相关文档"><a href="#4-相关文档" class="headerlink" title="4. 相关文档"></a>4. 相关文档</h1><ul><li>《Design Patterns: Elements of Reusable Object-Oriented Software》</li><li><a href="http://c.biancheng.net/view/1317.html" target="_blank" rel="noopener">软件设计模式概述</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>live555分析-流媒体数据传输</title>
      <link href="/2019/09/10/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-%E6%B5%81%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
      <url>/2019/09/10/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-%E6%B5%81%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<p>在 SETUP 请求之后，客户端会发起 PLAY 请求，以请求服务器开始传输音视频数据。在 PLAY 请求执行时，一定是已经执行过 SETUP 请求，建立好了客户端会话，因而会与其它要求客户端会话已经建立的请求一起，通过 clientSession-&gt;handleCmd_withinSession() 执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if (strcmp(cmdName, &quot;TEARDOWN&quot;) == 0</span><br><span class="line"> || strcmp(cmdName, &quot;PLAY&quot;) == 0</span><br><span class="line"> || strcmp(cmdName, &quot;PAUSE&quot;) == 0</span><br><span class="line"> || strcmp(cmdName, &quot;GET_PARAMETER&quot;) == 0</span><br><span class="line"> || strcmp(cmdName, &quot;SET_PARAMETER&quot;) == 0) &#123;</span><br><span class="line">if (clientSession != NULL) &#123;</span><br><span class="line">  clientSession-&gt;handleCmd_withinSession(this, cmdName, urlPreSuffix, urlSuffix, (char const*)fRequestBuffer);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  handleCmd_sessionNotFound();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，将streamName与前缀进行比较，通过trackId寻找到subsession, 找到subsession后LAY 请求通过RTSPServer::RTSPClientSession::handleCmd_PLAY() 函数处理：</p><p>第一步:解析scaleHeader, scale 值是用于控制播放速度的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Boolean sawScaleHeader = parseScaleHeader(fullRequestStr, scale);</span><br><span class="line"></span><br><span class="line">// Try to set the stream&apos;s scale factor to this value:</span><br><span class="line">if (subsession == NULL /*aggregate op*/) &#123;</span><br><span class="line">  fOurServerMediaSession-&gt;testScaleFactor(scale);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  subsession-&gt;testScaleFactor(scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char buf[100];</span><br><span class="line">char* scaleHeader;</span><br><span class="line">if (!sawScaleHeader) &#123;</span><br><span class="line">  buf[0] = &apos;\0&apos;; // Because we didn&apos;t see a Scale: header, don&apos;t send one back</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  sprintf(buf, &quot;Scale: %f\r\n&quot;, scale);</span><br><span class="line">&#125;</span><br><span class="line">scaleHeader = strDup(buf);</span><br></pre></td></tr></table></figure></p><p>应用于整个流媒体会话的 PLAY 请求，通过 ServerMediaSession::testScaleFactor(float&amp; scale) 设置 scale，应用于具体子会话的 PLAY 请求，则通过 ServerMediaSubsession 的 testScaleFactor(float&amp; scale) 设置</p><p>第二步：解析客户端Range， 并根据Range设置subsession seek</p>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ONVIF-使用gSOAP生成ONVIF框架代码</title>
      <link href="/2019/09/10/%E6%B5%81%E5%AA%92%E4%BD%93/ONVIF-%E4%BD%BF%E7%94%A8gSOAP%E7%94%9F%E6%88%90ONVIF%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81/"/>
      <url>/2019/09/10/%E6%B5%81%E5%AA%92%E4%BD%93/ONVIF-%E4%BD%BF%E7%94%A8gSOAP%E7%94%9F%E6%88%90ONVIF%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="gSOAP下载"><a href="#gSOAP下载" class="headerlink" title="gSOAP下载"></a>gSOAP下载</h1><ul><li>官方网址： <a href="http://www.cs.fsu.edu/~engelen/soap.html" target="_blank" rel="noopener">http://www.cs.fsu.edu/~engelen/soap.html</a></li><li>最新版本下载地址：<a href="http://sourceforge.net/projects/gsoap2" target="_blank" rel="noopener">http://sourceforge.net/projects/gsoap2</a></li></ul><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li>bison:apt-get install bison</li><li>flex: apt-get install flex</li></ul><h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><ul><li><a href="https://blog.csdn.net/benkaoya/article/details/72424335" target="_blank" rel="noopener">ONVIF协议网络摄像机（IPC）客户端程序开发（6）：使用gSOAP生成ONVIF框架代码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树算法!</title>
      <link href="/2019/09/08/%E6%9E%B6%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/08/%E6%9E%B6%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#什么是红黑树">什么是红黑树</a></li><li><a href="#红黑树解决了什么问题">红黑树解决了什么问题</a></li><li><a href="#红黑树复杂度">红黑树复杂度</a></li><li><a href="#如何构造">如何构造</a><ul><li><a href="#实现代码">实现代码</a></li><li><a href="#方法">方法</a><ul><li><a href="#左旋">左旋</a></li><li><a href="#右旋">右旋</a></li><li><a href="#插入节点">插入节点</a></li><li><a href="#删除节点">删除节点</a></li></ul></li></ul></li></ul><!-- /TOC --><p>在CSDN看到了一篇文章， <a href="https://blog.csdn.net/csdnsevenn/article/details/97842196" target="_blank" rel="noopener">漫画：5 分钟学会红黑树算法</a></p><p>文字永远也没有图直观</p><h1 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h1><p>红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。除了符合二叉查找树的特性之外，还具体下列的特性：</p><ul><li>节点是红色或者黑色</li><li>根节点是黑色</li><li>每个叶子的节点都是黑色的空节点（NULL）</li><li>每个红色节点的两个子节点都是黑色的。</li><li>从任意节点到其每个叶子的所有路径都包含相同的黑色节点。</li></ul><p><img src="/2019/09/08/架构/红黑树算法/rb_sample.jpg" alt=""></p><h1 id="红黑树解决了什么问题"><a href="#红黑树解决了什么问题" class="headerlink" title="红黑树解决了什么问题"></a>红黑树解决了什么问题</h1><p>红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高</p><h1 id="红黑树复杂度"><a href="#红黑树复杂度" class="headerlink" title="红黑树复杂度"></a>红黑树复杂度</h1><p>能保证在最坏情况下，基本的动态几何操作的时间均为O（lgn）</p><h1 id="如何构造"><a href="#如何构造" class="headerlink" title="如何构造"></a>如何构造</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><ul><li>rb-tree:<a href="https://github.com/CuijianSa/utils/blob/master/src/redblack-tree/rb-tree.h" target="_blank" rel="noopener">路径</a></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>对x进行左旋，将x编程一个左节点<img src="/2019/09/08/架构/红黑树算法/left_rotate.jpg" alt=""></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>对x进行右旋，将x编程一个右节点<img src="/2019/09/08/架构/红黑树算法/right_rotate.jpg" alt=""></p><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p><strong>红黑树特性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 每个节点或者是黑色，或者是红色。</span><br><span class="line">2. 根节点是黑色。</span><br><span class="line">3. 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</span><br><span class="line">4. 如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span class="line">5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span><br></pre></td></tr></table></figure></p><ul><li>将红黑树当作一颗二叉查找树，将节点插入。</li><li>将插入的节点着色为”红色”(减少特性冲突)</li><li>特对特性2,4， 修复红黑树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z)</span><br><span class="line">    while z.p.color == RED                 // 当z的父结点为红色，循环继续</span><br><span class="line">        if z.p == z.p.p.left               // 父结点是祖父结点的左孩子的情况</span><br><span class="line">            y = z.p.p.right                // y指向祖父结点的右孩子，即叔结点</span><br><span class="line">            if y.color == RED              // 如果叔结点为红色</span><br><span class="line">                z.p.color = BLACK          // case 1  父结点置为黑色</span><br><span class="line">                y.color = BLACK            // case 1  叔结点置为黑色</span><br><span class="line">                z.p.p.color = RED          // case 1  祖父结点置为红色</span><br><span class="line">                z = z.p.p                  // case 1  将z指向其祖父结点</span><br><span class="line">            else                           // 否则，叔结点为黑色</span><br><span class="line">                if z == z.p.right          // 如果z为父结点的右孩子</span><br><span class="line">                    z = z.p                // case 2  z指向其父结点</span><br><span class="line">                    LEFT-ROTATE(T, z)      // case 2  对z左旋</span><br><span class="line">                                           // 到这里表明z为父结点的左孩子</span><br><span class="line">                z.p.color = BLACK          // case 3  父结点置为黑色</span><br><span class="line">                z.p.p.color = RED          // case 3  祖父结点置为红色</span><br><span class="line">                RIGHT-ROTATE(T, z.p.p)     // case 3  对祖父结点右旋</span><br><span class="line">        else(same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)</span><br><span class="line">    T.root.color = BLACK                  // 根节点置为黑色</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">RB-TRANSPLANT(T, u, v)</span><br><span class="line">    if u.p == T.nil          // u的父结点为T.nil，说明u为根结点</span><br><span class="line">        T.root = v           // v成为新的根结点</span><br><span class="line">    else if u == u.p.left    // 若u是他爹的左孩子</span><br><span class="line">        u.p.left = v         // u的爹重新认v为左孩子</span><br><span class="line">    else                     // 若u是他爹的右孩子</span><br><span class="line">        u.p.right = v        // u的爹重新认v为右孩子</span><br><span class="line">    v.p = u.p                // v认u的爹为爹</span><br><span class="line"></span><br><span class="line">TREE-MINIMUM(x)</span><br><span class="line">    while x.left != T.nil</span><br><span class="line">        x = x.left</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line">RB-DELETE(T, z)</span><br><span class="line">    y = z                                  // y指向z</span><br><span class="line">    y-original-color = y.color             // 记录y的颜色</span><br><span class="line">    if z.left == T.nil                     // 如果z的左孩子是T.nil</span><br><span class="line">        x = z.right                        // x指向z的右孩子</span><br><span class="line">        RB-TRANSPLANT(T, z, z.right)       // 用z的右孩子替换z</span><br><span class="line">    else if z.right == T.nil               // 如果z有左孩子并且z的右孩子是T.nil</span><br><span class="line">        x = z.left                         // x指向z的左孩子</span><br><span class="line">        RB-TRANSPLANT(T, z, z.left)        // 用z的左孩子替换z</span><br><span class="line">    else                                   // 如果z既有左孩子又有右孩子</span><br><span class="line">        y = TREE-MINIMUM(z.right)          // y指向z的右子树的最小结点</span><br><span class="line">        y-orighinal-color == y.color       // 记录y的颜色</span><br><span class="line">        x = y.right                        // x指向y的右孩子</span><br><span class="line">        if y.p == z                        // 如果y的父结点是z</span><br><span class="line">            x.p = y                        // 因为x可能为T.nil结点，所以需要指明x的父结点</span><br><span class="line">        else                               // 如果y的父结点不是z</span><br><span class="line">            RB-TRANSPLANT(T, y, y.right)   // 用y的右孩子替换y</span><br><span class="line">            y.right = z.right              // y认z的右孩子为自己的右孩子</span><br><span class="line">            y.right.p = y                  // y的右孩子认y为父</span><br><span class="line">        RB-TRANSPLANT(T, z, y)             // y替换z</span><br><span class="line">        y.left = z.left                    // y认z的左孩子为自己的左孩子</span><br><span class="line">        y.left.p = y                       // y的左孩子认y为父</span><br><span class="line">        y.color = z.color                  // y的颜色变为z的颜色</span><br><span class="line">    if y-original-color == BLACK           // y的初始颜色为黑色</span><br><span class="line">        RB-DELETE-FIXUP(T, x)              // 修复红黑性质</span><br></pre></td></tr></table></figure><p><strong>参考书籍</strong>：</p><ul><li>&lt;&lt;算法导论&gt;&gt;第3版</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gprof</title>
      <link href="/2019/08/27/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/gprof/"/>
      <url>/2019/08/27/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/gprof/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>gprof是GNU 编译器工具包所提供了一种剖析工具 GNU profiler（gprof）。gprof 可以为 Linux平台上的程序精确分析性能瓶颈。gprof精确地给出函数被调用的时间和次数，给出函数调用关系</p><p>gprof是GNU工具之一，它在编译的时候在每个函数的出入口加入了profiling的代码，运行时统计程序在用户态的 执行信息，可以得到每个函数的调用次数，执行时间，调用关系等信息，简单易懂。适合于查找用户级程序的性能瓶颈，对于很多时间都在内核态执行的程 序，gprof不适合。</p><p>gprof用户手册:<a href="https://sourceware.org/binutils/docs-2.17/gprof/index.html" target="_blank" rel="noopener">https://sourceware.org/binutils/docs-2.17/gprof/index.html</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li>使用 -pg 选项来编译hello.c，如果要得到带注释的源码清单，则需要增加 -g 选项。运行： gcc -pg -g -o hello hello.c</li><li>运行应用程序： ./hello 会在当前目录下产生gmon.out文件</li><li>使用gprof来分析 gmon.out文件，需要把它和产生它的应用程序关联起来：<ul><li>gprof hello gmon.out -p 得到每个函数占用的执行时间</li><li>gprof hello gmon.out -q 得到call graph，包含了每个函数的调用关系，调用次数，执行时间等信息</li><li>gprof hello gmon.out -A 得到一个带注释的“源代码清单”，它会注释源码，指出每个函数的执行次数。这需要在编译的时候增加 -g选项。</li></ul></li></ol><ul><li>Usage:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Usage: gprof [-[abcDhilLsTvwxyz]] [-[ACeEfFJnNOpPqSQZ][name]] [-I dirs]</span><br><span class="line">[-d[num]] [-k from/to] [-m min-count] [-t table-length]</span><br><span class="line">[--[no-]annotated-source[=name]] [--[no-]exec-counts[=name]]</span><br><span class="line">[--[no-]flat-profile[=name]] [--[no-]graph[=name]]</span><br><span class="line">[--[no-]time=name] [--all-lines] [--brief] [--debug[=level]]</span><br><span class="line">[--function-ordering] [--file-ordering] [--inline-file-names]</span><br><span class="line">[--directory-path=dirs] [--display-unused-functions]</span><br><span class="line">[--file-format=name] [--file-info] [--help] [--line] [--min-count=n]</span><br><span class="line">[--no-static] [--print-path] [--separate-files]</span><br><span class="line">[--static-call-graph] [--sum] [--table-length=len] [--traditional]</span><br><span class="line">[--version] [--width=n] [--ignore-non-functions]</span><br><span class="line">[--demangle[=STYLE]] [--no-demangle] [--external-symbol-table=name] [@FILE]</span><br><span class="line">[image-file] [profile-file...]</span><br><span class="line">Report bugs to &lt;http://www.sourceware.org/bugzilla/&gt;</span><br></pre></td></tr></table></figure></li></ul><p>使用注意：<br>1) 一般gprof只能查看用户函数信息。如果想查看库函数的信息，需要在编译是再加入“-lc_p”编译参数代替“-lc”编译参数，这样程序会链接libc_p.a库，才可以产生库函数的profiling信息。<br>2) gprof只能在程序正常结束退出之后才能生成程序测评报告，原因是gprof通过在atexit()里注册了一个函数来产生结果信息，任何非正常退出都不会执行atexit()的动作，所以不会产生gmon.out文件。如果你的程序是一个不会退出的服务程序，那就只有修改代码来达到目的。如果不想改变程序的运行方式，可以添加一个信号处理函数解决问题（这样对代码修改最少），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void sighandler( int sig_no )   </span><br><span class="line">&#123;   </span><br><span class="line">      exit(0);   </span><br><span class="line">&#125;   </span><br><span class="line">signal( SIGUSR1, sighandler );</span><br></pre></td></tr></table></figure><p>当使用kill -USR1 pid 后，程序退出，生成gmon.out文件。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过在编译和链接你的程序的时候（使用 -pg 编译和链接选项），gcc 在你应用程序的每个函数中都加入了一个名为mcount ( or “_mcount” , or “__mcount” , 依赖于编译器或操作系统)的函数，也就是说你的应用程序里的每一个函数都会调用mcount, 而mcount 会在内存中保存一张函数调用图，并通过函数调用堆栈的形式查找子函数和父函数的地址。这张调用图也保存了所有与函数相关的调用时间、调用次数等等的所有信息</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li><p>gproc.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void a()&#123;</span><br><span class="line">    cout&lt;&lt;&quot;\t\t+---call a() function&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void c()&#123;</span><br><span class="line">    cout&lt;&lt;&quot;\t\t+---call c() function&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int b() &#123;</span><br><span class="line">    cout&lt;&lt;&quot;\t+--- call b() function&quot;&lt;&lt;endl;</span><br><span class="line">    a();</span><br><span class="line">    c();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Makefile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += -g -pg</span><br><span class="line"></span><br><span class="line">all:test</span><br><span class="line"></span><br><span class="line">test: test.o</span><br><span class="line">$(CXX) $(CFLAGS) -o $@ $^</span><br><span class="line"></span><br><span class="line">%.o:%.cpp</span><br><span class="line">$(CXX) $(CFLAGS) -o $@ -c $&lt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY:</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm test</span><br><span class="line">find -name &quot;*.o&quot; | xargs rm</span><br></pre></td></tr></table></figure></li></ul><p>可以在当前目录看到gmon.out文件<br><code>gmon.out  gprof  gprof.cpp  gprof.o  Makefile</code></p><p>执行命令生成数据gprof -b test gmon.out<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Flat profile:</span><br><span class="line"></span><br><span class="line">Each sample counts as 0.01 seconds.</span><br><span class="line"> no time accumulated</span><br><span class="line"></span><br><span class="line">  %   cumulative   self              self     total           </span><br><span class="line"> time   seconds   seconds    calls  Ts/call  Ts/call  name    </span><br><span class="line">  0.00      0.00     0.00        1     0.00     0.00  _GLOBAL__sub_I__Z1av</span><br><span class="line">  0.00      0.00     0.00        1     0.00     0.00  a()</span><br><span class="line">  0.00      0.00     0.00        1     0.00     0.00  b()</span><br><span class="line">  0.00      0.00     0.00        1     0.00     0.00  c()</span><br><span class="line">  0.00      0.00     0.00        1     0.00     0.00  __static_initialization_and_destruction_0(int, int)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Call graph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">granularity: each sample hit covers 2 byte(s) no time propagated</span><br><span class="line"></span><br><span class="line">index % time    self  children    called     name</span><br><span class="line">                0.00    0.00       1/1           __libc_csu_init [18]</span><br><span class="line">[8]      0.0    0.00    0.00       1         _GLOBAL__sub_I__Z1av [8]</span><br><span class="line">                0.00    0.00       1/1           __static_initialization_and_destruction_0(int, int) [12]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00       1/1           b() [10]</span><br><span class="line">[9]      0.0    0.00    0.00       1         a() [9]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00       1/1           main [6]</span><br><span class="line">[10]     0.0    0.00    0.00       1         b() [10]</span><br><span class="line">                0.00    0.00       1/1           a() [9]</span><br><span class="line">                0.00    0.00       1/1           c() [11]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00       1/1           b() [10]</span><br><span class="line">[11]     0.0    0.00    0.00       1         c() [11]</span><br><span class="line">-----------------------------------------------</span><br><span class="line">                0.00    0.00       1/1           _GLOBAL__sub_I__Z1av [8]</span><br><span class="line">[12]     0.0    0.00    0.00       1         __static_initialization_and_destruction_0(int, int) [12]</span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Index by function name</span><br><span class="line"></span><br><span class="line">   [8] _GLOBAL__sub_I__Z1av (test.cpp) [10] b()           [12] __static_initialization_and_destruction_0(int, int) (test.cpp)</span><br><span class="line">   [9] a()                    [11] c()</span><br></pre></td></tr></table></figure></p><p>从上面的输出我们能明显的看出来，main 调用了 b 函数， 而b 函数分别调用了a 和 c 函数。由于我们的函数只是简单的输出了一个字串，故每个函数的消耗时间都是0 秒。</p><h1 id="生成函数调用图"><a href="#生成函数调用图" class="headerlink" title="生成函数调用图"></a>生成函数调用图</h1><ul><li>安装依赖<ul><li>sudo apt install graphviz</li><li>下载gprof2dot:<a href="https://github.com/jrfonseca/gprof2dot.git" target="_blank" rel="noopener">https://github.com/jrfonseca/gprof2dot.git</a></li></ul></li><li>在上一步骤已获取函数的调用关系和调用次数文件gmon.out</li><li>输出readable文件:prof -b test gmon.out &gt; grof.log</li><li>生成函数调用图:python3 gprof2dot.py grof.log | dot -Tpng -o output.png</li></ul><p><img src="/2019/08/27/性能调优/gprof/output.png" alt=""></p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="未生成gmon-out的原因"><a href="#未生成gmon-out的原因" class="headerlink" title="未生成gmon.out的原因"></a>未生成gmon.out的原因</h2><p>prof只能在程序正常结束退出之后才能生成程序测评报告，原因是gprof通过在atexit()里注册了一个函数来产生结果信息，任何非正常退出都不会执行atexit()的动作，所以不会产生gmon.out文件。所以，以下情况可能不会有gmon.out文件产生：</p><ol><li>程序不是从main return或exit()退出，则可能不生成gmon.out。</li><li>程序如果崩溃，可能不生成gmon.out。</li><li>测试发现在虚拟机上运行，可能不生成gmon.out。</li><li>程序忽略SIGPROF信号！一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated</li><li>如果程序运行时间非常短，则gprof可能无效。因为受到启动、初始化、退出等函数运行时间的影响。如果你的程序是一个不会退出的服务程序，那就只有修改代码来达到目的。如果不想改变程序的运行方式，可以添加一个信号处理函数解决问题（这样对代码修改最少），例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void sighandler( int sig_no ) </span><br><span class="line">&#123; </span><br><span class="line">    exit(0); </span><br><span class="line">&#125; </span><br><span class="line">signal( SIGUSR1, sighandler )；</span><br></pre></td></tr></table></figure></li></ol><p>这样当使用kill -USR1 pid 后，程序退出，生成gmon.out文件。 </p>]]></content>
      
      
      <categories>
          
          <category> 性能调优 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>oprofile</title>
      <link href="/2019/08/27/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/oprofile/"/>
      <url>/2019/08/27/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/oprofile/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>oprofile也是一个开源的profiling工具，它使用硬件调试寄存器来统计信息，进 行profiling的开销比较小，而且可以对内核进行profiling。它统计的信息非常的多，可以得到cache的缺失率，memory的访存信 息，分支预测错误率等等，这些信息gprof是得不到的，但是对于函数调用次数，它是不能够得到的</p><p>主页:<a href="https://oprofile.sourceforge.io/news/" target="_blank" rel="noopener">https://oprofile.sourceforge.io/news/</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>下载: wget <a href="https://prdownloads.sourceforge.net/oprofile/oprofile-1.3.0.tar.gz" target="_blank" rel="noopener">https://prdownloads.sourceforge.net/oprofile/oprofile-1.3.0.tar.gz</a></li><li>安装依赖库:<ul><li>sudo apt-get install libpopt-dev</li><li>sudo apt-get install binutils-dev</li><li>sudo apt-get install libiberty-dev</li></ul></li><li><p>编译: </p><ul><li>./configure  –with-kernel-support</li><li>make </li><li>make install</li></ul></li><li><p>opcontrol –init  加载模块，mout /dev/oprofile 创建必需的文件和目录 </p></li><li>opcontrol –no-vmlinux 或者 opcontrol –vmlinux=/boot/vmlinux-<code>uname -r</code> 决定是否对kernel进行profiling </li><li>opcontrol –reset 清楚当前会话中的数据 </li><li>opcontrol –start 开始profiling </li><li>./hello 运行应用程序，oprofile会对它进行profiling </li><li>opcontrol –dump 把收集到的数据写入文件 </li><li>opcontrol –stop 停止profiling </li><li>opcotrol -h 关闭守护进程oprofiled </li><li>opcontrol –shutdown 停止oprofiled</li><li>opcontrol –deinit 卸载模块 </li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>首先加载profile</li></ol><p>opcontrol –init</p><p>初始化oprofile，可以通过demsg查看oprofile使用的是哪一种模式：<br>[root@compiler /]# dmesg | grep oprofile<br>oprofile: using NMI interrupt.<br>oprofile: using NMI interrupt.<br>oprofile: using NMI interrupt.<br>oprofile: using NMI interrupt.<br>oprofile: using NMI interrupt.</p><ol start="2"><li>然后start 调用开始获取CPU采样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@compiler /]# opcontrol --start --no-vmlinux</span><br><span class="line">ATTENTION: Use of opcontrol is discouraged. Please see the man page for operf.</span><br><span class="line">Using default event: CPU_CLK_UNHALTED:100000:0:1:1</span><br><span class="line">Using 2.6+ OProfile kernel interface.</span><br><span class="line">Using log file /var/lib/oprofile/samples/oprofiled.log</span><br><span class="line">Daemon started.</span><br><span class="line">Profiler running.</span><br></pre></td></tr></table></figure></li></ol><p>每次启动都会在/root/.oprofile/目录下生成一个配置文件daemonrc,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@compiler /]# cat /root/.oprofile/daemonrc </span><br><span class="line">SESSION_DIR=/var/lib/oprofile</span><br><span class="line">NR_CHOSEN=0</span><br><span class="line">SEPARATE_LIB=0</span><br><span class="line">SEPARATE_KERNEL=0</span><br><span class="line">SEPARATE_THREAD=0</span><br><span class="line">SEPARATE_CPU=0</span><br><span class="line">VMLINUX=none</span><br><span class="line">IMAGE_FILTER=</span><br><span class="line">CPU_BUF_SIZE=0</span><br><span class="line">CALLGRAPH=0</span><br><span class="line">XENIMAGE=none</span><br></pre></td></tr></table></figure></p><p>注:<br>以上的每个配置项是通过启动oprofile时加的参数生成的.</p><p>清理统计数据，重置统计量,如下:<br>[root@compiler /]# opcontrol –reset</p><ol start="3"><li>这个时候启动需要监控的程序，如果是内核，就直接sleep一段时间即可</li></ol><p>[root@compiler /]# /usr/local/nginx/sbin/nginx</p><ol start="4"><li>接下来我们用–dump选项告诉oprofiled输出统计量,如下:<br>[root@compiler /]# opcontrol –dump</li></ol><p>（可选）停止后台程序<br>[root@compiler /]# opcontrol –shutdown</p><ol start="5"><li>再下来我们就可以用opreport,opgprof或者opannotate来观察它们,任何用户都可以看到输出,下面我们用opreport来查看统计量,如下:</li></ol><p>(1)opreport<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@compiler /]# opreport |grep nginx</span><br><span class="line">Using /var/lib/oprofile/samples/ for samples directory.</span><br><span class="line">39 1.0e-04 nginx</span><br><span class="line"></span><br><span class="line">观察对应进程里面函数在运行时候的的占用百分比</span><br><span class="line">[root@compiler /]# opreport -l /usr/local/nginx/sbin/nginx</span><br><span class="line">Using /var/lib/oprofile/samples/ for samples directory.</span><br><span class="line">CPU: Intel Core/i7, speed 2.128e+06 MHz (estimated)</span><br><span class="line">Counted CPU_CLK_UNHALTED events (Clock cycles when not halted) with a unit mask of 0x00 (No unit mask) count 100000</span><br><span class="line">samples % symbol name</span><br><span class="line">20 39.2157 ngx_hash_init</span><br><span class="line">10 19.6078 ngx_conf_parse</span><br><span class="line">2 3.9216 ngx_init_setproctitle</span><br><span class="line">1 1.9608 _fini</span><br><span class="line">1 1.9608 main</span><br><span class="line">1 1.9608 ngx_array_push</span><br><span class="line">1 1.9608 ngx_cpuinfo</span><br><span class="line">1 1.9608 ngx_event_process_init</span><br><span class="line">1 1.9608 ngx_hash_key_lc</span><br><span class="line">1 1.9608 ngx_http_core_merge_loc_conf</span><br><span class="line">1 1.9608 ngx_http_core_server_name</span><br><span class="line">1 1.9608 ngx_http_core_type</span><br><span class="line">1 1.9608 ngx_http_limit_conn_merge_conf</span><br><span class="line">1 1.9608 ngx_http_log_compile_format</span><br><span class="line">1 1.9608 ngx_http_log_init</span><br><span class="line">1 1.9608 ngx_http_merge_locations</span><br><span class="line">1 1.9608 ngx_http_upstream_keepalive_create_conf</span><br><span class="line">1 1.9608 ngx_http_uwsgi_merge_loc_conf</span><br><span class="line">1 1.9608 ngx_signal_handler</span><br><span class="line">1 1.9608 ngx_strlow</span><br><span class="line">1 1.9608 ngx_vslprintf</span><br><span class="line">1 1.9608 ngx_worker_process_init</span><br><span class="line">[root@compiler /]#</span><br></pre></td></tr></table></figure></p><p>(2)opannotate<br>[root@compiler /]# opannotate –source /usr/local/nginx/sbin/nginx &gt; 1.txt</p><p>可以针对某一个进程，里面所有函数的执行采样统计，用于优化函数。</p><p>注:<br>输出显示了一系列对象文件,文件包含了当profile测试时正在运行的代码.<br>oprofiled 从调用opcontrol –start时开始记录,到调用opcontrol –dump时会截取当前的统计量,但是oprofiled仍会继续搜集并积累统计数据,之后再调用opconrol –dump就会有旧的积累数据产生.直到调用opcontrol –stop时,才会停止搜集.</p><p>(3)opgprof</p><p>我们可以通过gprof来产生一个gmon.out文件,如下:<br>[root@compiler /]# opgprof /usr/local/nginx/sbin/nginx</p><p>不调用图像数据得出gmon.out结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@compiler /]# gprof --no-graph /usr/local/nginx/sbin/nginx</span><br><span class="line">Flat profile:</span><br><span class="line"></span><br><span class="line">Each sample counts as 1 samples.</span><br><span class="line">% cumulative self self total </span><br><span class="line">time samples samples calls T1/call T1/call name </span><br><span class="line">39.22 20.00 20.00 ngx_hash_init</span><br><span class="line">19.61 30.00 10.00 ngx_conf_parse</span><br><span class="line">3.92 32.00 2.00 ngx_init_setproctitle</span><br><span class="line">1.96 33.00 1.00 _fini</span><br><span class="line">1.96 34.00 1.00 main</span><br><span class="line">1.96 35.00 1.00 ngx_array_push</span><br><span class="line">1.96 36.00 1.00 ngx_cpuinfo</span><br><span class="line">1.96 37.00 1.00 ngx_event_process_init</span><br><span class="line">1.96 38.00 1.00 ngx_hash_key_lc</span><br><span class="line">1.96 39.00 1.00 ngx_http_core_merge_loc_conf</span><br><span class="line">1.96 40.00 1.00 ngx_http_core_server_name</span><br><span class="line">1.96 41.00 1.00 ngx_http_core_type</span><br><span class="line">1.96 42.00 1.00 ngx_http_limit_conn_merge_conf</span><br><span class="line">1.96 43.00 1.00 ngx_http_log_compile_format</span><br><span class="line">1.96 44.00 1.00 ngx_http_log_init</span><br><span class="line">1.96 45.00 1.00 ngx_http_merge_locations</span><br><span class="line">1.96 46.00 1.00 ngx_http_upstream_keepalive_create_conf</span><br><span class="line">1.96 47.00 1.00 ngx_http_uwsgi_merge_loc_conf</span><br><span class="line">1.96 48.00 1.00 ngx_signal_handler</span><br><span class="line">1.96 49.00 1.00 ngx_strlow</span><br><span class="line">1.96 50.00 1.00 ngx_vslprintf</span><br><span class="line">1.96 51.00 1.00 ngx_worker_process_init</span><br><span class="line"></span><br><span class="line">% the percentage of the total running time of the</span><br><span class="line">time program used by this function.</span><br><span class="line"></span><br><span class="line">cumulative a running sum of the number of seconds accounted</span><br><span class="line">seconds for by this function and those listed above it.</span><br><span class="line"></span><br><span class="line">self the number of seconds accounted for by this</span><br><span class="line">seconds function alone. This is the major sort for this</span><br><span class="line">listing.</span><br><span class="line"></span><br><span class="line">calls the number of times this function was invoked, if</span><br><span class="line">this function is profiled, else blank.</span><br><span class="line"></span><br><span class="line">self the average number of milliseconds spent in this</span><br><span class="line">ms/call function per call, if this function is profiled,</span><br><span class="line">else blank.</span><br><span class="line"></span><br><span class="line">total the average number of milliseconds spent in this</span><br><span class="line">ms/call function and its descendents per call, if this </span><br><span class="line">function is profiled, else blank.</span><br><span class="line"></span><br><span class="line">name the name of the function. This is the minor sort</span><br><span class="line">for this listing. The index shows the location of</span><br><span class="line">the function in the gprof listing. If the index is</span><br><span class="line">in parenthesis it shows where it would appear in</span><br><span class="line">the gprof listing if it were to be printed.</span><br><span class="line">[root@compiler /]#</span><br></pre></td></tr></table></figure></p><p>6.<br>opcontrol –stop  #停止profiling<br>opcontrol –shutdown  #关闭守护进程oprofiled<br>opcontrol –deinit  #卸载模块</p><p>二)关于oprofile的最终论述</p><p>这里只提到了oprofile的表面功能.<br>默认情况下,oprofile不支持在虚拟机上进行调试,我们可以通过下面的方法让oprofile可以在虚拟机上跑,如下:</p><p>echo “options oprofile timer=1” &gt;&gt; /etc/modprobe.conf<br>此时再重启虚拟机就可以工作了.</p>]]></content>
      
      
      <categories>
          
          <category> 性能调优 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>openssl</title>
      <link href="/2019/08/20/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/openssl/"/>
      <url>/2019/08/20/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/openssl/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/1daae319d5fc" target="_blank" rel="noopener">https://www.jianshu.com/p/1daae319d5fc</a></p><h1 id="openssl简介"><a href="#openssl简介" class="headerlink" title="openssl简介"></a>openssl简介</h1><p><a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL下载连接</a></p><p>OpenSSL组成主要包括以下三个组件:</p><ul><li>openssl:多用途命令行工具</li><li>libcrypto:加密算法库</li><li>libssl:加密模块应用库，实现ssl及tls</li></ul><table><thead><tr><th>目录名</th><th>功能描述</th></tr></thead><tbody><tr><td>Crypto</td><td>存放 OpenSSL 所有加密算法源码文件和相关标注如 X.509 源码文件，是 OpenSSL 中最重要的目录，包含了 OpenSSL 密码算法库的所有内容</td></tr><tr><td>SSL</td><td>存放 OpenSSL 中 SSL 协议各个版本和 TLS 1.0 协议源码文件，包含了 OpenSSL 协议库的所有内容</td></tr><tr><td>Apps</td><td>存放 OpenSSL 中所有应用程序源码文件，如 CA、X509 等应用程序的源文件就存放在这里</td></tr><tr><td>Doc</td><td>存放了 OpenSSL 中所有的使用说明文档，包含三个部分：应用程序说明文档、加密算法库 API 说明文档及 SSL 协议API说明文档</td></tr><tr><td>Demos</td><td>存放了一些基于 OpenSSL 的应用程序例子，这些例子一般都很简单，演示怎么使用 OpenSSL 中的一个功能</td></tr><tr><td>Include</td><td>存放了使用 OpenSSL 的库时需要的头文件</td></tr><tr><td>Test</td><td>存放了 OpenSSL 自身功能测试程序的源码文件</td></tr></tbody></table><h2 id="DER-编码、BER-编码、CER-编码、PEM-编码"><a href="#DER-编码、BER-编码、CER-编码、PEM-编码" class="headerlink" title="DER 编码、BER 编码、CER 编码、PEM 编码"></a>DER 编码、BER 编码、CER 编码、PEM 编码</h2><ul><li>为了方便证书在互联网中传输，需要通过一个规则将 ASN.1转换为二进制文件。在 X.509 中，使用的编码方式是 Distinguished Encoding Rules（DER）。ASN.1和 DER 的关系类似于字符集和编码的关系。</li><li>Basic Encoding Rules（BER）是 DER 的一个子集。</li><li>Canonical Encoding Rules（CER）是另外一种编码标准，用来编码 ASN.1 结构。</li><li>DER 是一个二进制文件，为了方便传输，可以将 DER 转换为 PEM（Privacy-enhanced Electronic Mail）格式，PEM 是 base64 编码方式。</li></ul><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="genrsa-简介"><a href="#genrsa-简介" class="headerlink" title="genrsa 简介"></a>genrsa 简介</h2><p>平时主要用来生成私钥，选择使用的算法、对称加密密码和私钥长度来生成私钥。</p><h2 id="req"><a href="#req" class="headerlink" title="req"></a>req</h2><p>req的基本功能主要有两个：生成证书请求和生成自签名证书</p><h2 id="x509"><a href="#x509" class="headerlink" title="x509"></a>x509</h2><p>x509是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作</p><h2 id="rsa"><a href="#rsa" class="headerlink" title="rsa"></a>rsa</h2><h2 id="ca"><a href="#ca" class="headerlink" title="ca"></a>ca</h2><h2 id="自签名过程"><a href="#自签名过程" class="headerlink" title="自签名过程"></a>自签名过程</h2><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>加密算法</title>
      <link href="/2019/08/11/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/SSL%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/"/>
      <url>/2019/08/11/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/SSL%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目用到SSL比较多，为了串联各个知识点</p><p>应用都须要在网络上进行在线交易，它们对网络通信的安全性提出了更高的要求。传统的万维网协议HTTP不具备安全机制——採用明文的形式数据传输、不能验证通信两方的身份、无法防止传输的数据被篡改等，导致HTTP无法满足电子商务和网上银行等应用的安全性要求。</p><p>Netscape公司提出的安全协议SSL，利用数据加密、身份验证和消息完整性验证机制，为网络上数据的传输提供安全性保证。SSL能够为HTTP提供安全连接，从而非常大程度上改善了万维网的安全性问题。</p><ul><li>SSL结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------------</span><br><span class="line">|                         Application                                  |</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">| SSL handshake | SSL change cipher spec protocol | SSL alert protocol |</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">|                      SSL record protocol                             |</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">|                             TCP                                      |</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">|                             IP                                       |</span><br><span class="line">------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><ul><li>技术长处<ul><li>提供较高的安全性保证:SSL利用数据加密、身份验证和消息完整性验证机制。保证网络上传输数据的安全性。</li><li>支持各种应用层协议:尽管SSL设计的初衷是为了解决万维网安全性问题，可是因为SSL位于应用层和传输层之间。它能够为不论什么基于TCP等可靠连接的应用层协议提供安全性保证。</li><li>部署简单:眼下SSL已经成为网络中用来鉴别站点和网页浏览者身份，在浏览器使用者及Webserver之间进行加密通信的全球化标准。SSL协议已被集成到大部分的浏览器中，如IE、Netscape、Firefox等。这就意味着差点儿随意一台装有浏览器的计算机都支持SSL连接。不须要安装额外的client软件</li></ul></li></ul><h1 id="协议安全机制"><a href="#协议安全机制" class="headerlink" title="协议安全机制"></a>协议安全机制</h1><ul><li>传输数据的机密性：利用对称密钥算法对传输的数据进行加密。</li><li>身份验证机制：基于证书利用数字签名方法对server和client进行身份验证，当中client的身份验证是可选的。</li><li>消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性。</li></ul><h2 id="SSL加密"><a href="#SSL加密" class="headerlink" title="SSL加密"></a>SSL加密</h2><p>安利一本权威书籍&lt;&lt;应用密码学：协议、算法与C源程序&gt;&gt;</p><p>整个加密的过程就是一种数学的变换：</p><p>CT = f1(PT, KEY)<br>PT = f2(CT, KEY)</p><p>加密时，f1是加密的函数变换，它的输入是明文和口令，<br>解密时，f2是解密的函数变换，它的输入是密文和口令。<br>f1和f2是互逆的两种变换，但是f1和f2输入的参数key可以相等也可以不相等。相等的时候就是用同一把密钥进行加密和解密，不相等的时候就是用不同的密钥进行加解密。</p><p>根据加解密的key相同或者不同，加密术分为两个体系：对称式加密体系（传统加密体系）和非对称式加密体系。</p><ul><li>对称密钥算法：数据加密和解密时使用同样的密钥</li><li>非对称密钥算法：数据加密和解密时使用不同的密钥，一个是公开的公钥，一个是由用户秘密保存的私钥</li></ul><p>SSL加密通道上的数据加解密使用对称密钥算法。眼下主要支持的算法有DES、3DES、AES等，这些算法都能够有效地防止交互数据被窃听</p><h3 id="对称式加密"><a href="#对称式加密" class="headerlink" title="对称式加密"></a>对称式加密</h3><p>这种加密体系的优点：加密速度很快，可以加密大量的数据</p><p>但是有个致命的缺点：在非本地加密通信时，密钥的传输问题（把加密好的密文给接收方，你得把密钥给他，但是怎么安全传输这个密钥呢？）<br>虽然对称式加密体系有这个致命的缺点，但是它仍然是加密的主要手段，因为其加密速度快，能加密大量的数据。</p><ul><li>对称式加密测试</li></ul><p>openssl enc -des3 -in file -out ciphertext</p><p>使用des3算法对file进行加密，生成目的文件ciphertext.</p><p>openssl enc -des3 -d -in ciphertext -out deciphertext</p><p>可以看到测试结果, 使用对称式算法进行加解密，可以看到ciphertext空deciphertext内容一致</p><p>对称式加密算法在数据安全的领域下，有一个较为严重的问题， 关于密钥口令的传播并不能保证其安全</p><p>这些问题可以使用非对称解密来解决</p><h3 id="非对称式解密"><a href="#非对称式解密" class="headerlink" title="非对称式解密"></a>非对称式解密</h3><p>为了解决对称加密中密钥的传输的问题，一些提出了非对称式的加密体系</p><p>加密及解密使用两个不同的密钥，分别为公钥及私钥</p><p>公钥加密的数据只能由私钥进行解密， 私钥加密的数据只能由公钥解密</p><p>在实际场景下，service将公钥发给各个client, client使用公钥解析server加密的数据。 client使用公钥加密发送给server, 私钥只由server保存，这种机制保证了数据的安全性</p><p>这种情况下还有一个隐含的问题， 攻击者可以伪造server进行钓鱼工具；这里就需要一个权威结构CA进行验证公钥</p><ul><li>非对称式加密测试</li></ul><p>openssl genrsa -out file 1024</p><p>openssl rsa -in file -pubout</p><p>先产生1024bit私钥, 然后根据私钥再产生对应的公钥</p><p>但是私钥的加密的速度很慢，比传统加密体系的速度慢三个数量级，所以只能加密少量的数据,了解决这个问题，我们综合对称加密和非对称加密</p><h2 id="综合方案"><a href="#综合方案" class="headerlink" title="综合方案"></a>综合方案</h2><p>先发送方如果想加密发送一个很大的数据，由于非对称加密的速度很慢，所以只能采用对称式的加密方式，加密这个很大的明文数据。这时的口令就是一个session key，这个口令是个随机数，每次通讯的时候都不一样，发送方也不关心这个口令是什么，因为他只要能安全的给接收方就可以了</p><p>那么怎样才能确保这个session key安全的到达接收方呢？</p><p>用非对称加密的方式对session key加密，这样只有接收方用自己的私钥才能解密session key，并用session key解密那个很大的文件的密文</p><h2 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h2><p>对一个大的文件进行签名，当文件比较大， 非对称签名很慢， 使用MD5可以对body进行签名， 对MD5签名进行加密</p><p>任何人都可以看可以使用 这个明文，但是不能修改。一旦你修改了，别人也能很容易的看到这个不是原发送方的那个明文了，因为你没有原发送方的私钥，你无法对特征码签名，别人用原发送方的公钥验证的时候很容易就能发现你的明文是被修改过的</p><h2 id="验证公钥"><a href="#验证公钥" class="headerlink" title="验证公钥"></a>验证公钥</h2><p>我怎么能确定我手里的公钥就是我心中的接收方的公钥呢？怎么防止被钓鱼呢？</p><p>解决的办法就是引入一个第三方，一个权威机构，一个我们都相信的机构。</p><p>验证公钥，Digital Certificate</p><p>好的解决办法就是建立一个中介，我们所有的人都相信这个中介，中介对接收方的公钥的合法性进行认证，在接收方的公钥上签名，这样发送方在相信中介的基础上就能安全的给接收方发送信息了。</p><p>具体的做法就是：中介要求接收方在他这里注册，验证其公钥，然后中介对接收方的公钥进行签名，也就是中介用自己的私钥对接收方的公钥进行加密。然而中介的公钥是众所周知，任何人都知道，不会被任何人假冒的，发送方如果能用中介的公钥认证这份证书，就证明里面的接收方的公钥是注册过的，是合法的。就能安全的给接收方发送信息了。</p><p>也即是说如果我们想给某个人发送信息，必须得到他的公钥，但是为了防止钓鱼，这个公钥必须得被我们相信的中介签名后才是安全的。</p><p>注意：这个证书仍是通信双方通信时，接收者给出的，不同的是这个证书已经被我们相信的中介签过名</p><p>一张数字证书包含接收方的公钥、DN信息、签过名的哈希值。</p><h1 id="协议工作过程"><a href="#协议工作过程" class="headerlink" title="协议工作过程"></a>协议工作过程</h1><h2 id="SSL的分层结构"><a href="#SSL的分层结构" class="headerlink" title="SSL的分层结构"></a>SSL的分层结构</h2><p>SSL分为两层</p><ul><li>上层为SSL握手协议（SSL handshake protocol）、SSLpassword变化协议（SSL change cipher spec protocol）和SSL警告协议（SSL alert protocol）</li><li>底层为SSL记录协议（SSL record protocol）</li></ul><p>SSL握手协议：是SSL协议很重要的组成部分。用来协商通信过程中使用的加密套件（加密算法、密钥交换算法和MAC算法等）、在server和client之间安全地交换密钥、实现server和client的身份验证</p><p>SSLpassword变化协议：client和server端通过password变化协议通知对端。随后的报文都将使用新协商的加密套件和密钥进行保护和传输</p><p>SSL警告协议：用来向通信对端报告告警信息，消息中包括告警的严重级别和描写叙述</p><p>SSL记录协议：主要负责对上层的数据（SSL握手协议、SSLpassword变化协议、SSL警告协议和应用层协议报文）进行分块、计算并加入MAC值、加密。并把处理后的记录块传输给对端</p><h2 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h2><p>SSL通过握手过程在client和server之间协商会话參数，并建立会话。会话包括的主要參数有会话ID、对方的证书、加密套件（密钥交换算法、数据加密算法和MAC算法等）以及主密钥（master secret）。通过SSL会话传输的数据，都将採用该会话的主密钥和加密套件进行加密、计算MAC等处理</p><h3 id="仅仅验证server的SSL握手过程"><a href="#仅仅验证server的SSL握手过程" class="headerlink" title="仅仅验证server的SSL握手过程"></a>仅仅验证server的SSL握手过程</h3><p><img src="/2019/08/11/加密算法/SSL加密传输/vertify_server_only.png" alt=""></p><ol><li>SSLclient通过Client Hello消息将它支持的SSL版本号、加密算法、密钥交换算法、MAC算法等信息发送给SSLserver</li><li>SSLserver确定本次通信採用的SSL版本号和加密套件，并通过Server Hello消息通知给SSLclient。假设SSLserver同意SSLclient在以后的通信中重用本次会话，则SSLserver会为本次会话分配会话ID。并通过Server Hello消息发送给SSLclient</li><li>SSLserver将携带自己公钥信息的数字证书通过Certificate消息发送给SSLclient</li><li>SSLserver发送Server Hello Done消息。通知SSLclient版本号和加密套件协商结束。開始进行密钥交换</li><li>SSLclient验证SSLserver的证书合法后，利用证书中的公钥加密SSLclient随机生成的premaster secret，并通过Client Key Exchange消息发送给SSLserver</li><li>SSLclient发送Change Cipher Spec消息，通知SSLserver兴许报文将採用协商好的密钥和加密套件进行加密和MAC计算</li><li>SSLclient计算已交互的握手消息（除Change Cipher Spec消息外全部已交互的消息）的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并加入MAC值、加密等），并通过Finished消息发送给SSLserver。SSLserver利用相同的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比較，假设二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功</li><li>相同地。SSLserver发送Change Cipher Spec消息，通知SSLclient兴许报文将採用协商好的密钥和加密套件进行加密和MAC计算</li><li>SSLserver计算已交互的握手消息的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并加入MAC值、加密等），并通过Finished消息发送给SSLclient。SSLclient利用相同的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比較，假设二者相同。且MAC值验证成功。则证明密钥和加密套件协商成功</li></ol><p>SSLclient接收到SSLserver发送的Finished消息后。假设解密成功，则能够推断SSLserver是数字证书的拥有者，即SSLserver身份验证成功，由于仅仅有拥有私钥的SSLserver才干从Client Key Exchange消息中解密得到premaster secret，从而间接地实现了SSLclient对SSLserver的身份验证</p><h3 id="验证server和client的SSL握手过程"><a href="#验证server和client的SSL握手过程" class="headerlink" title="验证server和client的SSL握手过程"></a>验证server和client的SSL握手过程</h3><p><img src="/2019/08/11/加密算法/SSL加密传输/vertify_server_client.png" alt=""><br>SSLclient的身份验证是可选的，由SSLserver决定是否验证SSLclient的身份。</p><ol><li>SSLserver发送Certificate Request消息。请求SSLclient将其证书发送给SSLserver</li><li>SSLclient通过Certificate消息将携带自己公钥的证书发送给SSLserver。SSLserver验证该证书的合法性</li><li>SSLclient计算已交互的握手消息、主密钥的Hash值。利用自己的私钥对其进行加密，并通过Certificate Verify消息发送给SSLserver</li><li>SSLserver计算已交互的握手消息、主密钥的Hash值。利用SSLclient证书中的公钥解密Certificate Verify消息，并将解密结果与计算出的Hash值比較。假设二者同样，则SSLclient身份验证成功</li></ol><h3 id="恢复原有会话的SSL握手过程"><a href="#恢复原有会话的SSL握手过程" class="headerlink" title="恢复原有会话的SSL握手过程"></a>恢复原有会话的SSL握手过程</h3><p><img src="/2019/08/11/加密算法/SSL加密传输/recover_shankhand.png" alt=""></p><p>协商会话參数、建立会话的过程中。须要使用非对称密钥算法来加密密钥、验证通信对端的身份。计算量较大，占用了大量的系统资源。</p><p>为了简化SSL握手过程。SSL同意重用已经协商过的会话，详细过程为</p><ol><li>SSLclient发送Client Hello消息，消息中的会话ID设置为计划重用的会话的ID</li><li>SSLserver假设同意重用该会话，则通过在Server Hello消息中设置同样的会话ID来应答。这样，SSLclient和SSLserver就能够利用原有会话的密钥和加密套件。不必又一次协商</li><li>SSLclient发送Change Cipher Spec消息，通知SSLserver兴许报文将採用原有会话的密钥和加密套件进行加密和MAC计算</li><li>SSLclient计算已交互的握手消息的Hash值，利用原有会话的密钥和加密套件处理Hash值，并通过Finished消息发送给SSLserver，以便SSLserver推断密钥和加密套件是否正确</li><li>相同地。SSLserver发送Change Cipher Spec消息，通知SSLclient兴许报文将採用原有会话的密钥和加密套件进行加密和MAC计算</li><li>SLserver计算已交互的握手消息的Hash值，利用原有会话的密钥和加密套件处理Hash值，并通过Finished消息发送给SSLclient。以便SSLclient推断密钥和加密套件是否正确</li></ol><h1 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h1><p><a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL</a>是一种功能强大的商用级全功能工具包，适用于传输层安全性（TLS）和安全套接字层（SSL）协议。 它也是一个通用的加密库</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>tar zxvf openssl-1.0.1e.tar.gz</li><li>cd openssl-1.0.1e</li><li>./configure –prefix=/usr/local/openssl</li><li>make </li><li>make install</li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/bhlsheji/p/4586597.html" target="_blank" rel="noopener">SSL工作原理</a></li><li><a href="https://www.cnblogs.com/stemon/p/3480626.html" target="_blank" rel="noopener">加密传输SSL协议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>live555总篇</title>
      <link href="/2019/07/21/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E6%80%BB%E7%AF%87/"/>
      <url>/2019/07/21/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E6%80%BB%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>live555是采用开放标准协议(RTP/RTCP,RTSP,SIP)实现的C++库，可在Unix,Windows及QNX平台编译构建流媒体库。这些库已在”LIVE555Proxy Server”及vobStreamer中使用，这些库也可用于流式传输，接收和处理MPEG,H265,H264，H+,DV及JPEG视频及音频解码器。它们可以很容易拓展支持其他的(音视频)解码器，还可以用于构建基本的RTSP和SIP客户端及服务器，并已经永固实际的流媒体播放应用程序，例如”VLC”及”MPLayer”</p><p><a href="http://www.live555.com" target="_blank" rel="noopener">LIVE555 Streaming Media</a></p><p>live555被设计为单线程，不知为何没有设计为多线程模式。<br>其事件调度比较巧妙， 使用事件性驱动框架设计架构。底层select或epool实现</p><h1 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>该代码包括以下库，每个库都有自己的子目录：</p><h3 id="BasicUsageEnvironment"><a href="#BasicUsageEnvironment" class="headerlink" title="BasicUsageEnvironment"></a>BasicUsageEnvironment</h3><p>定义了一个UsageEnvironment的一个实例，用于简单的控制台应用程序。 使用select（）循环处理读取事件和延迟操作</p><h3 id="groupsock"><a href="#groupsock" class="headerlink" title="groupsock"></a>groupsock</h3><p>这个库中类封装网络接口和套接字，”Groupsock”类封装了一个发送多播或者组播数据报的套接字</p><h3 id="liveMedia"><a href="#liveMedia" class="headerlink" title="liveMedia"></a>liveMedia</h3><p>这个类定义了一个类层次结构，以Medium为root类，适用于各种流媒体类型和编解码器</p><h3 id="mediaServer"><a href="#mediaServer" class="headerlink" title="mediaServer"></a>mediaServer</h3><p>演示了media server的一个示例，支持搭建rtsp server</p><h3 id="proxyServer"><a href="#proxyServer" class="headerlink" title="proxyServer"></a>proxyServer</h3><p>rtsp proxy的一个演示示例，支持转发rtsp数据流</p><h3 id="testProgs"><a href="#testProgs" class="headerlink" title="testProgs"></a>testProgs</h3><p>该目录实现了一些使用“BasicUsageEnvironment”的简单程序来演示如何使用这些库开发应用程序</p><h3 id="UsageEnvironment"><a href="#UsageEnvironment" class="headerlink" title="UsageEnvironment"></a>UsageEnvironment</h3><p>“UsageEnvironment”和”TaskScheduler”用于调度事件，为异步读取事件分配处理程序以及输出错误/警告消息。此外，”HashTable”类定义了一个通用HashTable接口，可以供其余代码使用.<br>这些都是抽象基类，它们必须子类实现它们的接口， 这些子类可以利用程序将运行的环境的特定属性 - 例如，其GUI和/或脚本环境。</p><ul><li>WindowsAudioInputDevice</li></ul><p>这是“liveMedia”库的“AudioInputDevice”抽象类的实现。 Windows应用程序可以使用它从输入设备读取PCM音频</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/2019/07/21/流媒体/live555总篇/live555_classDiagram.jpg" alt=""></p><h1 id="RTSP数据报文"><a href="#RTSP数据报文" class="headerlink" title="RTSP数据报文"></a>RTSP数据报文</h1><p>从RTSPServer::RTSPClientConnection::handleRequestBytes函数分析， 当socket接收到bytes,由handleRequestBytes进行拆包处理,一般的交互流程如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. C-&gt;S: OPTION request 询问S提供的方法</span><br><span class="line">1. S-&gt;C: OPTION response S回应提供的所有可用方法</span><br><span class="line"></span><br><span class="line">2. C-&gt;S: DESCRIBE request 要求得到S提供的媒体初始化描述信息</span><br><span class="line">2. S-&gt;C: DESCRIBE response S回应媒体初始化描述信息， 主要是SDP</span><br><span class="line"></span><br><span class="line">3. C-&gt;S: SETUP request 设置会话的属性，以及传输模式，并提醒S建立会话</span><br><span class="line">3. S-&gt;C: SETUP response S建立会话，返回会话标识符及会话相关信息</span><br><span class="line"></span><br><span class="line">4. C-&gt;S: PLAY request C请求播放</span><br><span class="line">4. S-&gt;C: PLAY response S回应请求信息</span><br><span class="line"></span><br><span class="line">5. S-&gt;C: 发送流媒体数据</span><br><span class="line"></span><br><span class="line">6. C-&gt;S: TEARDOWN request C请求关闭会话</span><br><span class="line">6. S-&gt;C: TEARDOWN response S回应请求</span><br></pre></td></tr></table></figure><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char const* RTSPServer::allowedCommandNames() &#123;</span><br><span class="line">  return &quot;OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, GET_PARAMETER, SET_PARAMETER&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RTSPServer::RTSPClientConnection::handleCmd_OPTIONS() &#123;</span><br><span class="line">  snprintf((char*)fResponseBuffer, sizeof fResponseBuffer,</span><br><span class="line">       &quot;RTSP/1.0 200 OK\r\nCSeq: %s\r\n%sPublic: %s\r\n\r\n&quot;,</span><br><span class="line">       fCurrentCSeq, dateHeader(), fOurRTSPServer.allowedCommandNames());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DESCRIBE"><a href="#DESCRIBE" class="headerlink" title="DESCRIBE"></a>DESCRIBE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void RTSPServer::RTSPClientConnection</span><br><span class="line">::handleCmd_DESCRIBE(char const* urlPreSuffix, char const* urlSuffix, char const* fullRequestStr) &#123;</span><br><span class="line">  do &#123;</span><br><span class="line">    if (!authenticationOK(&quot;DESCRIBE&quot;, urlTotalSuffix, fullRequestStr)) break; //验证username passwd</span><br><span class="line">    session = fOurServer.lookupServerMediaSession(urlTotalSuffix);//根据suffix查找session</span><br><span class="line">    if (session == NULL) &#123;</span><br><span class="line">      handleCmd_notFound();</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sdpDescription = session-&gt;generateSDPDescription();</span><br><span class="line"></span><br><span class="line">    rtspURL = fOurRTSPServer.rtspURL(session, fClientInputSocket);</span><br><span class="line">    </span><br><span class="line">    snprintf((char*)fResponseBuffer, sizeof fResponseBuffer,</span><br><span class="line">         &quot;RTSP/1.0 200 OK\r\nCSeq: %s\r\n&quot;</span><br><span class="line">         &quot;%s&quot;</span><br><span class="line">         &quot;Content-Base: %s/\r\n&quot;</span><br><span class="line">         &quot;Content-Type: application/sdp\r\n&quot;</span><br><span class="line">         &quot;Content-Length: %d\r\n\r\n&quot;</span><br><span class="line">         &quot;%s&quot;,</span><br><span class="line">         fCurrentCSeq,</span><br><span class="line">         dateHeader(),</span><br><span class="line">         rtspURL,</span><br><span class="line">         sdpDescriptionSize,</span><br><span class="line">         sdpDescription);</span><br><span class="line">  &#125; while (0);</span><br><span class="line">  </span><br><span class="line">  if (session != NULL) &#123;</span><br><span class="line">    // Decrement its reference count, now that we&apos;re done using it:</span><br><span class="line">    session-&gt;decrementReferenceCount();</span><br><span class="line">    if (session-&gt;referenceCount() == 0 &amp;&amp; session-&gt;deleteWhenUnreferenced()) &#123;</span><br><span class="line">      fOurServer.removeServerMediaSession(session);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete[] sdpDescription;</span><br><span class="line">  delete[] rtspURL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">void OnDemandServerMediaSubsession</span><br><span class="line">::getStreamParameters(unsigned clientSessionId,</span><br><span class="line">              netAddressBits clientAddress,</span><br><span class="line">              Port const&amp; clientRTPPort,</span><br><span class="line">              Port const&amp; clientRTCPPort,</span><br><span class="line">              int tcpSocketNum,</span><br><span class="line">              unsigned char rtpChannelId,</span><br><span class="line">              unsigned char rtcpChannelId,</span><br><span class="line">              netAddressBits&amp; destinationAddress,</span><br><span class="line">              u_int8_t&amp; /*destinationTTL*/,</span><br><span class="line">              Boolean&amp; isMulticast,</span><br><span class="line">              Port&amp; serverRTPPort,</span><br><span class="line">              Port&amp; serverRTCPPort,</span><br><span class="line">              void*&amp; streamToken) &#123;</span><br><span class="line">    if (fLastStreamToken != NULL &amp;&amp; fReuseFirstSource) &#123;</span><br><span class="line">        // Special case: Rather than creating a new &apos;StreamState&apos;,</span><br><span class="line">        // we reuse the one that we&apos;ve already created:</span><br><span class="line">        serverRTPPort = ((StreamState*)fLastStreamToken)-&gt;serverRTPPort();</span><br><span class="line">        serverRTCPPort = ((StreamState*)fLastStreamToken)-&gt;serverRTCPPort();</span><br><span class="line">        ++((StreamState*)fLastStreamToken)-&gt;referenceCount();</span><br><span class="line">        streamToken = fLastStreamToken;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        //创建流媒体源</span><br><span class="line">        FramedSource* mediaSource = createNewStreamSource(clientSessionId, streamBitrate);</span><br><span class="line">        if (clientRTPPort.num() != 0 || tcpSocketNum &gt;= 0) &#123;</span><br><span class="line">            //创建server RTP port,从fInitialPortNum开始+1尝试创建port</span><br><span class="line">            rtpGroupsock = createGroupsock(dummyAddr, serverRTPPort);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        rtpSink = createNewRTPSink(rtpGroupsock, rtpPayloadType, mediaSource);</span><br><span class="line">        //并记录stream的状态</span><br><span class="line">        streamToken = fLastStreamToken</span><br><span class="line">          = new StreamState(*this, serverRTPPort, serverRTCPPort, rtpSink, udpSink,</span><br><span class="line">                streamBitrate, mediaSource,</span><br><span class="line">                rtpGroupsock, rtcpGroupsock);</span><br><span class="line">        //并将clientSessionId及destinations保存到hash表中</span><br><span class="line">        fDestinationsHashTable-&gt;Add((char const*)clientSessionId, destinations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void RTSPServer::RTSPClientSession</span><br><span class="line">::handleCmd_SETUP(RTSPServer::RTSPClientConnection* ourClientConnection,</span><br><span class="line">      char const* urlPreSuffix, char const* urlSuffix, char const* fullRequestStr) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">          ServerMediaSession* sms</span><br><span class="line">      = fOurServer.lookupServerMediaSession(streamName, fOurServerMediaSession == NULL);//查找session</span><br><span class="line">            if(sms) &#123;</span><br><span class="line">              //返回失败</span><br><span class="line">            &#125;</span><br><span class="line">            if(fStreamStates == NULL) &#123;</span><br><span class="line">              //第一次设置SETUP</span><br><span class="line">              //初始化环境</span><br><span class="line">              fNumStreamStates = fOurServerMediaSession-&gt;numSubsessions();</span><br><span class="line">              fStreamStates = new struct streamState[fNumStreamStates];</span><br><span class="line">              </span><br><span class="line">              ServerMediaSubsessionIterator iter(*fOurServerMediaSession);</span><br><span class="line">              ServerMediaSubsession* subsession;</span><br><span class="line">              for (unsigned i = 0; i &lt; fNumStreamStates; ++i) &#123;</span><br><span class="line">                  subsession = iter.next();</span><br><span class="line">                  fStreamStates[i].subsession = subsession;</span><br><span class="line">                  fStreamStates[i].tcpSocketNum = -1; // for now; may get set for RTP-over-TCP streaming</span><br><span class="line">                  fStreamStates[i].streamToken = NULL; // for now; it may be changed by the &quot;getStreamParameters()&quot; call that comes later</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //根据url的后缀，一般用来确定媒体类型，例如mp4、h264...</span><br><span class="line">            if (trackId != NULL &amp;&amp; trackId[0] != &apos;\0&apos;) &#123; // normal case</span><br><span class="line">              for (trackNum = 0; trackNum &lt; fNumStreamStates; ++trackNum) &#123;</span><br><span class="line">            subsession = fStreamStates[trackNum].subsession;</span><br><span class="line">            if (subsession != NULL &amp;&amp; strcmp(trackId, subsession-&gt;trackId()) == 0) break;</span><br><span class="line">              &#125;</span><br><span class="line">              if (trackNum &gt;= fNumStreamStates) &#123;</span><br><span class="line">            // The specified track id doesn&apos;t exist, so this request fails:</span><br><span class="line">            ourClientConnection-&gt;handleCmd_notFound();</span><br><span class="line">            break;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //解析客户端SETUP消息， Transport类型， client-port</span><br><span class="line">            parseTransportHeader(fullRequestStr, streamingMode, streamingModeString,</span><br><span class="line">             clientsDestinationAddressStr, clientsDestinationTTL,</span><br><span class="line">             clientRTPPortNum, clientRTCPPortNum,</span><br><span class="line">             rtpChannelId, rtcpChannelId);</span><br><span class="line"></span><br><span class="line">             subsession-&gt;getStreamParameters(fOurSessionId, ourClientConnection-&gt;fClientAddr.sin_addr.s_addr,</span><br><span class="line">                    clientRTPPort, clientRTCPPort,</span><br><span class="line">                    fStreamStates[trackNum].tcpSocketNum, rtpChannelId, rtcpChannelId,</span><br><span class="line">                    destinationAddress, destinationTTL, fIsMulticast,</span><br><span class="line">                    serverRTPPort, serverRTCPPort,</span><br><span class="line">                    fStreamStates[trackNum].streamToken);</span><br><span class="line"></span><br><span class="line">            //拼接RESPONSE包</span><br><span class="line"></span><br><span class="line">          &#125;while(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PLAY"><a href="#PLAY" class="headerlink" title="PLAY"></a>PLAY</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void RTSPServer::RTSPClientSession</span><br><span class="line">::handleCmd_PLAY(RTSPServer::RTSPClientConnection* ourClientConnection,</span><br><span class="line">         ServerMediaSubsession* subsession, char const* fullRequestStr) &#123;</span><br><span class="line">            //解析scale、range</span><br><span class="line">            //根据scale、range设置session   setStreamScale、seekStream or nullSeekStream</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; fNumStreamStates; ++i) &#123;</span><br><span class="line">            fStreamStates[i].subsession-&gt;startStream(...)</span><br><span class="line">        &#125;</span><br><span class="line">        //拼接PLAY RESPONSE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OnDemandServerMediaSubsession::startStream()</span><br><span class="line">&#123;</span><br><span class="line">  StreamState* streamState = (StreamState*)streamToken;</span><br><span class="line">  Destinations* destinations</span><br><span class="line">    = (Destinations*)(fDestinationsHashTable-&gt;Lookup((char const*)clientSessionId));</span><br><span class="line">  if (streamState != NULL) &#123;</span><br><span class="line">    streamState-&gt;startPlaying(destinations, clientSessionId,</span><br><span class="line">                  rtcpRRHandler, rtcpRRHandlerClientData,</span><br><span class="line">                  serverRequestAlternativeByteHandler, serverRequestAlternativeByteHandlerClientData);</span><br><span class="line">    RTPSink* rtpSink = streamState-&gt;rtpSink(); // alias</span><br><span class="line">    if (rtpSink != NULL) &#123;</span><br><span class="line">      //返回rtp seqNum及timestamp</span><br><span class="line">      rtpSeqNum = rtpSink-&gt;currentSeqNo();</span><br><span class="line">      rtpTimestamp = rtpSink-&gt;presetNextTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PAUSE"><a href="#PAUSE" class="headerlink" title="PAUSE"></a>PAUSE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void RTSPServer::RTSPClientSession</span><br><span class="line">::handleCmd_PAUSE(RTSPServer::RTSPClientConnection* ourClientConnection,</span><br><span class="line">      ServerMediaSubsession* subsession) &#123;</span><br><span class="line">  for (unsigned i = 0; i &lt; fNumStreamStates; ++i) &#123;</span><br><span class="line">    if (subsession == NULL /* means: aggregated operation */</span><br><span class="line">  || subsession == fStreamStates[i].subsession) &#123;</span><br><span class="line">      if (fStreamStates[i].subsession != NULL) &#123;</span><br><span class="line">  fStreamStates[i].subsession-&gt;pauseStream(fOurSessionId, fStreamStates[i].streamToken);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  setRTSPResponse(ourClientConnection, &quot;200 OK&quot;, fOurSessionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TEARDOWN"><a href="#TEARDOWN" class="headerlink" title="TEARDOWN"></a>TEARDOWN</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void RTSPServer::RTSPClientSession</span><br><span class="line">::handleCmd_TEARDOWN(RTSPServer::RTSPClientConnection* ourClientConnection,</span><br><span class="line">         ServerMediaSubsession* subsession) &#123;</span><br><span class="line">  unsigned i;</span><br><span class="line">  for (i = 0; i &lt; fNumStreamStates; ++i) &#123;</span><br><span class="line">    if (subsession == NULL /* means: aggregated operation */</span><br><span class="line">  || subsession == fStreamStates[i].subsession) &#123;</span><br><span class="line">      if (fStreamStates[i].subsession != NULL) &#123;</span><br><span class="line">  fOurRTSPServer.unnoteTCPStreamingOnSocket(fStreamStates[i].tcpSocketNum, this, i);</span><br><span class="line">  fStreamStates[i].subsession-&gt;deleteStream(fOurSessionId, fStreamStates[i].streamToken);</span><br><span class="line">  fStreamStates[i].subsession = NULL;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  setRTSPResponse(ourClientConnection, &quot;200 OK&quot;);</span><br><span class="line">  </span><br><span class="line">  // Optimization: If all subsessions have now been torn down, then we know that we can reclaim our object now.</span><br><span class="line">  // (Without this optimization, however, this object would still get reclaimed later, as a result of a &apos;liveness&apos; timeout.)</span><br><span class="line">  Boolean noSubsessionsRemain = True;</span><br><span class="line">  for (i = 0; i &lt; fNumStreamStates; ++i) &#123;</span><br><span class="line">    if (fStreamStates[i].subsession != NULL) &#123;</span><br><span class="line">      noSubsessionsRemain = False;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (noSubsessionsRemain) delete this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原码、反码、补码</title>
      <link href="/2019/07/07/C++/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/"/>
      <url>/2019/07/07/C++/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/SnailMann/article/details/94436918" target="_blank" rel="noopener">转自【组成原理】一起重温组成原理咯 | 对原码，反码，补码的理解</a></p><p>最近在CSDN上看到了一篇很好的文章，对计算机源码、反码、补码解释的很透彻</p><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a><ul><li><a href="#%E5%AD%97%E8%8A%82">字节</a></li><li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97">二进制计算</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81">如何理解原码、反码、补码？</a></li></ul></li><li><a href="#%E6%9C%BA%E5%99%A8%E6%95%B0%E4%B8%8E%E7%9C%9F%E5%80%BC">机器数与真值</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E6%95%B0">什么是机器数</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E5%80%BC%E5%92%8C%E5%BD%A2%E5%BC%8F%E5%80%BC">什么是真值和形式值？</a></li><li><a href="#%E6%9C%BA%E5%99%A8%E6%95%B0%E5%92%8C%E6%BA%90%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E7%9A%84%E5%85%B3%E7%B3%BB">机器数和源码、反码、补码的关系</a></li></ul></li><li><a href="#%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8">同余定理的应用</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86">什么是同余定理？</a></li><li><a href="#%E6%A8%A1%E4%BA%92%E4%B8%BA%E8%A1%A5%E6%95%B0%E5%90%8C%E4%BD%99">模，互为补数，同余</a><ul><li><a href="#%E6%A8%A1">模</a></li><li><a href="#%E4%BA%92%E4%B8%BA%E8%A1%A5%E6%95%B0">互为补数</a></li></ul></li></ul></li><li><a href="#%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81">原码，反码，补码</a><ul><li><a href="#%E5%8E%9F%E7%A0%81">原码</a></li><li><a href="#%E5%8F%8D%E7%A0%81">反码</a></li><li><a href="#%E8%A1%A5%E7%A0%81">补码</a></li></ul></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81">为什么需要原码，反码，补码？</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8E%9F%E7%A0%81">为什么需要原码？</a></li><li><a href="#%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86%E5%8E%9F%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E8%BF%98%E8%A6%81%E5%8F%8D%E7%A0%81%E5%91%A2">既然有了原码，为什么又还要反码呢？</a></li><li><a href="#%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86%E5%8F%8D%E7%A0%81%E8%BF%98%E8%A6%81%E8%A1%A5%E7%A0%81%E5%81%9A%E4%BB%80%E4%B9%88">既然有了反码，还要补码做什么？</a></li><li><a href="#%E5%B0%8F%E5%B0%8F%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B">小小的总结一下：</a></li></ul></li><li><a href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">相关问题</a><ul><li><a href="#%E8%A1%A5%E7%A0%81%E8%AE%A1%E7%AE%97%E7%9A%84%E6%BA%A2%E5%87%BA">补码计算的溢出</a></li></ul></li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>字长为8的计算机中，一个字节，有8位。2^8 = 256 , 既8位空间进行二进制的排列组合，最多可以有256种可能</p><ul><li>无符号位情况下，可表示最大的值为255，最小值为0</li><li>有符号为情况下，可表示最大的值为127，最小值为-127(8)，8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]</li></ul><h2 id="二进制计算"><a href="#二进制计算" class="headerlink" title="二进制计算"></a>二进制计算</h2><p>计算器默认只会做加法，例：<code>5-3 =&gt; 5+(-3)</code> 乘法除法:是通过左移 &lt;&lt; 和右移 &gt;&gt; 来实现</p><ul><li>&amp;: 全1为1，有0为0</li><li>|: 有1为1，全0为0</li><li>~: 逐位取反</li><li>^: 相同位0，相异为1</li></ul><p>1000 mod 256  = 1000 &amp;(256-1), 通式是a mod b = a &amp; (b - 1)，不过需要在特定的条件下才能成立，需要满足b是2的次方数值</p><h2 id="如何理解原码、反码、补码？"><a href="#如何理解原码、反码、补码？" class="headerlink" title="如何理解原码、反码、补码？"></a>如何理解原码、反码、补码？</h2><ul><li>现代操作系统的数值运算是以补码的形式进行的</li><li>在学习原码，反码，补码之前，我们有必要先来了解一下机器数,真值的知识</li><li>然后了解一下同余定理在机器数中的运用，知道模, 互补数，这能让我们更好的理解补码运算中的溢出和为什么能化减为加的行为</li><li>然后我们就可以学习一下原码，反码，补码的基本概念</li><li>再了解一下为什么需要原码，反码和补码，以及他们的具体作用是什么</li></ul><h1 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h1><h2 id="什么是机器数"><a href="#什么是机器数" class="headerlink" title="什么是机器数"></a>什么是机器数</h2><p>一个数在”计算机”中的”二进制”表示形式, 叫做这个数的机器数。 机器数有以下两个特点</p><ul><li>数的符号数值化</li></ul><p>我们知道数值具有正负数之分，由于计算机内部的硬件只能表示0,1两种物理状态，因此数值的正负数，通常在机器中使用最高位的0,1来区分表示。正数为0, 负数为1</p><ul><li>二进制的位数受机器设备的限制</li></ul><p>机器设备一次能表示的二进制位数叫机器的字长，一台机器的字长是固定的。字长8位叫一个字节，机器字长一般都是字节的整数倍，如字长8位、16位、32位、64位</p><p><img src="/2019/07/07/C++/原码、反码、补码/bit.png" alt=""></p><p><strong>机器数由两部分组成，最高位的符号位和剩余位的数值位</strong></p><p>举个粟子，十进制的+8, 转换成机器数就是00001000。十进制的-8，转换成机器数就是10001000<br><a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E6%95%B0/1096838" target="_blank" rel="noopener">机器数 - @百度百科</a></p><h2 id="什么是真值和形式值？"><a href="#什么是真值和形式值？" class="headerlink" title="什么是真值和形式值？"></a>什么是真值和形式值？</h2><p>我们知道机器数的重点是，一个数以 “二进制的形式” ，在 “计算机” 中存储，存在 “符号位”。所以我们要区别机器数和数学意义上的二进制数。</p><p>因为机器数是带有符号位的，普通数学角度的二进制数是没有符合位概念的。所以机器数在计算机中所表示的真实值和机器数所表示的形式值是不相同的。比如说，十进制的-8，转换成机器数就是10001000，而10001000按照数学角度去转换为10进制应该是136, 而不是-8。</p><table><thead><tr><th>十进制</th><th>机器数</th><th>2进制数</th></tr></thead><tbody><tr><td>+ 8</td><td>0000 1000</td><td>+ 0000 1000</td></tr><tr><td>-8</td><td>1000 1000</td><td>- 0000 1000</td></tr></tbody></table><ul><li>真值</li></ul><p>当我们把机器数当做有符号位的二进制数值去计算，得到的值就是机器数真实所表示的值，称之为真值</p><ul><li>形式值</li></ul><p>当我们把机器数当做数学角度的没有符合位的二进制数去计算，得到的值只是一个纯数学角度的数值，并非机器数真实代表的值，称之为形式值</p><h2 id="机器数和源码、反码、补码的关系"><a href="#机器数和源码、反码、补码的关系" class="headerlink" title="机器数和源码、反码、补码的关系"></a>机器数和源码、反码、补码的关系</h2><ul><li>机器数是一个概念，只要符合该概念定义的二进制数，我们就称为机器数。</li><li>而原码，反码，补码都是机器数的一种表现形式，他们的定义都符合机器数的定义。</li><li>也可以说，对于一个数, 计算机要使用一定的编码方式进行存储。原码, 反码, 补码是机器存储一个具体数字的编码方式.</li></ul><h1 id="同余定理的应用"><a href="#同余定理的应用" class="headerlink" title="同余定理的应用"></a>同余定理的应用</h1><p>计算机补码运算背后是具有一定的数理知识的，例如同余定理就是补码运算背后的基石</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同余定理：</span><br><span class="line">数学上，两个整数除以同一个整数，若得相同余数，则二整数同余</span><br><span class="line"></span><br><span class="line">既两个整数a,b 分别除以一个整数m所得到的余数如果相同，则a,b对于模m同余，同余的意思就是效果是等价的</span><br><span class="line">(6 - 12) mod 12 = 6,(6 + 12) mod 12 = 6 , 所以 -6和18对模12同余 ，也就是说 -12和+12的行为在这个计量系统中是等价，可以互相代替的，既减12是可以被加12替代的</span><br></pre></td></tr></table></figure><h2 id="什么是同余定理？"><a href="#什么是同余定理？" class="headerlink" title="什么是同余定理？"></a>什么是同余定理？</h2><h2 id="模，互为补数，同余"><a href="#模，互为补数，同余" class="headerlink" title="模，互为补数，同余"></a>模，互为补数，同余</h2><h3 id="模"><a href="#模" class="headerlink" title="模"></a>模</h3><ul><li>模:模就像是一个计量系统的计数范围，如时钟只能表示0~11点的数值，12则是该时钟的模，当值大于等于12时，则需要对时钟的模(12)进行取余运算，得到该计量系统的值。</li><li>例如时钟的计量范围是0～11，模为12。那么计算机补码运算中，n位计算机，其计算系统的模为2^n ，补码取值范围就是-2^n～(2^n)-1。例如8位的补码运算中，模为2^8 = 256，补码取值范围是-128 ~ 127</li><li>计算机补码运算也可以看成一个计量机器，补码也有一个计量范围，即也存在一个“模”</li></ul><h3 id="互为补数"><a href="#互为补数" class="headerlink" title="互为补数"></a>互为补数</h3><p>“模” 实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。任何有模的计量器，均可化减法为加法运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设一个时钟，当前时针指向10点，而准确时间是6点，需要调整时间为正确的时间，那么就可以有以下两种拨法：一种是倒拨4小时，即10-4=6；另一种是顺拨8小时，既10+8=12+6=6</span><br><span class="line"></span><br><span class="line">- 所以在模为12的计量系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。对“模”而言，+8和-4互为补数，+8和-4的行为是同余的，也可以说6和18模12的行为是同余的。实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特性。共同的特点是两者相加等于模</span><br><span class="line"></span><br><span class="line">对于计算机，其概念和方法完全一样</span><br><span class="line"></span><br><span class="line">- 8位计算机所能表示的最大数是1111 1111，若再加1成为1 0000 0000，但因计算机定长8位，所以最高位1自然丢失，又回了0000 0000，所以8位二进制系统的模为2^8 = 256。在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以了。把补数用到计算机对数的处理上，就是补码。</span><br></pre></td></tr></table></figure><h1 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h1><p>计算机的二进制计算，都是使用补码进行计算的</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p><strong>什么是原码？</strong></p><ul><li>原码是人脑最容易理解和计算的表示方式</li><li>原码是机器数的一种表现形式，由符号位 + 数值位组成 ，数值位是真值的绝对值</li><li>字长8位的1字节原码的取值范围是[-127,127], 0有两种表示编码<br>在这里插入图片描述</li></ul><table><thead><tr><th>十进制真值</th><th>原码</th></tr></thead><tbody><tr><td>+1</td><td>0 000 0001</td></tr><tr><td>-1</td><td>1 000 0001</td></tr><tr><td>+123</td><td>0 111 1011</td></tr><tr><td>-123</td><td>1 111 1011</td></tr></tbody></table><p><strong>原码作用</strong></p><ul><li>计算机中无法直接使用原码进行计算，计算机内部运算使用的是补码，非原码。但如果要知道某个补码对应的机器数真值是什么，就需要先转换为原码，再通过原码快速的转换为真值</li><li>通过原码，我们可以快速的知道其对应的真值是什么，这就是需要原码的主要原因</li></ul><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p><strong>什么是反码</strong></p><ul><li>反码是在原码的基础上，符号位不变，数值位全部取反的结果</li><li>正数的反码是其本身，一定意义上说只有负数才有反码</li><li>反码没有直接用于计算，并且通过反码也无法得知真值，反码是一个中间值</li><li>字长8位的1字节反码的取值范围是[-127,127]，0有两种表示编码</li></ul><p><img src="/2019/07/07/C++/原码、反码、补码/inverse.png" alt=""></p><table><thead><tr><th>十进制真值</th><th>原码</th><th>反码</th></tr></thead><tbody><tr><td>+1</td><td>0 000</td><td>0001</td><td>0</td><td>111 1110</td></tr><tr><td>-1</td><td>1 000</td><td>0001</td><td>1</td><td>111 1110</td></tr><tr><td>+123</td><td>0</td><td>111</td><td>1011</td><td>0 000 0100</td></tr><tr><td>-123</td><td>1</td><td>111</td><td>1011</td><td>1 000 0100</td></tr></tbody></table><p><strong>反码的作用</strong></p><ul><li>反码是一个中间值，既不能直接计算，也不能直接推断出真值</li><li>其实反码已经可以表示负数了，既本质可以用来化减为加的去做机器数运算。只是反码运算留有一个小缺陷，既没有解决正负0的问题，所以最后没有被采用做计算的编码，而是作为原码和补码之间的中间值。</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p><strong>什么是补码？</strong></p><ul><li>补码是原码符号位不变，数值位取反之后再 + 1得到的结果值，既在反码的基础上+1</li><li>正数的反码，补码都是其本身</li><li>补码的出现是为了解决正负0的问题，补充反码的缺陷</li><li>补码是计算机存储和运算的直接编码，不过不能直接表示出真值，所以对外展示，还需要转换为原码</li><li>字长8位的1字节反码的取值范围是[-128,127]，解决了正负0的问题，只有0 0000000代表0</li><li>8位空间中，人为的定义原负0的编码1 0000000为-(2^8) = -128，所以-128，虽然是负的，但没有反码和补码。这个人为定义是可以通用扩展的n位空间的补码最小值是-(2^n)，如16位空间，原负0编码则为-(2^16) = -65536</li></ul><p><img src="/2019/07/07/C++/原码、反码、补码/complement.png" alt=""></p><table><thead><tr><th>十进制真值</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>+1</td><td>0 000 0001</td><td>0 111 1110</td><td>0 111 1111</td></tr><tr><td>-1</td><td>1 000 0001</td><td>1 111 1110</td><td>1 111 1111</td></tr><tr><td>+123</td><td>0 111 1011</td><td>0 000 0100</td><td>0 000 0101</td></tr><tr><td>-123</td><td>1 111 1011</td><td>1 000 0100</td><td>1 000 0101</td></tr></tbody></table><p><strong>补码作用</strong></p><ul><li>补码是为了解决反码中遗留的正负0问题。为了不浪费宝贵的空间资源，负0的二进制表示1 0000000为人为认定是-128,扩展多一位的新内容</li><li>计算机最后采用的机器数存储方式就是补码方案，所以计算机中所有的二进制运算都是使用补码进行的。</li><li>补码计算得到的结果也是补码，如果要想知道补码对应的机器数真值，需要把补码转换成原码，才能让人脑更好的识别</li></ul><h1 id="为什么需要原码，反码，补码？"><a href="#为什么需要原码，反码，补码？" class="headerlink" title="为什么需要原码，反码，补码？"></a>为什么需要原码，反码，补码？</h1><h2 id="为什么需要原码？"><a href="#为什么需要原码？" class="headerlink" title="为什么需要原码？"></a>为什么需要原码？</h2><p>因为计算机只能识别0和1，使用的是二进制。而在日常生活中人们使用的是十进制，并且有正负之分，由正负符号来表示。所以只有两种物理状态的计算机想要模拟出正负的概念，并以二进制的形式去存储，也就催生了机器数 原码的出现，既用一个数的最高位来表示符号，0为正，1为负，剩余位存储数值</p><h2 id="既然有了原码，为什么又还要反码呢？"><a href="#既然有了原码，为什么又还要反码呢？" class="headerlink" title="既然有了原码，为什么又还要反码呢？"></a>既然有了原码，为什么又还要反码呢？</h2><p>因为原码的出现，我们在计算机中就有了可以表示有符号数值的方式。有了表现数值的方式，我们就可以进行加减乘除的计算。但是经过计算的实践，我们发现，直接拿原码进行四则运算中的减法运算(加乘除都可以)会得出错误的结果。比如</p><p>1 - 1 = 1 + (-1) = 0 0000001 + 1 0000001 = 1 0000010 = -2</p><p>我们期待的结果是0 (1 0000000 或 0 0000000), 但是却给得到了-2 (1 0000010)的答案，所以这明显是一个错误。为什么会出现错误呢？</p><ul><li>对于人脑来说，在计算的时候，我们可以根据符号位, 选择对数值位进行加减的操作。但是对于计算机而言，四则运算属于最底层的基础计算，需要设计的尽量简单，高效率。既根据运算法则，减去一个正数等于加上一个负数，比如1 - 1 = 1 + (-1)。 所以底层电路设计时，为了避免基础电路设计变得十分的复杂，就放弃了减法的概念，只有保留了加法。所以计算机运算中只有加法，没有减法，减去一个正数会被替换成加上一个负数。</li><li>通过原码进行四则运算的实践，我们发现，乘除加法都没有问题，只有减法有问题。问题就出在了计算机中没有减法，只有加法，减去一个正数会被替换成了加上一个负数，这是原码设计之初本身就不能满足的事情。 既带有符号位的原码进行减法(加上一个负数)运算，很可能计算出错误的结果。</li><li>Maybe，当初基础电路设计设计的更复杂点，可以容忍减法运算，那么可能原码就可以通过真正的“减法”进行减法运算了</li></ul><p>为了解决原码无法满足计算机减法运算的问题，反码就出现了<br>1 - 1 =&gt; 1 + (-1) =&gt; [0 0000001]原 + [1 0000001]原 =&gt; [0 0000001]反 + [1 1111110]反 =&gt;<br>[1 1111111]反 =&gt; [1 0000000]反 =&gt; 0</p><p>很好，反码的出现就解决了原码无法进行减法运算的问题</p><h2 id="既然有了反码，还要补码做什么？"><a href="#既然有了反码，还要补码做什么？" class="headerlink" title="既然有了反码，还要补码做什么？"></a>既然有了反码，还要补码做什么？</h2><p>我们知道反码是在原码的基础上，符号位不变，数值位取反得到的结果。反码解决了原码中无法与负数相加的问题。反码很棒，但是反码依然有一个小缺陷，就是没有解决原码留下来正负0的问题，所以正负0问题也就成为了反码的缺陷。人类总是精益求精的，为了解决反码留下来正负0缺陷，补码就出现了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正负0问题：</span><br><span class="line"></span><br><span class="line">反码中+0由0 0000000表示，-0由1 0000000表示，然而-0在数学的角度来说是没有意义的，在计算机存储的角度也是多余的</span><br></pre></td></tr></table></figure><p>在8位的补码中，只有+0的概念，+0由0 0000000所表示，原-0的编码被人为的指定是-128。所以8位的补码最小值是-128，取值范围不同于原码和反码的[-127,127],而是[-128,127]</p><h2 id="小小的总结一下："><a href="#小小的总结一下：" class="headerlink" title="小小的总结一下："></a>小小的总结一下：</h2><ul><li>原码就是计算机为了存储带符号的二进制数值而出现的机器数形式</li><li>反码就是为了解决原码无法进行减法运算的问题，说白了就是为了解决与负数相加的问题</li><li>补码就是为了解决反码遗留的正负0问题而出现的新机器数形式</li></ul><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><h2 id="补码计算的溢出"><a href="#补码计算的溢出" class="headerlink" title="补码计算的溢出"></a>补码计算的溢出</h2><p>因为计算出来的结果值大于该计量系统能显示的值的范围，所以我们要得到与结果值同余，且计量系统能显示出来的值<br>重点是同余，所以理解同余定理可以更好的理解补码计算的溢出情况。</p><p>Java的byte超过了[-128，127]时，怎么处理？<br>我们在进行byte计算的时候，肯定有会这样的思考</p><ul><li>我们知道-1-127的运算等于-128，刚好等于byte的最小值。那么-127-127得到的结果大于1个字节时，又怎么去计算呢？</li><li>当计算出来的结果值大于8位二进制系统能存储的值时，怎么办？</li></ul><p>Java的byte是以补码进行计算的，当byte变量被赋予[-128,127]范围之外的值时，这就属于补码计算溢出的情况。那么Java是怎么处理的呢？</p><ul><li>它会以补码的形式值</li></ul><p>比如，我们将一个十进制值129赋予给byte, 129已经超过Java byte类型的值范围[-128，127], 所以Java最终输出的byte类型结果是129的补码形式值-127。过程如图</p><p><img src="/2019/07/07/C++/原码、反码、补码/overfill.png" alt=""></p><ul><li>-129的原码形式 0 1 0000 0001(9位)，因为byte类型最多支持8位，所以溢出，最高位自然丢失，129在byte的原码形式成为1 0000001(8位)</li><li>原码1 0000001(8位)的数值位取反，得到反码1 1111110(8位)</li><li>补码1 11111111(8位)的十进制形式值是-127，真值是-1</li></ul><p>所以在Java中，如果值大于byte的取值范围，Java会以其补码的形式值方式展示</p><ul><li>当我们用Java的有符号位byte去接收其他语言无符号位的byte数据时，就会导致原义是正数的值在Java的byte中显示为负数情况。此时通常情况下的解决方案就是int = (byte &amp; 0xff), 0xff其实就是255的十六进制哈。byte &amp; 0xff的意思本质就是byte mod (255 +1)</li><li>该解决方案的本质就是，负数不在无符号位byte计量系统的取值范围内，既不在[0,255]范围内。 所以我需要找出负数于模2^8 = 256同余，且在[0,255]范围内的值</li><li>例如-135于模256同余，且在[0,255]范围内的值是121， -129于模256同余，且在[0,255]范围内的值是127</li></ul><p><strong>为什么有-0和+0的表示呢？</strong></p><p>既-0由(1 0000000)表示，+0由(0 0000000)来表示。但是在数学的角度看，-0是没有意义的。而站在计算机存储的角度看，1个字节的空间有限且宝贵，-0的表示浪费了一个存储空间。所以综上所述，既然-0的表示没有意义，那么我们又不能浪费这么一个宝贵的空间，所以就人为的去规定了0只有一种表示手段，既0 0000000，而1 0000000则固定认为是 -128</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开源项目</title>
      <link href="/2019/07/02/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/07/02/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="我的开源项目"><a href="#我的开源项目" class="headerlink" title="我的开源项目"></a>我的开源项目</h1><h2 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>utils是基于c++编写的一些demo，包含python、QT、通用库，其目录如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|--- cmake:cmake 文件存放目录</span><br><span class="line">|--- common: 通用头文件</span><br><span class="line">|--- python: 一些Python demo</span><br><span class="line">|--- src: 源码</span><br><span class="line">    |--- image</span><br><span class="line">    |--- media</span><br><span class="line">    |--- unittest: src测试代码</span><br><span class="line">    |--- ...</span><br><span class="line">|--- test: 非主干测试文件</span><br></pre></td></tr></table></figure><h3 id="项目主页"><a href="#项目主页" class="headerlink" title="项目主页"></a>项目主页</h3><ul><li><a href="https://github.com/CuijianSa/utils" target="_blank" rel="noopener">utils</a></li></ul><h3 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h3><ul><li>common <ul><li>定制化log</li><li>控制台输出配色</li></ul></li><li>python<ul><li>线程</li><li>网络编程</li><li>tls 加密</li><li>线程</li><li>通配符</li><li>进程</li></ul></li><li>qt<ul><li>Camera:使用opencv + USB 进行实时数据采集</li><li>H264Analysis: H264解析工具</li><li>Player: 视频流播放工具，目前支持RTSP + RTMP</li></ul></li><li>src<ul><li>io: C++封装的io读取类</li><li>image: 图像格式解析类，目前支持BMP</li><li>media：<ul><li>H264Wrap: H264格式解析类</li><li>RTMPServer: RTMP Client,至此HLV、H264格式</li></ul></li><li>net: 使用C++分组的网络接口，支持TCP+TLS、UDP…</li><li>thread-pool:线程库</li></ul></li><li>test: 模块测试</li></ul><h3 id="后期计划"><a href="#后期计划" class="headerlink" title="后期计划:"></a>后期计划:</h3><ol><li>可以将各个模块的库分别打包，每个module拥有独立的lib, 输出utils再将各个模块lib整合，实现可定制化裁剪功能</li><li>将utils依赖的库放置于工程中， 并使用cmake编译环境</li></ol><h2 id="Hi3518"><a href="#Hi3518" class="headerlink" title="Hi3518"></a>Hi3518</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Hi3518基于Hislicon旗下3518芯片，实现流媒体传输，支持RTMP、RTSP协议</p><h3 id="项目主页-1"><a href="#项目主页-1" class="headerlink" title="项目主页"></a>项目主页</h3><ul><li><a href="https://github.com/CuijianSa/hi3518" target="_blank" rel="noopener">hi3518</a></li></ul><h3 id="功能列表-1"><a href="#功能列表-1" class="headerlink" title="功能列表"></a>功能列表</h3><ul><li>RTMP</li><li>RTSP</li><li>HLS</li></ul><h3 id="后期计划-1"><a href="#后期计划-1" class="headerlink" title="后期计划:"></a>后期计划:</h3><ul><li>依赖库自包含</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo命令</title>
      <link href="/2019/06/30/hexo%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/06/30/hexo%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-简介"><a href="#hexo-简介" class="headerlink" title="hexo 简介"></a>hexo 简介</h1><p>Hexo 是一套快速、简洁且高效的博客框架，使用Markdown解析文章生成静态网页</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>npm install hexo-cli -g</li><li>hexo init blog</li><li>cd blog</li><li>npm install</li><li>hexo server</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><ul><li>打开<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo themes</a>页面</li><li>将中意的thems下载在blog/themes</li><li>配置博客根目录下_config.yml文件，在theme添加上一步骤下载的主题文件夹名称</li></ul><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><ul><li>hexo init {folder}</li><li>cd {folder}</li><li>npm install</li><li>tree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ul><li>hexo init [folder]: 新建网站</li><li>hexo new [layout] <title>: 新建文章</title></li></ul><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>page</td><td>source/_drafts</td></tr></tbody></table><ul><li>hexo generate: 生成静态文件</li><li>hexo publish [layout] <filename></filename></li><li>hexo server:启动服务器</li><li>hexo deploy: 部署网站</li><li>hexo render: 渲染文件</li><li>hexo migrate <type>: 博客迁移</type></li><li>hexo clean: 清理缓存</li><li>hexo list: 列举网站资料</li><li>hexo version： hexo版本</li></ul><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo.io</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux应用程序加载</title>
      <link href="/2019/06/26/linux/linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/06/26/linux/linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">|             APPLICATION                 |</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">---------------------- --------------------         </span><br><span class="line">| libc.so ld-linux.so| | LD_LOADER|libso.z|</span><br><span class="line">---------------------- --------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">|            LINUX KERNEL                 |</span><br><span class="line">-------------------------------------------</span><br></pre></td></tr></table></figure><p>在同一个ARCH Machine, 一个完整的运行库都是可以运行的<br>ld-linux.so和libc.so强关联</p><h1 id="静态库搜索路径"><a href="#静态库搜索路径" class="headerlink" title="静态库搜索路径"></a>静态库搜索路径</h1><ul><li>gcc先从-L搜索</li><li>再从LIBRARY_PATH路径搜索</li><li>再从/usr /usr/lib /usr/local/lib. 这是由compile gcc编写在程序中</li></ul><h1 id="动态库搜索路径"><a href="#动态库搜索路径" class="headerlink" title="动态库搜索路径"></a>动态库搜索路径</h1><ul><li>编译目标代码时指定的动态库搜索路径-L</li><li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li><li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib /usr/lib/ /usr/local/lib</li></ul><h1 id="静态链接-编译时"><a href="#静态链接-编译时" class="headerlink" title="静态链接(编译时)"></a>静态链接(编译时)</h1><p>链接器将函数的代码从其所在地（目标文件或静态链接库中）拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码</p><p>为创建可执行文件，链接器必须要完成的主要任务：</p><ul><li>符号解析：把目标文件中符号的定义和引用联系起来</li><li>重定位：把符号定义和内存地址对应起来，然后修改所有对符号的引用</li></ul><h1 id="动态链接-加载、运行时"><a href="#动态链接-加载、运行时" class="headerlink" title="动态链接(加载、运行时)"></a>动态链接(加载、运行时)</h1><p>在此种方式下，函数的定义在动态链接库或共享对象的目标文件中。在编译的链接阶段，动态链接库只提供符号表和其他少量信息用于保证所有符号引用都有定义，保证编译顺利通过。动态链接器(ld-linux.so)链接程序在运行过程中根据记录的共享对象的符号定义来动态加载共享库，然后完成重定位。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码</p><h1 id="加载工程"><a href="#加载工程" class="headerlink" title="加载工程"></a>加载工程</h1><p>加载器首先创建如上图所示的内存映像，然后根据段头部表，把目标文件拷贝到内存的数据和代码段中。然后，加载器跳转到程序入口点（即符号_start 的地址），执行启动代码（startup code）</p><ul><li>AR ：创建静态库，插入、删除、列出和提取成员</li><li>STRINGS ：列出目标文件中所有可以打印的字符串</li><li>STRIP ：从目标文件中删除符号表信息</li><li>NM ：列出目标文件符号表中定义的符号</li><li>SIZE ：列出目标文件中节的名字和大小</li><li>READELF ：显示一个目标文件的完整结构，包括ELF 头中编码的所有信息</li><li>OBJDUMP ：显示目标文件的所有信息，最有用的功能是反汇编.text节中的二进制指令</li><li>LDD ：列出可执行文件在运行时需要的共享库</li><li>PATCHELF : ELF解析工具</li></ul><h1 id="软件打包"><a href="#软件打包" class="headerlink" title="软件打包"></a>软件打包</h1><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="patchelf-可以修改已编译运行程序的依赖库位置和指定库链接器"><a href="#patchelf-可以修改已编译运行程序的依赖库位置和指定库链接器" class="headerlink" title="patchelf 可以修改已编译运行程序的依赖库位置和指定库链接器"></a>patchelf 可以修改已编译运行程序的依赖库位置和指定库链接器</h3><ul><li>set-rpath: 修改可执行库的RPATH</li><li>set-interpreter: 修改动态加载”ELF解析器”给INTERPRETER</li><li>print-interpreter: 查找解析器</li><li>print-needed:查看file依赖库</li></ul><h3 id="file查看文件类型，ELF"><a href="#file查看文件类型，ELF" class="headerlink" title="file查看文件类型，ELF"></a>file查看文件类型，ELF</h3><p><code>getopt_long: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=1f8be3f23fd0851687854682e57818954e8a04e8, not stripped</code></p><ul><li>ELF:二进制文件、可执行文件、目标代码、共享库和核心转储格式文件</li><li>x86-64: CPU架构</li></ul><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><ul><li>Type:DYN，动态库</li><li>Machine:机器类型</li><li>Class：ELF位数</li></ul><h3 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h3><p>获取文件所有的依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux-vdso.so.1 (0x00007ffe3c715000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f89780a4000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f8978698000)</span><br></pre></td></tr></table></figure></p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>readelf 查看目标文件的Machine、ELF位数</li><li>ldd查看依赖库</li><li>搜索/usr/lib及/usr/lib64,匹配Machine、ELF、type，将动态库拷贝至目标文件夹</li><li>将ELF LD加载器拷贝至目标文件夹</li><li>使用patchelf,set-rpath、set-interpreter配置可执行库路径、libc加载器</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手+四次挥手</title>
      <link href="/2019/06/05/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B+%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/06/05/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B+%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/2019/06/05/网络/TCP三次握手+四次挥手/connect.png" alt=""></p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题:"></a>解决的问题:</h2><p>以最小的握手次数，达到C-S可靠的连接</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul><li>第一次握手: 建立连接时，客户端发送SYN(seq = x)包,并进入SYS_SENT状态，并等待信号回复</li><li>第二次握手: 服务端收到SYN包，必须确定客户的SYN，并且同时发送SYN+ACK(seq = y, ack = x+1)包，此时服务器进入SYN_RECV状态</li><li>第三次握手: 客户端收到服务器的SYN+ACK包，并向服务器发送确认包ACK(seq = x+1, ack = y+1),此时客户端及服务端ESTABLISHED状态</li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/2019/06/05/网络/TCP三次握手+四次挥手/disconnect.png" alt=""></p><h2 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题:"></a>解决的问题:</h2><p>实现C-S间挥手同步，因为涉及到数据的断开，多了一次挥手</p><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><ul><li>客户端发送连接释放报文，并且停止发送数据。FIN = 1,seq = u并进入FIN-WAIT-1状态</li><li>服务器收到FIN，并发出确认报文，ACK=1, ack = u+1,此时进入CLOSW-WAIT状态，并通知应用层客户端向服务端方向连接断开，此时客户端没有数据要发送了，此时服务器发送数据，客户端依然要接收</li><li>客户端收到服务器的确认请求后，客户端进入FIN-WAIT-2状态，等待服务器发送连接断开请求</li><li>服务器将最后的数据发送完毕后，向客户端发送连接释放报文,FIN=1,ack=u+1,服务器进入LAST-ACK状态</li><li>客户收到服务器的连接释放报文，必须发出确认，ACK=1,ack=w+1,seq=u+1,此时客户端进入TIME-WAIT状态。</li><li>注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些</li></ul><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li>为什么连接的时候是三次握手，关闭的时候却是四次握手</li></ul><p>因为当Server收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中SYN用来同步，ACK报文用来应答。在关闭连接时，Server收到FIN时，可能不会立即关闭SOCKET，可能并不会立即关闭SCOKET，所以只能先回复一个ACK报文，告诉Client端,”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手</p><ul><li>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态</li></ul><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><ul><li>为什么不能用两次握手进行连接？</li></ul><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。</p><p>作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><ul><li>如果已经建立了连接，但是客户端突然出现故障了怎么办？</li></ul><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongodb</title>
      <link href="/2019/05/07/SQL/mongodb/"/>
      <url>/2019/05/07/SQL/mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB基础概念"><a href="#MongoDB基础概念" class="headerlink" title="MongoDB基础概念"></a>MongoDB基础概念</h1><p>MongoDB是基于分布式文件存储的数据库，介于关系数据库和非关系数据库之间的产品</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点:"></a>优缺点:</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>可靠性(容错):分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。</li><li>可扩展性:在分布式计算系统可以根据需要增加更多的机器。</li><li>资源共享</li><li>灵活性:由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。</li><li>更快的速度:分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。</li><li>开放系统：由于它是开放的系统，本地或者远程都可以访问到该服务。</li><li>更高的性能：相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>故障排除:故障排除和诊断问题。</li><li>软件:更少的软件支持是分布式计算系统的主要缺点。</li><li>网络:网络基础设施的问题，包括：传输问题，高负载，信息丢失等。</li><li>安全性:开放系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。</li></ul><h2 id="RDBMS-vs-NoSQL"><a href="#RDBMS-vs-NoSQL" class="headerlink" title="RDBMS vs NoSQL"></a>RDBMS vs NoSQL</h2><p>RDBMS </p><ul><li>高度组织化结构化数据 </li><li>结构化查询语言（SQL） (SQL) </li><li>数据和关系都存储在单独的表中。 </li><li>数据操纵语言，数据定义语言 </li><li>严格的一致性</li><li>基础事务</li></ul><p>NoSQL </p><ul><li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式<br>-键 - 值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理 </li><li>高性能，高可用性和可伸缩性</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>下载： curl -O <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz</a></li><li>运行服务<code>mongod</code> </li><li>后台管理shell <code>mongo</code></li><li><code>&gt;show dbs</code>显示数据库列表</li><li><code>&gt;db</code>显示当前苏韩剧库对象或集合</li><li><code>&gt;use</code>连接指定的数据库</li></ul><p>特殊数据库</p><ul><li>admin:  从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器</li><li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li><li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li></ul><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>数据库的信息都是存储在集合中，它们使用了系统的命名空间<code>dbname.system.*</code></p><table><thead><tr><th>集合命名空间</th><th>描述</th></tr></thead><tbody><tr><td>dbname.system.namespaces</td><td>列出所有名字空间</td></tr><tr><td>dbname.system.indexes</td><td>列出所有索引</td></tr><tr><td>dbname.system.profile</td><td>包含数据库概要(profile)信息</td></tr><tr><td>dbname.system.users</td><td>列出所有可访问数据库的用户</td></tr><tr><td>dbname.local.sources</td><td>包含复制对端（slave）的服务器信息和状态</td></tr></tbody></table><h2 id="RDBMS-VS-MongoDB-术语对比"><a href="#RDBMS-VS-MongoDB-术语对比" class="headerlink" title="RDBMS VS MongoDB 术语对比"></a>RDBMS VS MongoDB 术语对比</h2><table><thead><tr><th>RDBMS</th><th>MongoDB</th></tr></thead><tbody><tr><td>数据库</td><td>数据库</td></tr><tr><td>表格</td><td>集合</td></tr><tr><td>行</td><td>文档</td></tr><tr><td>列</td><td>字段</td></tr><tr><td>表联合</td><td>嵌入文档</td></tr><tr><td>主键</td><td>主键 (MongoDB 提供了 key 为 _id )</td></tr><tr><td>Mysqld/Oracle</td><td>mongod</td></tr><tr><td>mysql/sqlplus</td><td>mongo</td></tr></tbody></table><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的</td></tr><tr><td>Interger</td><td>整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位</td></tr><tr><td>Boolean</td><td>布尔值， 用于存储布尔值（真/假）</td></tr><tr><td>Double</td><td>双精度浮点值。用于存储浮点值</td></tr><tr><td>Min/Max keys</td><td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比</td></tr><tr><td>Array</td><td>用于将数组或列表或多个值存储为一个键</td></tr><tr><td>Timestamp</td><td>时间戳。记录文档修改或添加的具体时间</td></tr><tr><td>Object</td><td>用于内嵌文档</td></tr><tr><td>Null</td><td>用于创建空值</td></tr><tr><td>Symbol</td><td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言</td></tr><tr><td>Date</td><td>日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息</td></tr><tr><td>Object ID</td><td>对象 ID。用于创建文档的 ID</td></tr><tr><td>Binary Data</td><td>二进制数据。用于存储二进制数据。</td></tr><tr><td>Code</td><td>代码类型。用于在文档中存储 JavaScript 代码</td></tr><tr><td>Regular expression</td><td>正则表达式类型。用于存储正则表达式</td></tr></tbody></table><ul><li>对象ID<ul><li>ObjectId 类似唯一主键，可以很快的去生成和排序，包含 12 bytes，含义是：    <ul><li>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时</li><li>接下来的 3 个字节是机器标识码</li><li>紧接的两个字节由进程 id 组成 PID</li><li>最后三个字节是随机数</li></ul></li></ul></li><li>字符串<ul><li>BSON 字符串都是 UTF-8 编码</li></ul></li><li>时间戳<ul><li>BSON 有一个特殊的时间戳类型用于 MongoDB 内部使用，与普通的 日期 类型不相关。 时间戳值是一个 64 位的值。其中：<ul><li>前32位是一个 time_t 值（与Unix新纪元相差的秒数）</li><li>后32位是在某秒中操作的一个递增的序数</li></ul></li><li>在单个 mongod 实例中，时间戳值通常是唯一的</li></ul></li><li>日期<ul><li>当前距离 Unix新纪元（1970年1月1日）的毫秒数。日期类型是有符号的, 负数表示 1970 年之前的日期。</li></ul></li></ul><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>UIR: <code>mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</code></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>epoll框架</title>
      <link href="/2019/04/08/%E7%BD%91%E7%BB%9C/epoll%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/04/08/%E7%BD%91%E7%BB%9C/epoll%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The  epoll  API performs a similar task to poll(2): monitoring multiple</span><br><span class="line">       file descriptors to see if I/O is possible on any of them.   The  epoll</span><br><span class="line">       API can be used either as an edge-triggered or a level-triggered inter‐</span><br><span class="line">       face and scales well to large numbers of watched file descriptors.  The</span><br><span class="line">       following  system  calls  are  provided  to  create and manage an epoll</span><br><span class="line">       instance:</span><br><span class="line"></span><br><span class="line">       *  epoll_create(2) creates a new epoll  instance  and  returns  a  file</span><br><span class="line">          descriptor  referring to that instance.  (The more recent epoll_cre‐</span><br><span class="line">          ate1(2) extends the functionality of epoll_create(2).)</span><br><span class="line"></span><br><span class="line">       *  Interest in particular  file  descriptors  is  then  registered  via</span><br><span class="line">          epoll_ctl(2).   The  set of file descriptors currently registered on</span><br><span class="line">          an epoll instance is sometimes called an epoll set.</span><br><span class="line"></span><br><span class="line">       *  epoll_wait(2) waits for I/O events, blocking the calling  thread  if</span><br><span class="line">          no events are currently available.</span><br></pre></td></tr></table></figure><h1 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h1><ul><li>int epoll_create(int size)<ul><li>描述: 创建一个epoll实例，为new epoll实例返回一个文件描述符， 可用close(2)关闭文件描述符</li></ul></li><li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data &#123;</span><br><span class="line">       void        *ptr;</span><br><span class="line">       int          fd;</span><br><span class="line">       uint32_t     u32;</span><br><span class="line">       uint64_t     u64;</span><br><span class="line">   &#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">   struct epoll_event &#123;</span><br><span class="line">       uint32_t     events;      /* Epoll events */</span><br><span class="line">       epoll_data_t data;        /* User data variable */</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><ul><li>op:<ul><li>EPOLL_CTL_ADD: Register  the  target  file  descriptor fd on the epoll instance referred to by the file descriptor epfd and associate the  event event with the internal file linked to fd.</li><li>EPOLL_CTL_MOD: Change  the event event associated with the target file descriptor fd.</li><li>EPOLL_CTL_DEL: Remove (deregister) the target file descriptor fd from the epoll instance  referred  to by epfd.  The event is ignored and can be NULL (but see BUGS below).</li></ul></li><li>event<ul><li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li><li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li></ul></li></ul></li><li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout):等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p></li></ul><h1 id="ET、LT工作模式"><a href="#ET、LT工作模式" class="headerlink" title="ET、LT工作模式"></a>ET、LT工作模式</h1><ul><li>LT（水平触发）模式下，只要这个文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；</li><li>ET（边缘触发）模式下，在它检测到有 I/O 事件时，通过 epoll_wait 调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，如可读，则必须将该文件描述符一直读到空，让 errno 返回 EAGAIN 为止，否则下次的 epoll_wait 不会返回余下的数据，会丢掉事件。如果ET模式不是非阻塞的，那这个一直读或一直写势必会在最后一次阻塞。</li></ul><p>epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知</p><h1 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXLEN 1024</span><br><span class="line">#define MAX_OPEN_FD 1024</span><br><span class="line">#define SERV_PORT 8000</span><br><span class="line"></span><br><span class="line">void setnonblocking(int sock)</span><br><span class="line">&#123;</span><br><span class="line">    int opts;</span><br><span class="line">    opts = fcntl(sock, F_GETFL);</span><br><span class="line">    if (opts &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fcntl(sock,GETFL)&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = opts | O_NONBLOCK;</span><br><span class="line">    if (fcntl(sock, F_SETFL, opts) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fcntl(sock,SETFL,opts)&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int listenfd, connfd, efd;</span><br><span class="line">    char buf[MAXLEN];</span><br><span class="line">    struct sockaddr_in cliaddr, servaddr;</span><br><span class="line">    socklen_t clilen = sizeof(cliaddr);</span><br><span class="line">    struct epoll_event ep[MAX_OPEN_FD], tep;</span><br><span class="line"></span><br><span class="line">    if (-1 == (listenfd = socket(AF_INET, SOCK_STREAM, 0)))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; __LINE__ &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    if (-1 == (bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr))))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; __LINE__ &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(listenfd,20);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(MAX_OPEN_FD);</span><br><span class="line">    tep.events = EPOLLIN;</span><br><span class="line">    tep.data.fd = listenfd;</span><br><span class="line"></span><br><span class="line">    if (-1 == epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; __LINE__ &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t nready = epoll_wait(efd, ep, MAX_OPEN_FD - 1, -1);</span><br><span class="line">        for (unsigned int i = 0; i &lt; nready; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //new client connect</span><br><span class="line">            if (ep[i].data.fd == listenfd)</span><br><span class="line">            &#123;</span><br><span class="line">                connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">                tep.events = EPOLLIN;</span><br><span class="line">                tep.data.fd = connfd;</span><br><span class="line">                if (-1 == epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep))</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; __LINE__ &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123; //read client dataa</span><br><span class="line">                connfd = ep[i].data.fd;</span><br><span class="line">                int bytes = read(connfd, buf, MAXLEN);</span><br><span class="line">                //peer socket is close</span><br><span class="line">                if (bytes == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    epoll_ctl(efd, EPOLL_CTL_DEL, connfd, NULL);</span><br><span class="line">                    close(connfd);</span><br><span class="line">                    cout &lt;&lt; &quot;client[&quot; &lt;&lt; i &lt;&lt; &quot;] is close&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    for (int j = 0; j &lt; bytes; ++j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        buf[j] = toupper(buf[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // write to client</span><br><span class="line">                    write(connfd, buf, bytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311" target="_blank" rel="noopener">epoll原理详解及epoll反应堆模型</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cmake-基本命令</title>
      <link href="/2019/04/04/%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6/cmake-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/04/04/%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6/cmake-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h1><ul><li>指定构建系统生成器: -G<ul><li>使用: -G可以指定编译器，当前平台支持的编译器名词可通过cmake –help查看，例如cmake -G “Visual Stdio 15 2017”</li></ul></li><li>CMakeCache.txt<ul><li>存放制定工程的设置，比如:变量、选项等</li><li>对于同一个变量，如果Cache文件里面有设置，那么CMakeLists文件里就会优先<br>使用Cache文件里面的同名变量。</li><li>CMakeLists里面通过设置了一个Cache里面没有的变量，那就将这个变量的值写<br>入到Cache里面</li><li>例子：<ul><li>SET (var 1024)<br>  //变量var的值被设置成1024，如果变量var在Cache中已经存在，该命令不会覆盖cache里面的值</li><li>SET (var 1024 ..CACHE..)//如果var在Cache中存在，就优先使用Cache里面的值，如果不存在，就将该值写<br>入Cache里面</li><li>SET (var..CACHE..FORCE)//无论Cache里面是否存在，都始终使用该值</li></ul></li></ul></li><li>添加变量到Cache文件中:-D<ul><li>注意：-D后面不能有空格，例如：cmake -DCMAKE_BUILD_TYPE:STRING=Debug</li></ul></li><li>从Cache文件中删除变量: -U<ul><li>从Cache文件中删除变量，支持* 和？通配符</li></ul></li><li>CMake命令行模式: -E<ul><li>非平台相关的命令，chdir、copy及copy_if_different等</li><li>cmake -E help进行查询</li></ul></li><li>打印运行的每一行CMake<ul><li>命令行选项:–trace,打印运行的每一行CMake</li><li>命令： –trace-source=”filename”打印有关filenae的执行</li></ul></li><li>设置编译参数<ul><li>add_definitions(-DENABLED)</li></ul></li><li>设置默认值命令: option<ul><li>设置自定义的宏，option(MY-MESSAGE “this is my message” ON)<ul><li>第一项: 默认值名称</li><li>第二项: 注释</li><li>第三项: 默认值,默认OFF</li><li>=== cmake -DMY-MESSAGE=on ../,命令行加D</li></ul></li></ul></li></ul><h1 id="基础简介"><a href="#基础简介" class="headerlink" title="基础简介"></a>基础简介</h1><ul><li>指定最低版本:cmake_minimnum_required(VERSION 3.1)</li><li>指定版本范围:cmake_minimnum_required(VERSION 3.1…3.12)</li><li>设置生成项目名称:project(MyProject)</li><li>RROJECT_SOURCE_DIR和CMAKE_SOURCE_DIR都指向工程的根目录</li><li>PROJECT_BINARY_DIR和CMAKE_BINARY_DIR都指向target编译的目录</li><li>生成可执行文件<ul><li>add_executable(exaname srcname)</li><li>aux_source_directory(<dir> <variable>)</variable></dir></li></ul></li><li>生成lib<ul><li>add_library(libname [SHARED| STATIC|MODULE] [EXCLUDE_FROM_ALL] source1  source2 …sourceN})<ul><li>[SHARED | STATIC | MODULE]: (动态库| 静态库| 模块)</li><li>[EXCLUDE_FROM_ALL]:该库不会被默认构建</li></ul></li></ul></li><li>添加头文件目录:<ul><li>target_include_directories(<target>[SYSTEM][BEFORE]&lt;INTERFACE|PUBLIC|PRIVATE&gt;[items1..]&lt;INTERFACE|PUBLIC|PRIVATE&gt;[items2..]…)<ul><li>target_include_directories(RigelEditor PUBLIC ./include/rgeditor),表示给RigelEditor这个子项目添加一个库文件的路径</li></ul></target></li><li>tinclude_directores([AFTER|BEFORE][SYSTEM] dir1 [dir2…])<ul><li>[AFTER|BEFORE]:添加到列表之前后之后</li><li>[SYSTEM]:把被包含的路径当作系统包含路径来处理</li></ul></li><li>两条指令的作用都是讲将include的目录添加到目标区别在于include_directories<br>是CMake编译所有目标的目录进行添加，target_include_directories是将<br>CMake编译的指定的特定目标的包含目录进行添加</li></ul></li><li>添加链接的库文件路径<ul><li>target_link_libraries(<target>[item1 ] [[debug|optimized|general]<item>]…)<ul><li>给目标设置链接设置链接时使用的库</li><li>debug：调试</li><li>optimized： 所有其他的配置类型</li><li>general：所有的配置</li></ul></item></target></li><li>link_libraries:<ul><li>给当前工程链接需要的库文件，全路径</li></ul></li></ul></li><li><p>控制目标的属性</p><ul><li>target有自己的属性集，如果我们没有显示的设置这些target的属性的话，CMake默认是<br>由相关的全局属性来填充target的属性</li><li>命令:set_target_properties(target1 target2 … PROPERTIES 属性名称1 值 属性名称1 值 …)</li><li>控制编译选项的属性:COMPILE_FLAGS</li><li>控制链接选项的属性:LINK_FLAGS</li><li>控制输出路径的属性:EXECUTABLE_OUTPUT_PATH、LIBRARY_OUTPUT_PATH</li><li>such as:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(exe</span><br><span class="line">    PROPERTIES</span><br><span class="line">    LINK_FLAGS -satic</span><br><span class="line">    LINK_FLAGS_RELEASE -s)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>变量和缓存</p><ul><li>局部变量:<ul><li>CMakeLists.txt相当于一个函数，第一个执行的CMakeLists.txt相当于主函数，正<br>常设置的变量不能跨越CMakeLists.txt文件，相当于局部变量只在当前函数域里<br>面作用一样，</li><li>设置变量：set(MY_VARIABLE “value”)</li><li>变量的名称通常大写</li><li>访问变量：${MY_VARIABLE}</li></ul></li><li>缓存变量:<ul><li>cache变量，相当于全局变量，都是在第一个执行的CMakeLists.txt<br>里面被设置的，不过在子项目的CMakeLists.txt文件里面也是可以修改这个变量<br>的，此时会影响父目录的CMakeLists.txt，这些变量用来配置整个工程，配置好<br>之后对整个工程使用</li><li>设置缓存变量：set(MY_CACHE_VALUE “cache_value” CACHE INTERNAL<br>“THIS IS MY CACHE VALUE”)</li></ul></li><li>环境变量：<ul><li>set(ENV{variable_name} value)</li><li>$ENV{varibale_name}</li></ul></li><li>内置变量:<ul><li>CMAKE_C_COMPILER:指定C编译器</li><li>CMAKE_CXX_COMPILER:指定C++编译器</li><li>EXECUTABLE_OUTPUT_PATH:指定可执行文件的存放路径</li><li>LIBRARY_OUT_PATH:指定库文件的放置路径</li><li>CMAKE_CURRENT_SOURCE_DIR:当前CMakeLists.txt所在的路径</li><li>CMAKE_BUILD_TYPE: Debug or Release</li><li>CMAKE_SOURCE_DIR: 工程的顶层目录</li><li>CMAKE_BINARY_DIR:当前构建的目录</li><li>CMAKE_CURRENT_LIST_LINE:内置变量所在的行</li></ul></li></ul></li></ul><h1 id="控制语法"><a href="#控制语法" class="headerlink" title="控制语法"></a>控制语法</h1><ul><li><p>if</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(expression)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line">else(expression)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">endif(expression)</span><br></pre></td></tr></table></figure><ul><li><p>基本语法</p><ul><li>expression: 空、N、NO、OFF、FALSE、NOTFOUND </li><li>if(not exp)</li><li>if(var1 and var2)</li><li>if(var1 or var2)</li><li>if(COMMAND cmd)</li><li>if(EXISTS dir)</li><li>if(EXISTS file)</li><li>if(file1 | S_NEWER_THAN file2):当file1比file2新，或file/file2有一个不能存在时为真，文件名需使用全路径</li><li>if(IS_DIRECTORY dir)</li><li>if(DEFINED var)</li><li>if(string MATCHES regex)，匹配正则表达式regex,such as   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF(&quot;hello &quot; MATCHES &quot;ell&quot;)</span><br><span class="line">MESSAGE(&quot;true&quot;)</span><br><span class="line">ENDIF(&quot;hello &quot; MATCHES &quot;ell&quot;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数字表达式</p><ul><li>if(var LESS number)</li><li>if(var GREATER number)</li><li>if(var EQUAL number)</li></ul></li><li>字母表顺序<ul><li>if(var1 STRLESS var2)</li><li>if(var1 STRGREATER var2)</li><li>if(var1 STREQUAL var2</li></ul></li></ul></li><li><p>While</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE(condition)</span><br><span class="line">    COMMAND1(ARGS...)</span><br><span class="line">    COMMAND2(ARGS...)</span><br><span class="line">ENDWHILE(condition)</span><br></pre></td></tr></table></figure></li><li><p>Foreach</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOREACH(loop_var arg1 arg2)</span><br><span class="line">    COMMAND1(ARGS...)</span><br><span class="line">    COMMAND2(ARGS...)</span><br><span class="line">ENDFOREACH(loop_var)</span><br></pre></td></tr></table></figure></li><li><p>宏和函数</p><ul><li><p>宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">macro([arg1 [arg2 [arg3]]])</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">endmacro()</span><br></pre></td></tr></table></figure></li><li><p>函数(function)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function([arg1 [arg2 [arg3]]])</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">endfunction()</span><br></pre></td></tr></table></figure></li><li><p>函数和宏的区别还在于，函数很难将计算结果传出来，使用宏就可以将一些值简单的<br>传出来</p></li><li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    macro(macroTest)</span><br><span class="line">    set(test1 &quot;aaa&quot;)</span><br><span class="line">    endmacro()</span><br><span class="line">    function(funTest)</span><br><span class="line">    set(test2 &quot;bbb&quot;)</span><br><span class="line">    endfunction()</span><br><span class="line">    macroTest()</span><br><span class="line">    message(&quot;$&#123;test1&#125;&quot;)</span><br><span class="line">    funTest()</span><br><span class="line">    message(&quot;$&#123;test2&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    运行上面这个代码，就会显示“aaa”，因为函数里面的test1是局部的，出了这个函</span><br><span class="line">数就出了他的作用域</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对文件的操作</p><ul><li>file(WRITE filename “message to write” …):WRITE选项会写一条消息到名为filename中，如果文件存在，则会覆<br>盖原文件，如果文件不存在，他将创建该文件</li><li>file(APPEND filename “message to write”… )</li><li>file(READ filename variable [LIMIT numBytes] [OFFSET offset] [HEX])</li><li>file(STRINGS filename variable [LIMIT_COUNT num] [LIMIT_INPUT<br>numBytes] [LIMIT_OUTPUT numBytes] [LENGTH_MINIMUM numBytes]<br>[LENGTH_MAXIMUM numBytes] [NEWLINE_CONSUME] [REGEX regex]<br>[NO_HEX_CONVERSION]</li><li>file(GLOB variable [RELATIVE path] [globbing expressions]…)</li><li>file(GLOB_RECURSE variable [RELATIVE path] [FOLLOW_SYMLINKS]<br>[globbing expressions]…)</li><li>file(REMOVE [file1…])</li><li>file(REMOVE_RECURSE [file1…])</li><li>file(MAKE_DIIRECOTRY [direcotry1 direcotry2 …])</li></ul></li></ul><h1 id="运行其他程序"><a href="#运行其他程序" class="headerlink" title="运行其他程序"></a>运行其他程序</h1><ul><li>execute_process<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">execute_process(COMMAND &lt;cmd1&gt; [args1...]]</span><br><span class="line">[COMMAND &lt;cmd2&gt; [args2...] [...]]</span><br><span class="line">[WORKING_DIRECTORY &lt;directory&gt;]</span><br><span class="line">[TIMEOUT &lt;seconds&gt;]</span><br><span class="line">[RESULT_VARIABLE &lt;variable&gt;]</span><br><span class="line">[OUTPUT_VARIABLE &lt;variable&gt;]</span><br><span class="line">[ERROR_VARIABLE &lt;variable&gt;]</span><br><span class="line">[INPUT_FILE &lt;file&gt;]</span><br><span class="line">[OUTPUT_FILE &lt;file&gt;]</span><br><span class="line">[ERROR_FILE &lt;file&gt;]</span><br><span class="line">[OUTPUT_QUIET]</span><br><span class="line">[ERROR_QUIET]</span><br><span class="line">[OUTPUT_STRIP_TRAILING_WHITESPACE]</span><br><span class="line">[ERROR_STRIP_TRAILING_WHITESPACE])</span><br></pre></td></tr></table></figure></li></ul><p>这条指令可以执行系统命令，将输出保存到cmake变量或文件中去，运行<br>一个或多个给定的命令序列，每一个进程的标准输出通过管道流向下一个进程的<br>标准输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set(MAKE_CMD &quot;/src/bin/make.bat&quot;)</span><br><span class="line">MESSAGE(&quot;COMMAND: $&#123;MAKE_CMD&#125;&quot;)</span><br><span class="line">execute_process(COMMAND &quot;$&#123;MAKE_CMD&#125;&quot;</span><br><span class="line">RESULT_VARIABLE CMD_ERROR</span><br><span class="line">OUTPUT_FILE CMD_OUTPUT)</span><br><span class="line">MESSAGE( STATUS &quot;CMD_ERROR:&quot; $&#123;CMD_ERROR&#125;)</span><br><span class="line">MESSAGE( STATUS &quot;CMD_OUTPUT:&quot; $&#123;CMD_OUTPUT&#125;)</span><br><span class="line">输出：</span><br><span class="line">COMMAND:/src/bin/make.bat</span><br><span class="line">CMD_ERROR:No such file or directory</span><br><span class="line">CMD_OUTPUT:</span><br><span class="line">（因为这个路径下面没有这个文件</span><br></pre></td></tr></table></figure><ul><li><p>构建时的运行命令</p><ul><li><p>调用python生成头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find_package(PythonInterp REQUIRED)</span><br><span class="line">add_custom_command(OUTPUT</span><br><span class="line">    &quot;#&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp&quot;</span><br><span class="line">    COMMAND &quot;$&#123;PYTHON_EXECUTABLE&#125;&quot;</span><br><span class="line">    &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/GenerateHeader.py&quot; --argument</span><br><span class="line">    DEPENDS some_target)</span><br><span class="line"></span><br><span class="line">    add_custom_target(generate_header ALL</span><br><span class="line">        DEPNENDS &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp&quot;)</span><br><span class="line">    install(FILES $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Gererated.hpp</span><br><span class="line">    DESTIATION include)</span><br></pre></td></tr></table></figure></li><li><p>find_package:查找链接库<br>  如果编译的过程使用了外部的库，事先并不知道其头文件和链接库的位置，得在编译命<br>令中加上包含外部库的查找路径，CMake中使用find_package方法</p><ul><li>find_package()查找***.cmake顺序<ul><li>首先查找CMAKE_MODULE_PATH路径</li><li>然会会在../.cmake/package或者../user/local/shared/的包路径查找&lt;库大写&gt;Config.cmake或者&lt;库名称小写&gt;-config.cmake</li></ul></li><li><p>**.cmake都会定义下面这些变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NAME&gt;_FOUND</span><br><span class="line">&lt;NAME&gt;_INCLUDE_DIRS or &lt;NAME&gt;_INCLUDES</span><br><span class="line">&lt;NAME&gt;_LIBRAROES or &lt;NAME&gt;_LIBRARIES or &lt;NAME&gt;_LIBS</span><br><span class="line">&lt;NAME&gt;_DEFINITIONS</span><br></pre></td></tr></table></figure></li><li><p>可通过cmake –help-module-list查看当前CMake中有那些支持的模块</p></li></ul></li><li><p>find模块<br>  find_path和find_library查找模块的头文件及库文件，然后将结果放到<name>_INCLUDE_DIR和<name>_LIBRARY</name></name></p><ul><li>find_path()</li><li>find_path(<var> name1[path1 path2 …])        </var></li></ul></li><li><p>add_custom_command:为工程添加一个自定义的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(TARGET target</span><br><span class="line">        PRE_BUILD | PRE_LINK| POST_BUILD</span><br><span class="line">        COMMAND command1[ARGS] [args1...]</span><br><span class="line">        [COMMAND command2[ARGS] [args2...] ...]</span><br><span class="line">        [WORKING_DIRECTORYdir]</span><br><span class="line">        [COMMENT comment][VERBATIM])</span><br></pre></td></tr></table></figure><ul><li>PRE_BUILD:在其他依赖项执行欠执行</li><li>PRE_LINK: 其他依赖项执行完成后执行</li><li>POST_BUILD:在目标构建后执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(TARGET $&#123;PROJECT_NAME&#125;</span><br><span class="line">    POST_BUILD</span><br><span class="line">    COMMAND $&#123;CMAKE_COMMAND&#125; -E sleep 5)</span><br><span class="line">add_custom_command(TARGET test_elf</span><br><span class="line">    PRE_BUILD</span><br><span class="line">    COMMAND</span><br><span class="line">    move /cfg/start.o $&#123;CMAKE_BINAARY_DIR&#125;/.)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>add_custom_command: 添加自定义命令产生一个输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(OUTPUT output1 [output2 ...]</span><br><span class="line">    COMMAND command1[ARGS][arg1...]</span><br><span class="line">    [COMMAND command2[ARGS][arg2...]..]</span><br><span class="line">    [MAIN_DEPENDCY depend]</span><br><span class="line">    [DEPENDS[depend...]]</span><br><span class="line">    [IMPLICT_DEPENDS&lt;lang1&gt; depend1 ..]</span><br><span class="line">    [WORKING_DIRECTORY dir]</span><br><span class="line">    [COMMENT comment][VARBARTIM][APPEND])</span><br></pre></td></tr></table></figure></li><li><p>add_custom_target:增加定制目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(Name [ALL] [command1 [args1...]]</span><br><span class="line">    [COMMAND command2 [args2...] ...]</span><br><span class="line">    [DEPENDS depend depend depend ... ]</span><br><span class="line">    [BYPRODUCTS [files...]]</span><br><span class="line">    [WORKING_DIRECTORY dir]</span><br><span class="line">    [COMMENT comment]</span><br><span class="line">    [VERBATIM] [USES_TERMINAL]</span><br><span class="line">    [SOURCES src1 [src2...]]</span><br></pre></td></tr></table></figure></li><li><p>add_custom_command和add_custom_target区别</p><ul><li>target:add_library或者add_executable生成的exe或者库，具有许多属性集</li><li>target：一般来说目标是调用：add_library或者add_executable生成的exe或者库，他们具有许多属性集，这些就是所谓目标，而使用如add_custom_target定义的叫做自定义目标，因此这些“目标”区别于正常的目标，他们不生成exe或者lib，但是仍然会具有一些正常目标相同的属性，构建他们的时候，只是调用了为他们设置的命令，如果自定义目标对于其他目标有依赖，那么就会优先生成依赖的那些目标</li></ul><ul><li>command:自定义命令：自定义命令不是一个“可构建”的对象，并且没有可以设置的属性，自定义命令是一个在构建依赖目标之前被调用的命令，自定义命令的依赖可以通过add_custom_command(TARGET target …)形式显式设置，也可以通过add_custom_command(OUTPUT output1 …)生成文件的形式隐式设置。显示执行的时候，每次构建目标，首先会执行自定义的命令，隐式执行的时候，如果自定义的命令依赖于其他文件，则在构建目标的时候先去执行生成其他文件</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cmake-find_package</title>
      <link href="/2019/04/01/%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6/cmake/"/>
      <url>/2019/04/01/%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6/cmake/</url>
      
        <content type="html"><![CDATA[<h1 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h1><h2 id="cmake-find-package基本原理"><a href="#cmake-find-package基本原理" class="headerlink" title="cmake find_package基本原理"></a>cmake find_package基本原理</h2><p>find_package()首先在模块路径中寻找Find.cmake, 一次为${CMAKE_MODULE_PATH}中所有目录，cmake 会将路径赋予相应的变量</p><p>以bzip为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#   BZIP2_FOUND - system has BZip2</span><br><span class="line">#   BZIP2_INCLUDE_DIR - the BZip2 include directory</span><br><span class="line">#   BZIP2_LIBRARIES - Link these to use BZip2</span><br><span class="line">#   BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_</span><br><span class="line">#   BZIP2_VERSION_STRING - the version of BZip2 found (since CMake 2.8.8)</span><br><span class="line"></span><br><span class="line">set(_BZIP2_PATHS PATHS</span><br><span class="line">  &quot;[HKEY_LOCAL_MACHINE\\SOFTWARE\\GnuWin32\\Bzip2;InstallPath]&quot;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">find_path(BZIP2_INCLUDE_DIR bzlib.h $&#123;_BZIP2_PATHS&#125; PATH_SUFFIXES include)</span><br><span class="line"></span><br><span class="line">if (NOT BZIP2_LIBRARIES)</span><br><span class="line">    find_library(BZIP2_LIBRARY_RELEASE NAMES bz2 bzip2 $&#123;_BZIP2_PATHS&#125; PATH_SUFFIXES lib)</span><br><span class="line">    find_library(BZIP2_LIBRARY_DEBUG NAMES bz2d bzip2d $&#123;_BZIP2_PATHS&#125; PATH_SUFFIXES lib)</span><br><span class="line"></span><br><span class="line">    include($&#123;CMAKE_CURRENT_LIST_DIR&#125;/SelectLibraryConfigurations.cmake)</span><br><span class="line">    SELECT_LIBRARY_CONFIGURATIONS(BZIP2)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line">if (BZIP2_INCLUDE_DIR AND EXISTS &quot;$&#123;BZIP2_INCLUDE_DIR&#125;/bzlib.h&quot;)</span><br><span class="line">    file(STRINGS &quot;$&#123;BZIP2_INCLUDE_DIR&#125;/bzlib.h&quot; BZLIB_H REGEX &quot;bzip2/libbzip2 version [0-9]+\\.[^ ]+ of [0-9]+ &quot;)</span><br><span class="line">    string(REGEX REPLACE &quot;.* bzip2/libbzip2 version ([0-9]+\\.[^ ]+) of [0-9]+ .*&quot; &quot;\\1&quot; BZIP2_VERSION_STRING &quot;$&#123;BZLIB_H&#125;&quot;)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line">include($&#123;CMAKE_CURRENT_LIST_DIR&#125;/FindPackageHandleStandardArgs.cmake)</span><br><span class="line">FIND_PACKAGE_HANDLE_STANDARD_ARGS(BZip2</span><br><span class="line">                                  REQUIRED_VARS BZIP2_LIBRARIES BZIP2_INCLUDE_DIR</span><br><span class="line">                                  VERSION_VAR BZIP2_VERSION_STRING)</span><br><span class="line"></span><br><span class="line">if (BZIP2_FOUND)</span><br><span class="line">   include($&#123;CMAKE_CURRENT_LIST_DIR&#125;/CheckSymbolExists.cmake)</span><br><span class="line">   include($&#123;CMAKE_CURRENT_LIST_DIR&#125;/CMakePushCheckState.cmake)</span><br><span class="line">   cmake_push_check_state()</span><br><span class="line">   set(CMAKE_REQUIRED_QUIET $&#123;BZip2_FIND_QUIETLY&#125;)</span><br><span class="line">   set(CMAKE_REQUIRED_INCLUDES $&#123;BZIP2_INCLUDE_DIR&#125;)</span><br><span class="line">   set(CMAKE_REQUIRED_LIBRARIES $&#123;BZIP2_LIBRARIES&#125;)</span><br><span class="line">   CHECK_SYMBOL_EXISTS(BZ2_bzCompressInit &quot;bzlib.h&quot; BZIP2_NEED_PREFIX)</span><br><span class="line">   cmake_pop_check_state()</span><br><span class="line"></span><br><span class="line">    if(NOT TARGET BZip2::BZip2)</span><br><span class="line">      add_library(BZip2::BZip2 UNKNOWN IMPORTED)</span><br><span class="line">      set_target_properties(BZip2::BZip2 PROPERTIES</span><br><span class="line">        INTERFACE_INCLUDE_DIRECTORIES &quot;$&#123;BZIP2_INCLUDE_DIRS&#125;&quot;)</span><br><span class="line"></span><br><span class="line">      if(BZIP2_LIBRARY_RELEASE)</span><br><span class="line">        set_property(TARGET BZip2::BZip2 APPEND PROPERTY</span><br><span class="line">          IMPORTED_CONFIGURATIONS RELEASE)</span><br><span class="line">        set_target_properties(BZip2::BZip2 PROPERTIES</span><br><span class="line">          IMPORTED_LOCATION_RELEASE &quot;$&#123;BZIP2_LIBRARY_RELEASE&#125;&quot;)</span><br><span class="line">      endif()</span><br><span class="line"></span><br><span class="line">      if(BZIP2_LIBRARY_DEBUG)</span><br><span class="line">        set_property(TARGET BZip2::BZip2 APPEND PROPERTY</span><br><span class="line">          IMPORTED_CONFIGURATIONS DEBUG)</span><br><span class="line">        set_target_properties(BZip2::BZip2 PROPERTIES</span><br><span class="line">          IMPORTED_LOCATION_DEBUG &quot;$&#123;BZIP2_LIBRARY_DEBUG&#125;&quot;)</span><br><span class="line">      endif()</span><br><span class="line"></span><br><span class="line">      if(NOT BZIP2_LIBRARY_RELEASE AND NOT BZIP2_LIBRARY_DEBUG)</span><br><span class="line">        set_property(TARGET BZip2::BZip2 APPEND PROPERTY</span><br><span class="line">          IMPORTED_LOCATION &quot;$&#123;BZIP2_LIBRARY&#125;&quot;)</span><br><span class="line">      endif()</span><br><span class="line">    endif()</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line">mark_as_advanced(BZIP2_INCLUDE_DIR)</span><br></pre></td></tr></table></figure><ul><li>安装相应的lib,<code>sudo apt-get install libbz2-dev</code></li><li>查看CMake模块<code>cmake --help-module FindBZip2</code></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line">message($&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_MODULE_PATH /usr/share/cmake-3.10/Modules)</span><br><span class="line">message($&#123;CMAKE_MODULE_PATH&#125;)</span><br><span class="line"></span><br><span class="line">find_package(BZip2)</span><br><span class="line"></span><br><span class="line">if (BZIP2_FOUND)</span><br><span class="line">message($&#123;BZIP2_INCLUDE_DIR&#125;)</span><br><span class="line">message($&#123;BZIP2_LIBRARIES&#125;)</span><br><span class="line">message($&#123;BZIP2_NEED_PREFIX&#125;)</span><br><span class="line">message($&#123;BZIP2_VERSION_STRING&#125;)</span><br><span class="line">endif(BZIP2_FOUND)</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/cuijian/do/git/utils/test/cmake_find_package</span><br><span class="line">/usr/share/cmake-3.10/Modules</span><br><span class="line">/usr/include</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libbz2.so</span><br><span class="line">1</span><br><span class="line">1.0.6</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写cmake-module"><a href="#编写cmake-module" class="headerlink" title="编写cmake module"></a>编写cmake module</h2><ul><li>文件目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── cmake</span><br><span class="line">│   └── FindDEMOLIB.cmake</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── demo.cpp</span><br><span class="line">├── demo.h</span><br><span class="line">└── demo_main.cpp</span><br><span class="line"></span><br><span class="line">1 directory, 5 files</span><br></pre></td></tr></table></figure><ul><li><p>CMakeLists.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line">message($&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_MODULE_PATH /usr/share/cmake-3.10/Modules)</span><br><span class="line">message(&quot;CMAKE_MODULE_PATH:$&#123;CMAKE_MODULE_PATH&#125;&quot;)</span><br><span class="line"></span><br><span class="line">find_package(BZip2)</span><br><span class="line"></span><br><span class="line">if (BZIP2_FOUND)</span><br><span class="line">message($&#123;BZIP2_INCLUDE_DIR&#125;)</span><br><span class="line">message($&#123;BZIP2_LIBRARIES&#125;)</span><br><span class="line">message($&#123;BZIP2_NEED_PREFIX&#125;)</span><br><span class="line">message($&#123;BZIP2_VERSION_STRING&#125;)</span><br><span class="line">endif(BZIP2_FOUND)</span><br><span class="line"></span><br><span class="line">set(SRC_LIB demo.cpp)</span><br><span class="line">add_library(demolib STATIC $&#123;SRC_LIB&#125;)</span><br><span class="line"></span><br><span class="line">set(DESTINATION $&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">install(TARGETS demolib DESTINATION $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="line">install(FILES demo.h DESTINATION $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)</span><br><span class="line">message(&quot;CMAKE_MODULE_PATH:$&#123;CMAKE_MODULE_PATH&#125;&quot;)</span><br><span class="line">find_package(DEMOLIB)</span><br><span class="line"></span><br><span class="line">if(DEMOLIB_FOUND)</span><br><span class="line">    add_executable(demo_main demo_main.cpp)</span><br><span class="line">    message(&quot;found demo9 $&#123;DEMOLIB_INCLUDE_DIR&#125; $&#123;DEMOLIB_LIBRARY&#125;&quot;)</span><br><span class="line">    include_directories($&#123;DEMOLIB_INCLUDE_DIR&#125;)</span><br><span class="line">    target_link_libraries(demo_main $&#123;DEMOLIB_LIBRARY&#125;)</span><br><span class="line">else()</span><br><span class="line">    message(&quot;not found DEMOLIB&quot;)</span><br><span class="line">endif(DEMOLIB_FOUND)</span><br></pre></td></tr></table></figure></li><li><p>FindDEMOLIB.cmake</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message(&quot;using FindDEMOLIB.cmake find demolib&quot;)</span><br><span class="line"></span><br><span class="line">FIND_PATH(DEMOLIB_INCLUDE_DIR demo.h $&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line">message(&quot;DEMOLIB_INCLUDE_DIR:$&#123;DEMOLIB_INCLUDE_DIR&#125;&quot;)</span><br><span class="line"></span><br><span class="line">FIND_LIBRARY(DEMOLIB_LIBRARY libdemolib.a $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="line">message(&quot;DEMOLIB_LIBRARY:$&#123;DEMOLIB_LIBRARY&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if(DEMOLIB_INCLUDE_DIR AND DEMOLIB_LIBRARY)</span><br><span class="line">    set(DEMOLIB_FOUND TRUE)</span><br><span class="line">endif(DEMOLIB_INCLUDE_DIR AND DEMOLIB_LIBRARY)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类型转换</title>
      <link href="/2019/03/30/C++/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/03/30/C++/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/chenyangchun/p/6795923.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangchun/p/6795923.html</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指针详解</title>
      <link href="/2019/03/29/C++/%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/03/29/C++/%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的指针类型"><a href="#常见的指针类型" class="headerlink" title="常见的指针类型"></a>常见的指针类型</h1><ul><li><em>int p</em>: int类型整形变量</li><li><em>int </em>p<em>: 指向int类型数据的指针；.p和</em>结合，表明p为指针，指针指向的内容为int类型</li><li><em>int p[3]</em>: p为int类型数组组成的数组;p和[]结合标识p是一个数组，然和int结合标识数组元素是整形</li><li><em>int </em>p[3]<em>: p为指向int类型指针组成的数组； p和[]结合标识p为数组， 然后和int </em>结合表示数组存储的数据类型为int*类型的指针</li><li><em>int (</em>p)[3]<em>: p为指向整型数据组成的数组的指针；p和</em>结合表示p为指针， 然后和[]结合表示表示p指向的是一个数组， 数组存储的值为int类型的数据</li><li><em>int **p</em>: 指向指针的指针，二级指针；p和<em>结合表示p为一个指针，然和</em>结合表示p指向的地址存储的值为一个int类型的指针</li><li><em>int (</em>p)(int)<em>: p指向有一个整形参数且返回类型为int类型的函数的指针；p和</em>结合表示p为一个指针,然后和()结合表示p指向一个函数，函数入参为int类型，且返回值为int类型</li><li><em>int </em>(<em>p(int</em>))[3]<em>: p是一个参数为int类型且返回值指向一个int指针组成的数组的函数;p和()结合表示p是一个函数， 且入参为int</em>, 函数返回一个指针，然后和[]结合表示指针指向一个数组， 数组的返回值为int类型的指针</li></ul><h1 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value;  </span><br><span class="line">value=array[0]; //也可写成：value=*array;  </span><br><span class="line">value=array[3]; //也可写成：value=*(array+3);  </span><br><span class="line">value=array[4]; //也可写成：value=*(array+4);</span><br></pre></td></tr></table></figure><p>int <em>p = array;<br>p + 3 &lt;===&gt; p + 3 </em> sizeof(int)</p><p><em>需注意</em><br>int arr[5]<br>对数组名取地址不代表存储数组首地址的指针的地址, arr == &amp;arr, 但他们的类型不一样</p><ul><li>arr = &amp;arr[0], 类型int *</li><li>&amp;arr = 指向整个数组的指针，类型int (*)[5]</li></ul><p>DBUS_EXPORT dbus_bool_t dbus_message_append_args    (   DBusMessage *   message,<br>int     first_arg_type,<br>    …<br>)<br>曾经在DBus吃过大亏， dbus_message_append_args第三个参数为void **, 传入&amp;arr会造成coredump<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBUS_EXPORT dbus_bool_t dbus_message_append_args    (   DBusMessage *   message,</span><br><span class="line">int     first_arg_type,</span><br><span class="line">    ... </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多进程线程通信同步总结</title>
      <link href="/2019/03/29/linux/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%90%8C%E6%AD%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/29/linux/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%90%8C%E6%AD%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><ol><li>pipe and fifo</li></ol><ul><li>管道（pipe): 具有亲缘关系进程的通信</li><li>命名管道(fifo): 支持无亲缘关系进程的通信</li></ul><ol start="2"><li>signal</li></ol><ul><li>用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身(signal, sigaction)</li></ul><ol start="3"><li>消息队列</li></ol><ul><li>消息的链接表(msgget)有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li></ul><ol start="4"><li>共享内存:</li></ol><ul><li>使多个进程可以访问同一块内存空间，信号量结合使用，来达到进程间的同步及互斥(shmget + shmat)</li></ul><ol start="5"><li>信号量:</li></ol><ul><li>主要作为进程间以及同一进程不同线程之间的同步手段(semget + semctl)</li></ul><ol start="6"><li>套接字:</li></ol><ul><li>一般的进程间通信机制，可用于不同机器之间的进程间通信(socket)</li></ul><p>进程有以下几个要素:</p><ul><li>有一段可执行程序</li><li>有专用的堆栈空间</li><li>内核有它的控制块，描述进程所占用的资源，这样，进程才能接受内核的调度</li><li>具有独立的存储空间</li></ul><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p><ol><li>互斥锁</li></ol><ul><li>互斥量本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量。对互斥量进行枷锁以后，其他视图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变成运行状态的线程可以对互斥量加锁，其他线程就会看到互斥量依然是锁着，只能再次阻塞等待它重新变成可用，这样，一次只有一个线程可以向前执行(pthread_mutex_lock + pthread_mutex_unlock)</li><li>死锁：一个线程需要访问两个或者更多不同的共享资源，而每个资源又有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发生死锁。死锁就是指多个线程/进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进<ul><li>预防死锁：破坏死锁产生的四个条件：互斥条件、不剥夺条件、请求和保持条件以及循环等待条件</li><li>避免死锁：在每次进行资源分配前，应该计算此次分配资源的安全性，如果此次资源分配不会导致系统进入不安全状态，那么将资源分配给进程，否则等待</li><li>检测死锁：检测到死锁后通过资源剥夺、撤销进程、进程回退等方法解除死锁</li></ul></li></ul><ol start="2"><li>读写锁</li></ol><ul><li>读写锁有3种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。<br>当读写锁是写加锁状态时，在这个锁被解锁之前，所有视图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止（pthread_rwlock_rdlock+pthread_rwlock_wlock+pthread_rwlock_unlock)</li></ul><ol start="3"><li>条件变量</li></ol><ul><li>互斥量用于上锁，条件变量则用于等待，并且条件变量总是需要与互斥量一起使用，运行线程以无竞争的方式等待特定的条件发生。<br>条件变量本身是由互斥量保护的，线程在改变条件变量之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种变化，因为互斥量必须在锁定之后才能计算条件(pthread_condwait+pthread_signal)</li></ul><ol start="4"><li>信号量</li></ol><ul><li>信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源(sem_post+sem_wait)</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="互斥-同步"><a href="#互斥-同步" class="headerlink" title="互斥+同步"></a>互斥+同步</h2><ul><li>互斥: 某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的</li><li>同步：主要是流程上的概念，是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</li></ul><h2 id="互斥锁-条件变量-信号量"><a href="#互斥锁-条件变量-信号量" class="headerlink" title="互斥锁+条件变量+信号量"></a>互斥锁+条件变量+信号量</h2><ul><li>互斥锁：互斥，一个线程占用了某个资源，那么其它的线程就无法访问，直到这个线程解锁，其它线程才可以访问</li><li>条件变量：同步，一个线程完成了某一个动作就通过条件变量发送信号告诉别的线程，别的线程再进行某些动作。条件变量必须和互斥锁配合使用</li><li>信号量：同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而且信号量有一个更加强大的功能，信号量可以用作为资源计数器，把信号量的值初始化为某个资源当前可用的数量，使用一个之后递减，归还一个之后递增</li></ul><ol><li>信号量可以模拟条件变量，因为条件变量和互斥量配合使用，相当于信号量模拟条件变量和互斥量的组合。在生产者消费者线程池中，生产者生产数据后就会发送一个信号 pthread_cond_signal通知消费者线程，消费者线程通过pthread_cond_wait等待到了信号就可以继续执行。这是用条件变量和互斥锁实现生产者消费者线程的同步，用信号量一样可以实现</li><li>信号量可以模拟互斥量，因为互斥量只能为加锁或解锁（0 or 1），信号量值可以为非负整数，也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，就完成一个资源的互斥访问。前面说了，信号量主要用做多线程多任务之间的同步，而同步能够控制线程访问的流程，当信号量为单值时，必须有线程释放，其他线程才能获得，同一个时刻只有一个线程在运行（注意，这个运行不一定是访问资源，可能是计算）。如果线程是在访问资源，就相当于实现了对这个资源的互斥访问</li><li>互斥锁是为上锁而优化的；条件变量是为等待而优化的； 信号量既可用于上锁，也可用于等待，因此会有更多的开销和更高的复杂性</li><li>互斥锁，条件变量都只用于同一个进程的各线程间，而信号量（有名信号量）可用于不同进程间的同步。当信号量用于进程间同步时，要求信号量建立在共享内存区</li><li>互斥量必须由同一线程获取以及释放，信号量和条件变量则可以由一个线程释放，另一个线程得到</li><li>信号量的递增和减少会被系统自动记住，系统内部的计数器实现信号量，不必担心丢失，而唤醒一个条件变量时，如果没有相应的线程在等待该条件变量，此次唤醒会被丢失</li></ol><h1 id="好博文参考"><a href="#好博文参考" class="headerlink" title="好博文参考"></a>好博文参考</h1><ul><li><a href="https://blog.csdn.net/wh_sjc/article/details/70283843" target="_blank" rel="noopener">进程间的五种通信方式介绍</a></li><li><a href="https://blog.csdn.net/liu5320102/article/details/50764645" target="_blank" rel="noopener">线程间的通信、同步方式与进程间通信方式</a></li><li><a href="https://blog.csdn.net/a987073381/article/details/52029070" target="_blank" rel="noopener">linux线程间通信及同步机制总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程调试</title>
      <link href="/2019/03/20/linux/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
      <url>/2019/03/20/linux/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol><li>gdb attach $PID:attach 进程</li><li>info threads: 显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    Id   Target Id         Frame </span><br><span class="line">* 1    Thread 0x7f8ef79ec740 (LWP 3994) &quot;thread_demo&quot; 0x00007f8ef75d1d2d in __GI___pthread_timedjoin_ex (threadid=140251998291712, thread_return=0x0, </span><br><span class="line">    abstime=0x0, block=&lt;optimized out&gt;) at pthread_join_common.c:89</span><br><span class="line">  2    Thread 0x7f8ef6898700 (LWP 3995) &quot;thread_demo&quot; 0x00007f8ef6f339d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f8ef6897ea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef6897ea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">  3    Thread 0x7f8ef6097700 (LWP 3996) &quot;thread_demo&quot; 0x00007f8ef6f339d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f8ef6096ea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef6096ea0)</span><br></pre></td></tr></table></figure><ol start="3"><li>thread ID:切换当前调试的线程为指定ID的线程</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Switching to thread 1 (Thread 0x7f8ef79ec740 (LWP 3994))]</span><br></pre></td></tr></table></figure><ol start="4"><li>打印堆栈信息: thread apply all bt</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hread 11 (Thread 0x7f8ef208f700 (LWP 4004)):</span><br><span class="line">#0  0x00007f8ef6f339d0 in __GI___nanosleep (</span><br><span class="line">    requested_time=requested_time@entry=0x7f8ef208eea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef208eea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">#1  0x00007f8ef6f338aa in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55</span><br><span class="line">#2  0x00005580971cdaa2 in thread_route (arg=0x0) at thread_demo.cpp:10</span><br><span class="line">#3  0x00007f8ef75d06db in start_thread (arg=0x7f8ef208f700)</span><br><span class="line">    at pthread_create.c:463</span><br><span class="line">#4  0x00007f8ef6f7088f in clone ()</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br><span class="line"></span><br><span class="line">Thread 10 (Thread 0x7f8ef2890700 (LWP 4003)):</span><br><span class="line">#0  0x00007f8ef6f339d0 in __GI___nanosleep (</span><br><span class="line">    requested_time=requested_time@entry=0x7f8ef288fea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef288fea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">#1  0x00007f8ef6f338aa in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55</span><br><span class="line">#2  0x00005580971cdaa2 in thread_route (arg=0x0) at thread_demo.cpp:10</span><br><span class="line">#3  0x00007f8ef75d06db in start_thread (arg=0x7f8ef2890700)</span><br><span class="line">    at pthread_create.c:463</span><br><span class="line">#4  0x00007f8ef6f7088f in clone ()</span><br></pre></td></tr></table></figure><ol start="5"><li>Thread apply ID1 ID2:让一个或者多个线程执行command命令</li><li>Set scheduler-locking off|on|step<ul><li>设置locking scheduler模式<ul><li>ON：只有当前线程运行</li><li>Off：所有线程都会运行</li><li>Step：当执行step操作时只有当前线程会运行，执行continue所有线程都会运行<ol start="7"><li>ps aux | grep thread_demo:查看当前运行的经常</li><li>ps -aL | grep thread_demo:查看当前运行的轻量级进程</li><li>pstree -p 主线程ID:查看线程关系</li><li>查看线程栈结构: ps stack 线程ID</li></ol></li></ul></li></ul></li></ol><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void *thread_route(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    sleep(random());</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    pthread_t threadID[10];</span><br><span class="line">    cout&lt;&lt;&quot;pthread runing&quot;&lt;&lt;endl;</span><br><span class="line">    for(i = 0; i &lt; sizeof(threadID) / sizeof(threadID[0]); i++) &#123;</span><br><span class="line">        pthread_create(&amp;threadID[i], NULL, thread_route, NULL);</span><br><span class="line">    &#125;   </span><br><span class="line">    for(i = 0; i &lt; sizeof(threadID) / sizeof(threadID[0]); i++) &#123;</span><br><span class="line"></span><br><span class="line">        pthread_join(threadID[i], NULL);</span><br><span class="line">    &#125;   </span><br><span class="line">    cout&lt;&lt;&quot;pthread end&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句</title>
      <link href="/2019/03/10/SQL/SQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/03/10/SQL/SQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table><thead><tr><th>存储类</th><th>Describe</th></tr></thead><tbody><tr><td>NULL</td><td>NULL值</td></tr><tr><td>INTEGER</td><td>带符号整数，size=1,2,3,4,6 or 8</td></tr><tr><td>REAL</td><td>浮点值,size=8的IEEE浮点数字</td></tr><tr><td>TEXT</td><td>文本字符串</td></tr><tr><td>BLOB</td><td>blob数据， 类型由输入存储</td></tr></tbody></table><h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE if not exists database_name.table_name(</span><br><span class="line">   column1 datatype  PRIMARY KEY(one or more columns),</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE database_name.table_name;</span><br></pre></td></tr></table></figure><h1 id="插入表"><a href="#插入表" class="headerlink" title="插入表"></a>插入表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME(column1, column2, ... columnN)</span><br><span class="line">VALUES (value1, value2, ... valueN)</span><br></pre></td></tr></table></figure><h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name;</span><br></pre></td></tr></table></figure><h1 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h1><p>可应用于SELCT、UPDATE、DELETE,用来过滤记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name</span><br><span class="line">WHERE[CONDITION | EXPRESSION];</span><br></pre></td></tr></table></figure><h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">set column1=value1, column2=value2...., columnN=valueN</span><br><span class="line">where[CONDITION];</span><br></pre></td></tr></table></figure><h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE[CONDITION];</span><br></pre></td></tr></table></figure><h1 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h1><p>LINK匹配通配符</p><ul><li>%：表示0、1或者多个数字或字符</li><li>_：表示单一的数字或字符</li></ul><p>such as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET column_list FROM table_name</span><br><span class="line">where column LIKE &apos;xxx%&apos;;</span><br></pre></td></tr></table></figure></p><h1 id="Glob"><a href="#Glob" class="headerlink" title="Glob"></a>Glob</h1><p>Glob匹配通配符， 大小敏感</p><ul><li>*：表示0、1或者多个数字或字符</li><li>?： 表示单一的数字或字符</li></ul><h1 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h1><p>Limit限制SELECT 返回的数据量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cloumn1, column2 ...</span><br><span class="line">FROM table_name</span><br><span class="line">LIMIT [no of rows]</span><br><span class="line"></span><br><span class="line">such as:</span><br><span class="line">SELECT * FROM COMPANY LIMIT 3 OFFSET 2;</span><br></pre></td></tr></table></figure><h1 id="Order-By"><a href="#Order-By" class="headerlink" title="Order By"></a>Order By</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE condition]</span><br><span class="line">[ORDER BY column1, coulum2, ...][ASC|DESC];</span><br></pre></td></tr></table></figure><h1 id="Group-By"><a href="#Group-By" class="headerlink" title="Group By"></a>Group By</h1><p>SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。<br>在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE[conditions]</span><br><span class="line">GROUP BY column1, ....</span><br><span class="line">ORDER BY column1,....;</span><br></pre></td></tr></table></figure><h1 id="Having-子句"><a href="#Having-子句" class="headerlink" title="Having 子句"></a>Having 子句</h1><p>Having子句允许指定条件来过滤将出现在最终结果的分组<br>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br><span class="line"></span><br><span class="line">such as:</span><br><span class="line">SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2;</span><br></pre></td></tr></table></figure><h1 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h1><p>DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。</p><p>有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。</p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul><li>NOT NULL: 确保某列不能为NULL</li><li>DEFAULT: 当莫列没有指定值时， 为该列提供默认值</li><li>UNIQUE: 确保某列的所有值不同</li><li>PRIMARY Key: 为一标识数据库表的各行和数据</li><li>CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件</li></ul><h1 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h1><p>SQLite 的 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段</p><ul><li>交叉连接 - CROSS JOIN</li><li>内连接 - INNER JOIN</li><li>外连接 - OUTER JOIN</li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>getaddrinfo爬坑</title>
      <link href="/2019/02/21/other/getaddrinfo%E7%88%AC%E5%9D%91/"/>
      <url>/2019/02/21/other/getaddrinfo%E7%88%AC%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>最近发现了客户一个问题， LE程序自启动一直连接不上服务端， 重启程序后成功</p><p>查看日志， getaddrinfo一直打印Tempoary failed in name soluation</p><p>开机时由systemd拉起程序, 此时网络服务并没有初始化成功， 此时连接失败时符合预期的， 间隔一段时间后， 发现还一直报域名服务失败</p><ol><li>此时采用ping 服务器域名， 发现网络正常</li><li>编写demo, 手动执行发现可以正常获取域名</li></ol><p>一开始被getaddrinfo文档误导了,一开始也考虑过缓存的问题，但getaddrinfow文档显示为MT-safe， 就首先排除这个选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────┬───────────────┬────────────────────┐</span><br><span class="line">│Interface       │ Attribute     │ Value              │</span><br><span class="line">├────────────────┼───────────────┼────────────────────┤</span><br><span class="line">│getaddrinfo()   │ Thread safety │ MT-Safe env locale │</span><br><span class="line">├────────────────┼───────────────┼────────────────────┤</span><br><span class="line">│freeaddrinfo(), │ Thread safety │ MT-Safe            │</span><br><span class="line">│gai_strerror()  │               │                    │</span><br><span class="line">└────────────────┴───────────────┴────────────────────┘</span><br></pre></td></tr></table></figure><p>后期发现DNS做了一次缓存…….</p><p>在使用 getaddrinfo 函数的时候，实际会使用 glibc 的相关函数，glibc 在应用第一次域名解析的时候会触发 res_init() 函数的调用，res_init() 函数的作用是读取 /etc/resolv.conf 的内容, 如 nameserver 地址、负载均衡策略、重试次数、超时时间等，并将读取的这些数据放到 static 类型的 <em>res</em> 结构体中。</p><p>由于 Linux 的进程在使用 glibc 动态链接库全局静态变量的时候，都会在用户进程空间生成自己独立的变量副本（感兴趣的同学可以查看每个进程的 smaps 文件，glibc 在每个用户进程空间都有可读、可写的 segment），所以每个发起 DNS 解析的进程都具有独立的 <em>res</em> 结构体变量。</p><p>回到 salt-minio 这个具体案例，salt-minion 进程启动后发起第一次域名解析请求，该请求最后会调用底层的 res_query，第一次 res_query 会调用 res_init()，res_init() 初始化后，nameserver 地址被初始化到当前进程的 <em>res</em> 结构体中， 然而 res_init() 对于每个进程来说，只会执行一次。</p><p>运维同学在用户进程运行的时候修改掉 /etc/resolv.conf 中的配置，但修改配置后无法生效的根本原因就在此（因为用户进程空间的 _res 结构体中仍然存放的是老的 nameserver 配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The functions described below make queriesto and interpret the responses from Internet domain name servers.The API consists of a set of more modern, reentrant functions and an older set of nonreentrant functions that have been superseded. The traditional resolver interfaces such as res_init() and res_query() use some static (global) state stored in the _res structure, rendering these functions non-thread-safe. BIND 8.2 introduced a set of new interfaces res_ninit(), res_nquery(), and so on, which take a res_state as their first argument, so you can use a per-thread</span><br><span class="line"></span><br><span class="line">resolver state.The res_ninit() and res_init() functions read the configuration files (see resolv.conf(5)) to get the default domain name and name server address(es).If no server isgiven, the local host is tried. If no domain is given, that associated with thelocal host is used. It can be overridden with the environment variable LOCALDOMAIN. res_ninit() or res_init() is normally executed by the first call to one of the other functions.</span><br></pre></td></tr></table></figure><p>解决方法:</p><ol><li>用户进程直接调用底层的接口，并且定期调用 res_init() 以防止 /etc/resolov.conf 文件被修改而无法感知(有一定的实现成本)。</li><li>直接重启用户进程，使用户进程在做第一次域名解析的时候触发 res_init()</li><li>用户进程实现 DNS 的 client 全部功能</li><li>通过非常规手段修改用户进程空间的数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rtmp_specification_1.0</title>
      <link href="/2019/01/27/%E6%B5%81%E5%AA%92%E4%BD%93/rtmp-specification-1-0/"/>
      <url>/2019/01/27/%E6%B5%81%E5%AA%92%E4%BD%93/rtmp-specification-1-0/</url>
      
        <content type="html"><![CDATA[<p>//<a href="https://www.cnblogs.com/Kingfans/p/7083100.html" target="_blank" rel="noopener">https://www.cnblogs.com/Kingfans/p/7083100.html</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Adobe 公司的实时消息传输协议 (RTMP) 通过一个可靠地流传输提供了一个双向多通道消息服务，比如 TCP [RFC0793]，意图在通信端之间传递带有时间信息的视频、音频和数据消息流。实现通常对不同类型的消息分配不同的优先级，当运载能力有限时，这会影响等待流传输的消息的次序。本文档将对实时流传输协议 (Real Time Messaging Protocol) 的语法和操作进行描述。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul><li>Payload(有效载荷): 包含于一个数据包中的数据，例如音频采样或者压缩的视频数据</li><li>Package(数据包): 一个数据包由一个固定头和有效载荷数据构成。一些个底层协议可能会要求对数据包定义封装。</li><li>Port (端口):”传输协议用以区分开指定一台主机的不同目的地的一个抽象。TCP/IP 使用小的正整数对端口进行标识。” OSI 传输层使用的运输选择器 (TSEL) 相当于端口</li><li>Transport address (传输地址): 用以识别传输层端点的网络地址和端口的组合，例如一个 IP 地址和一个 TCP 端口。数据包由一个源传输地址传送到一个目的传输地址。</li><li>Message stream (消息流): 通信中消息流通的一个逻辑通道。</li><li>Message stream ID (消息流 ID)：每个消息有一个关联的 ID，使用 ID 可以识别出流通中的消息流<br>Multiplexing (合成)：将独立的音频/视频数据合成为一个连续的音频/视频流的加工，这样可以同时发送几个视频和音频。</li><li>DeMultiplexing (分解): Multiplexing 的逆向处理，将交叉的音频和视频数据还原成原始音频和视频数据的格式。</li><li>Remote Procedure Call (RPC 远程方法调用): 允许客户端或服务器调用对端的一个子程序或者程序的请求。</li><li>Metadata (元数据): 关于数据的一个描述。一个电影的 metadata 包括电影标题、持续时间、创建时间等等。</li><li>Application Instance (应用实例): 服务器上应用的实例，客户端可以连接这个实例并发送连接请求。</li><li>Action Message Format (AMF 动作消息格式协议): 一个用于序列化 ActionScript 对象图的紧凑的二进制格式。AMF 有两个版本：AMF 0 [AMF0] 和 AMF 3 [AMF3]。</li></ul><h1 id="字节序、对齐和时间格式"><a href="#字节序、对齐和时间格式" class="headerlink" title="字节序、对齐和时间格式"></a>字节序、对齐和时间格式</h1><p>所有整数型属性以网络字节顺序传输，字节 0 代表第一个字节，零位是一个单词或字段最常用的有效位。字节序通常是大端排序。关于传输顺序的更多细节描述参考 IP 协议[RFC0791]</p><p>RTMP 中的所有数据都是字节对准的；例如，一个十六位的属性可能会在一个奇字节偏移上。填充后，填充字节应该有零值。</p><p>RTMP 中的 Timestamps 以一个整数形式给出，表示一个未指明的时间点。典型地，每个流会以一个为 0 的 timestamp 起始，但这不是必须的，只要双端能够就时间点达成一致。注意这意味着任意不同流 (尤其是来自不同主机的) 的同步需要 RTMP 之外的机制。</p><p>因为 timestamp 的长度为 32 位，每隔 49 天 17 小时 2 分钟和 47.296 秒就要重来一次。因为允许流连续传输，有可能要多年，RTMP 应用在处理 timestamp 时应该使用序列码算法 [RFC1982]，并且能够处理无限循环。例如，一个应用假定所有相邻的 timestamp 都在 2^31 - 1 毫秒之内，因此 10000 在 4000000000 之后，而 3000000000 在 4000000000 之前。</p><p>timestamp 也可以使用无符整数定义，相对于前面的 timestamp。timestamp 的长度可能会是 24 位或者 32 位。</p><h1 id="RTMP块流"><a href="#RTMP块流" class="headerlink" title="RTMP块流"></a>RTMP块流</h1><p>实时消息传输协议的块流 (RTMP 块流)。 它为上层多媒体流协议提供合并和打包的服务。</p><p>RTMP使用实时消息传输协议时，它可以处理任何发送消息流的协议。每个消息包含timestamp和payload类型标识，RTMP 块流和 RTMP 一起适合各种音频-视频应用，从一对一和一对多直播到点播服务，到互动会议应用。</p><p>当使用可靠传输协议时，比如 TCP [RFC0793]，RTMP 块流能够对于多流提供所有消息可靠的 timestamp 有序端对端传输。RTMP 块流并不提供任何优先权或类似形式的控制，但是可以被上层协议用来提供这种优先级。例如，一个直播视频服务器可能会基于发送时间或者每个消息的确认时间丢弃一个传输缓慢的客户端的视频消息以确保及时获取其音频消息。</p><p>RTMP 块流包括其自身的带内协议控制信息，并且提供机制为上层协议植入用户控制消息。</p><h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>可以被分割为块以支持组合的消息的格式取决于上层协议。消息格式必须包含以下创建块所需的字段</p><ul><li>Timestamp: message timestamp, 4Byte</li><li>Length: 消息的有效负载长度。如果不能省略掉消息头，那它也被包括进这个长度。这个字段占用了块头的三个字节。</li><li>Type Id：一些类型 ID 保留给协议控制消息使用。这些传播信息的消息由 RTMP 块流协议和上层协议共同处理。其他的所有类型 ID 可用于上层协议，它们被 RTMP 块流处理为不透明值。事实上，RTMP 块流中没有任何地方要把这些值当做类型使用；所有消息必须是同一类型，或者应用使用这一字段来区分同步跟踪，而不是类型。这一字段占用了块头的一个字节</li><li>Message Stream ID：message stream (消息流) ID 可以使任意值。合并到同一个块流的不同的消息流是根据各自的消息流 ID 进行分解。除此之外，对 RTMP 块流而言，这是一个不透明的值。这个字段以小端格式占用了块头的四个字节</li></ul><h2 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h2><p>一个 RTMP 连接以握手开始。RTMP 的握手不同于其他协议；RTMP 握手由三个固定长度的块组成，而不是像其他协议一样的带有报头的可变长度的块。</p><p>客户端 (发起连接请求的终端) 和服务器端各自发送相同的三块。便于演示，当发送自客户端时这些块被指定为 C0、C1 和 C2；当发送自服务器端时这些块分别被指定为 S0、S1 和 S2</p><h3 id="握手顺序"><a href="#握手顺序" class="headerlink" title="握手顺序"></a>握手顺序</h3><ul><li>握手以客户端发送C0和C1开始</li><li>客户端必须等到S1才能发送C2</li><li>客户端必须受到S2才能发送任何其他数据</li><li>服务端必须等待接收到C0才能发送S0、S1，也可以等待接收到C1再发送S0和S1.服务器端必须等待接收到 C1 才能发送 S2。服务器端必须等待接收到 C2 才能发送任何其他数据。</li></ul><h3 id="C0和S0的格式"><a href="#C0和S0的格式" class="headerlink" title="C0和S0的格式"></a>C0和S0的格式</h3><p>C0 和 S0 包都是一个单一的八位字节，以一个单独的八位整型域进行处理：</p><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C0_S0.png" alt=""></p><ul><li>version: 本文档中规范的版本号为 3。0、1、2 三个值是由早期其他产品使用的，是废弃值；4 - 31 被保留为 RTMP 协议的未来实现版本使用；32 - 255 不允许使用 (以区分开 RTMP 和其他常以一个可打印字符开始的文本协议)。无法识别客户端所请求版本号的服务器应该以版本 3 响应，(收到响应的) 客户端可以选择降低到版本 3，或者放弃握手。</li></ul><h3 id="C1和S1的格式"><a href="#C1和S1的格式" class="headerlink" title="C1和S1的格式"></a>C1和S1的格式</h3><p>C1 和 S1 数据包的长度都是 1536 字节，包含以下字段：</p><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C1_S1.png" alt=""></p><ul><li>time:包含一个timestamp,用于本终端发送的所有后续块的时间起点。这个值可以是 0，或者一些任意值。要同步多个块流，终端可以发送其他块流当前的 timestamp 的值</li><li>zero:must be 0</li><li>random data(1528 Byte): 这个字段可以包含任意值。终端需要区分出响应来自它发起的握手还是对端发起的握手，这个数据应该发送一些足够随机的数。这个不需要对随机数进行加密保护，也不需要动态值</li></ul><h3 id="C2和S2的格式"><a href="#C2和S2的格式" class="headerlink" title="C2和S2的格式"></a>C2和S2的格式</h3><p>C2 和 S2 数据包长度都是 1536 字节，包含有以下字段：<br><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C2_S2.png" alt=""></p><ul><li><p>time (四个字节)：这个字段必须包含终端在 S1 (给 C2) 或者 C1 (给 S2) 发的 timestamp。</p></li><li><p>time2 (四个字节)：这个字段必须包含终端先前发出数据包 (s1 或者 c1) timestamp。</p></li><li><p>random echo (1528 个字节)：这个字段必须包含终端发的 S1 (给 C2) 或者 S2 (给 C1) 的随机数。两端都可以一起使用 time 和 time2 字段再加当前 timestamp 以快速估算带宽和/或者连接延迟</p></li></ul><h3 id="握手示意图"><a href="#握手示意图" class="headerlink" title="握手示意图"></a>握手示意图</h3><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/hangshark.png" alt=""></p><ul><li>Uninitalized(未初始化)：协议的版本号在这个阶段被发送。客户端和服务器都是 uninitialized (未初始化) 状态。之后客户端在数据包 C0 中将协议版本号发出。如果服务器支持这个版本，它将在回应中发送 S0 和 S1。如果不支持呢，服务器会才去适当的行为进行响应。在 RTMP 协议中，这个行为就是终止连接。</li><li>Version Send(版本已发送): 在未初始化状态之后，客户端和服务器都进入 Version Sent (版本已发送) 状态。客户端会等待接收数据包 S1 而服务器在等待 C1。一旦拿到期待的包，客户端会发送数据包 C2 而服务器发送数据包 S2。(客户端和服务器各自的)状态随即变为 Ack Sent (确认已发送)</li><li>Ack Sent(确认)：客户端和服务器分别等待 S2 和 C2。</li><li>Handshake Done(握手结束)：客户端和服务器可以开始交换消息了。</li></ul><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>握手之后，连接开始对一个或多个块流进行合并。创建的每个块都有一个唯一ID对其进行关联。这个ID为chunk stream ID,这些块通过网络进行传输。传递时，每个块必须被完全发送才可以发送下一块。在接收端，这些块被根据块流 ID 被组装成消息。</p><p>分块允许上层协议将大的消息分解为更小的消息，例如，防止体积大的但优先级小的消息 (比如视频) 阻碍体积较小但优先级高的消息 (比如音频或者控制命令)。</p><p>分块也让我们能够使用较小开销发送小消息，因为块头包含包含在消息内部的信息压缩提示。</p><p>块的大小是可以配置的。它可以使用一个设置块大小的控制消息进行设置 (参考 5.4.1)。更大的块大小可以降低 CPU 开销，但在低带宽连接时因为它的大量的写入也会延迟其他内容的传递。更小的块不利于高比特率的流化。所以块的大小设置取决于具体情况。</p><h3 id="块格式"><a href="#块格式" class="headerlink" title="块格式"></a>块格式</h3><p>每个块包含一个头和数据体，块头包含三个部分</p><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_header.png" alt=""></p><ul><li>Basic Header(1-3Byte):这个字段对块流ID和块类型进行编码。块类型决定了消息头的编码格式，长度完全取决于块流 ID，因为块流 ID 是一个可变长度的字段</li><li>Message Header(0,3,7或者11个字节):这一字段对正在发送的消息 (不管是整个消息，还是只是一小部分) 的信息进行编码。这一字段的长度可以使用块头中定义的块类型进行决定</li><li>Extended Timestamp (扩展 timestamp，0 或 4 字节)：这一字段是否出现取决于块消息头中的 timestamp 或者 timestamp delta 字段</li><li>ChunkData(有效大小): 当前块的有效负载，相当于定义的最大块大小</li></ul><h4 id="块基本头"><a href="#块基本头" class="headerlink" title="块基本头"></a>块基本头</h4><p>块基本头对块流ID和块类型进行编码，字段可能或者有1,2或者3，取决于块流ID</p><p>一个RTMP实现应该使用能够容纳这个ID的最小容量进行表示</p><p>RTMP 协议最多支持 65597 个流，流 ID 范围 3 - 65599。ID 0、1、2 被保留。0 值表示二字节形式，并且 ID 范围 64 - 319 (第二个字节 + 64)。1 值表示三字节形式，并且 ID 范围为 64 - 65599 ((第三个字节) * 256 + 第二个字节 + 64)。3 - 63 范围内的值表示整个流 ID。带有 2 值的块流 ID 被保留，用于下层协议控制消息和命令。</p><p>块基本头中的 0 - 5 位 (最低有效) 代表块流 ID。<br>块流 ID 2 - 63 可以编进这一字段的一字节版本中。</p><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header1.jpg" alt=""></p><p>块流 ID 64 - 319 可以以二字节的形式编码在头中。ID 计算为 (第二个字节 + 64)</p><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header2.jpg" alt=""></p><p>块流 ID 64 - 65599 可以编码在这个字段的三字节版本中。ID 计算为 ((第三个字节) * 256 + (第二个字节) + 64)。</p><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header3.jpg" alt=""></p><ul><li>cs id (六位)：这一字段包含有块流 ID，值的范围是 2 - 63。值 0 和 1 用于指示这一字段是 2- 或者 3- 字节版本。</li><li>fmt (两个字节)：这一字段指示 ‘chunk message header’ 使用的四种格式之一。没中块类型的 ‘chunk message header’ 会在下一小节解释</li><li>cs id - 64 (8 或者 16 位)：这一字段包含了块流 ID 减掉 64 后的值。例如，ID 365 在 cs id 中会以一个 1 进行表示，和这里的一个 16 位 的 301 (cs id - 64)。</li><li>块流 ID 64 - 319 可以使用 2-byte 或者 3-byte 的形式在头中表示。</li></ul><h4 id="块消息头"><a href="#块消息头" class="headerlink" title="块消息头"></a>块消息头</h4><p>块消息头又四种不同的格式，由块基本头中的 “fmt” 字段进行选择。</p><p>一个 (RTMP) 实现应该为每个块消息头使用最紧凑的表示。</p><ul><li>type0</li></ul><p>类型0块头的长度为11字节，这已类型必须用在块流的起始位置，每当流回退的时候，例如充值<br><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type0.jpg" alt=""></p><p>timestamp(三个字节): 对于type-0块，当前消息的绝对timestamp在这边发送. 如果 timestamp 大于或者等于 16777215 (十六进制 0xFFFFFF)，这一字段必须是 16777215，表明有扩展 timestamp 字段来补充完整的 32 位 timestamp。否则的话，这一字段必须是整个的 timestamp。</p><p>-type1</p><p>类型 1 块头长为 7 个字节。不包含消息流 ID；这一块使用前一块一样的流 ID。可变长度消息的流 (例如，一些视频格式) 应该在第一块之后使用这一格式表示之后的每个新消息</p><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type1.jpg" alt=""></p><ul><li>type2 </li></ul><p>类型 2 块头长度为 3 个字节。既不包含流 ID 也不包含消息长度；这一块具有和前一块相同的流 ID 和消息长度。具有不变长度的消息 (例如，一些音频和数据格式) 应该在第一块之后使用这一格式表示之后的每个新消息。</p><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type2.jpg" alt=""></p><ul><li>type3</li></ul>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx_rtmp</title>
      <link href="/2019/01/23/%E6%B5%81%E5%AA%92%E4%BD%93/nginx-rtmp/"/>
      <url>/2019/01/23/%E6%B5%81%E5%AA%92%E4%BD%93/nginx-rtmp/</url>
      
        <content type="html"><![CDATA[<ul><li>git clone <a href="https://github.com/arut/nginx-rtmp-module.git" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module.git</a> </li><li>wget <a href="http://nginx.org/download/nginx-1.15.8.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.15.8.tar.gz</a></li><li>./configure –prefix=/usr/local/nginx  –add-module=../nginx-rtmp-module  –with-http_ssl_module    </li><li>nginx.conf <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    location /stat &#123;</span><br><span class="line">            rtmp_stat all;</span><br><span class="line">            rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">    &#125;</span><br><span class="line">    location /stat.xsl &#123;</span><br><span class="line">        root /home/cuijian/do/package/nginx-rtmp-module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp &#123;                #RTMP服务</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;  #//服务端口</span><br><span class="line">        chunk_size 4096;   #//数据传输块的大小</span><br><span class="line"></span><br><span class="line">        application live &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>ffmpeg -threads 2 -re -fflags +genpts -stream_loop -1 -i test.264   -c:v copy -c:a aac -f flv rtmp://127.0.0.1:1935/live/test264</p><p>RTMP推流数据包</p><p><img src="/2019/01/23/流媒体/nginx-rtmp/rtmp_publish.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用户态和内核态</title>
      <link href="/2019/01/07/linux/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"/>
      <url>/2019/01/07/linux/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="用户态及内核态介绍"><a href="#用户态及内核态介绍" class="headerlink" title="用户态及内核态介绍"></a>用户态及内核态介绍</h1><p><img src="/2019/01/07/linux/用户态和内核态/Unix_Linux的体系架构.png" alt=""></p><p>从宏观上来看，Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。<em>内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境</em>。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p><p>系统调用是操作系统的最小功能单位，这些系统调用根据不同的应用场景可以进行扩展和裁剪，现在各种版本的Unix实现都提供了不同数量的系统调用，如Linux的不同版本提供了240-260个系统调用，FreeBSD大约提供了320个（reference：UNIX环境高级编程）。我们可以把系统调用看成是一种不能再化简的操作（类似于原子操作，但是不同概念），有人把它比作一个汉字的一个“笔画”，而一个“汉字”就代表一个上层应用，我觉得这个比喻非常贴切。因此，有时候如果要实现一个完整的汉字（给某个变量分配内存空间），就必须调用很多的系统调用。如果从实现者（程序员）的角度来看，这势必会加重程序员的负担，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。库函数正是为了将程序员从复杂的细节中解脱出来而提出的一种有效方法。它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”。这样的一种组成方式极大增强了程序设计的灵活性，对于简单的操作，我们可以直接调用系统调用来访问资源，如“人”，对于复杂操作，我们借助于库函数来实现，如“仁”。显然，这样的库函数依据不同的标准也可以有不同的实现版本，如ISO C 标准库，POSIX标准库等。</p><p>　　Shell是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p><p>总结一下，用户态的应用程序可以通过三种方式来访问内核态的资源：<br>1) 系统调用<br>2) 库函数<br>3) Shell脚本</p><ul><li>向下控制硬件资源</li><li>向内管理操作系统资源<ul><li>进程的调度和管理</li><li>内存的管理</li><li>文件系统的管理</li><li>设备驱动</li><li>网络资源的管理</li></ul></li><li>向上则向应用程序提供系统调用的接口</li></ul><p>整个操作系统分为两层：用户态和内核态，这种分层的架构极大地提高了资源管理的可扩展性和灵活性，而且方便用户对资源的调用和集中式的管理，带来一定的安全性</p><p><img src="/2019/01/07/linux/用户态和内核态/kernal_framework.jpg" alt=""></p><h1 id="用户态及内核态的切换"><a href="#用户态及内核态的切换" class="headerlink" title="用户态及内核态的切换"></a>用户态及内核态的切换</h1><p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。</p><p><img src="/2019/01/07/linux/用户态和内核态/mode_change.gif" alt=""></p><p>从用户态到内核态的切换:</p><ol><li>系统调用</li><li>异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li><li>外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li></ol><p>系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">Linux探秘之用户态与内核态</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指针数组和数组指针</title>
      <link href="/2019/01/07/other/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/"/>
      <url>/2019/01/07/other/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><ul><li>int (*p)[n], 其中()优先级高于[]，故p是一个指针， 指向一维的数组，数组长度是n,p的步长也是n,也就是说执行p+1时，p要跨过n个整型数据的长度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如要将二维数组赋给一指针，应这样赋值：</span><br><span class="line">int a[3][4];</span><br><span class="line">int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。</span><br><span class="line"> p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span><br><span class="line"> p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span><br></pre></td></tr></table></figure><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><ul><li>int <em>p[n];[]优先级高于</em>，故先于p组成数组， int*说明是整形指针数组它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素</li></ul><h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><ul><li>指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。</li><li>数组指针：首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4 个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。</li></ul><p><img src="/2019/01/07/other/指针数组和数组指针/指针数组和数组指针-内存表示.jpg" alt=""><br><img src="/2019/01/07/other/指针数组和数组指针/指针数组和数组指针-内存表示2.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数指针和指针函数</title>
      <link href="/2019/01/07/other/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/"/>
      <url>/2019/01/07/other/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h1><p>返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。 </p><p>声明格式为：类型标识符 *函数名(参数表)</p><p>例如:<br>int *fun(int x,int y);</p><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p><p>声明格式：类型说明符 (*函数名) (参数) </p><p>int (*fun)(int x,int y);</p><p>函数指针是需要把一个函数的地址赋值给它，有两种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure></p><p>调用函数指针的方式也有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure></p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="定义不同"><a href="#定义不同" class="headerlink" title="定义不同"></a>定义不同</h2><ul><li>指针函数本质是一个函数，其返回值为指针。 </li><li>函数指针本质是一个指针，其指向一个函数。</li></ul><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><ul><li>指针函数：int* fun(int x,int y); </li><li>函数指针：int (*fun)(int x,int y); </li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>live555分析-startStream</title>
      <link href="/2019/01/05/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-startStream/"/>
      <url>/2019/01/05/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-startStream/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mount</title>
      <link href="/2019/01/04/linux/mount/"/>
      <url>/2019/01/04/linux/mount/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="peer-group"><a href="#peer-group" class="headerlink" title="peer group"></a>peer group</h2><p>peer group就是一个或多个挂载点的集合，他们之间可以共享挂载信息。目前在下面两种情况下会使两个挂载点属于同一个peer group（前提条件是挂载点的propagation type是shared）</p><ul><li><p>利用mount –bind命令，将会使源和目的挂载点属于同一个peer group，当然前提条件是‘源’必须要是一个挂载点。</p></li><li><p>当创建新的mount namespace时，新namespace会拷贝一份老namespace的挂载点信息，于是新的和老的namespace里面的相同挂载点就会属于同一个peer group</p></li></ul><h2 id="propagation-type"><a href="#propagation-type" class="headerlink" title="propagation type"></a>propagation type</h2><p>每个挂载点都有一个propagation type标志, 由它来决定当一个挂载点的下面创建和移除挂载点的时候，是否会传播到属于相同peer group的其他挂载点下去，也即同一个peer group里的其他的挂载点下面是不是也会创建和移除相应的挂载点.现在有4种不同类型的propagation type：</p><ul><li><p>MS_SHARED: 从名字就可以看出，挂载信息会在同一个peer group的不同挂载点之间共享传播. 当一个挂载点下面添加或者删除挂载点的时候，同一个peer group里的其他挂载点下面也会挂载和卸载同样的挂载点</p></li><li><p>MS_PRIVATE: 跟上面的刚好相反，挂载信息根本就不共享，也即private的挂载点不会属于任何peer group</p></li><li><p>MS_SLAVE: 跟名字一样，信息的传播是单向的，在同一个peer group里面，master的挂载点下面发生变化的时候，slave的挂载点下面也跟着变化，但反之则不然，slave下发生变化的时候不会通知master，master不会发生变化。</p></li><li><p>MS_UNBINDABLE: 这个和MS_PRIVATE相同，只是这种类型的挂载点不能作为bind mount的源，主要用来防止递归嵌套情况的出现</p></li></ul><p>最近做自包含就由这个问题， 当把根目录下/dev /sys使用mount –rbind 到当前目录下， 卸载目录时出现Device Busy， 发现系统进程占用了当前挂载点下/sys …, 导致目录一直被占用</p><p>解决方法</p><ul><li>使用umount -l ,  lazy可卸载当前挂载点, 但加上-l选项时出现/usr/…/cgroup也被卸载了…；原因如下，原先mount默认使用MS_SHARED，umount -l 挂载点会将挂载点下所有的挂载节点清除， 而；原因如下，原先mount默认使用MS_SHARED 则会共享挂载信息， 导致根目录下系节点也被卸载， mount 加上–make-slave时解决。猜测加上MS_SLAVE时， 源目录挂载消息可以通过内核消息传递给挂载点， 而SLAVE挂载点挂载信息则会被内核屏蔽。故虚拟化环境应当推荐使用MS_SLAVE</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-l, --lazy</span><br><span class="line">             Lazy unmount.  Detach the filesystem from the file hierarchy</span><br><span class="line">             now, and clean up all references to this filesystem as soon as</span><br><span class="line">             it is not busy anymore.</span><br><span class="line"></span><br><span class="line">             A system reboot would be expected in near future if you&apos;re</span><br><span class="line">             going to use this option for network filesystem or local</span><br><span class="line">             filesystem with submounts.  The recommended use-case for</span><br><span class="line">             umount -l is to prevent hangs on shutdown due to an</span><br><span class="line">             unreachable network share where a normal umount will hang due</span><br><span class="line">             to a downed server or a network partition. Remounts of the</span><br><span class="line">             share will not be possible.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>h264分析</title>
      <link href="/2018/12/27/%E6%B5%81%E5%AA%92%E4%BD%93/H264/h264%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/27/%E6%B5%81%E5%AA%92%E4%BD%93/H264/h264%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="IBP帧"><a href="#IBP帧" class="headerlink" title="IBP帧"></a>IBP帧</h2><p><strong>I:关键帧</strong><br>一帧画面的完整保留，解码时只需本帧解码即可</p><ul><li>全帧压缩编码真能，将全帧图像信息进行JPEG压缩编码及传输</li><li>解码仅用I帧即可重构完整图像</li><li>描述了图像背景和运动主体详情</li><li>I帧不需参考其他画面生成</li><li>是P帧和B帧的草考帧</li><li>是帧组GOP的基础帧(第一帧),在一组中只有一个I帧</li><li>I帧不需考虑运动矢量</li><li>I帧所占的数据信息量较大</li></ul><p><strong>P：前向预测编码帧</strong><br>表示此帧和上一I帧的差别，解码时需要用之前缓存的图像叠加上本帧定义的差别，生成最终画面</p><ul><li>I帧后相隔1~2帧的编码帧</li><li>采用运动补偿的方法传送它与前面的I帧或者P帧的差值及运动矢量</li><li>解码必须将I帧中的预测值与预测误差求和才能重构完整的P帧图像</li><li>P帧属于前向预测的帧建编码，只参考其前后的B帧的参考帧</li><li>P是参考帧，可能造成解码错误的扩散</li><li>差值传送，压缩比较高</li></ul><p><strong>B: 预测与重构</strong><br>以前面的I或P和后面的P帧作为参考，找出B帧某点的预测值和两个运动矢量，并取预测差值和运动矢量传送。</p><ul><li>B帧由前面的I、P帧或者后面的P帧来进行预测的</li><li>传送的是它与前面的I或者P帧和后面的P帧之间的预测误差及运动矢量</li><li>双向预测编码帧</li><li>压缩比最高，只反映参考帧间运动主题的变化情况</li><li>非参考帧， 不会造成编码错误扩散</li></ul><h2 id="压缩方法"><a href="#压缩方法" class="headerlink" title="压缩方法"></a>压缩方法</h2><ol><li>分组: 将几帧分为一组(GOP,一个序列),为防止运动变化，帧数不宜取多</li><li>定义帧: 将每组内各帧图像定义为三种类型,I、B、P帧帧</li><li>预测帧: 以I帧为基础帧，以I帧预测P帧，再由I、P帧预测B帧</li><li>数据传输: 以最后的I帧和预测的差值信息进行存储和传输</li></ol><p><strong>帧内压缩</strong>也为空间压缩，当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻相邻帧之间的冗余信息，实际和静态图像压缩相似，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示</p><p><strong>帧间压缩</strong>,相邻几帧数据有较大的相关性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比，通过比较本帧和相邻帧之间的差异，仅记录本帧和其他相邻帧之间的差值，可以大大减少数据量</p><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><p>在每个图像中，若干个宏块(一个编码图像被分为若干个16X16 Y、8 X 8 Cb、 8 X 8 Cr)被排列成片(I、B、P或者其他片)的形式。</p><p>I片包含I宏块、P片可包含P和I宏块而B片可包含B和I宏块</p><p>P宏块使用前面已编码图像作为参考图像进行帧内预测</p><p>B宏块使用双向的参考图像进行帧内预测</p><p><strong>H264</strong>结构中，一个视频图像编码厚度额数据叫做一帧，由多个片(slice)组成，一个片由一个或者多个块(MB)组成，宏块作为H264编码的基本单位</p><ul><li>SODB 数据比特串-&gt; 最原始的编码数据(VCL)</li><li>RBSP 原始字节序列载荷-&gt; 在SODB后加结尾比特（一个bit’1’，若干比特’0’字节对齐)</li><li>EBSP 拓展字节序列载荷-&gt; 在RBSP后加上仿校验字节0x03（在NALU加到Annexb上时，需在每组NALU前加StartCodePrefix,如果该NALU对应的slice为一帧的开始则用4字节标示，0x00 00 00 01，否则三字节0x00 00 01）。为了使NALU主体重不与开始吗冲突时，每遇到两字节连续为0，则插入一个字节的0x03,解码时将0x03去掉</li></ul><table><thead><tr><th>-</th><th>- </th></tr></thead><tbody><tr><td>VCL（video coding layer)</td><td>视频编码层，对应核心算法引擎，块宏及片语法级别的敌营，最终输出编码完的数据SODB</td></tr><tr><td>NAL (network abstraction layer)</td><td>网络提取层，定义片及以上语法级别，独立片解码，起始码唯一保证，SEI及流格式编码数据传送，NAL层将SODB打包成RBSP然后加上NAL头， 组成一个NALU</td></tr></tbody></table><h3 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h3><pre><code>--------------------------------------------------------|NAL header | RBSP |NAL header | RBSP |NAL header | RBSP | ...-------------------------------------------------------- </code></pre><p>其中NAL header（1byte)</p><pre><code>|forbidden_bit(1bit)|nal_reference_bit(2bit)|nal_unit_type(5bit)|</code></pre><ul><li>forbiddent_bit: 禁止位，初始为0,当网络发现NAL单元有比特错误时可设置该比特为1，以便接收方纠错或丢掉该单元。</li><li>nal_reference_bit：nal重要性指示，标志该NAL单元的重要性，值越大，越重要，解码器在解码处理不过来的时候，可以丢掉重要性为0的NALU</li><li>nal_unit_type:</li></ul><table><thead><tr><th>nal_unit_type</th><th>type</th><th>nal_reference_bit</th></tr></thead><tbody><tr><td>0</td><td>未使用</td><td>0</td></tr><tr><td>1</td><td>非IDR的片</td><td>此片属于参考帧，则不等于0不属于参考帧，则等与0</td></tr><tr><td>2</td><td>片数据A分区</td><td>同上</td></tr><tr><td>3</td><td>片数据B分区</td><td>同上</td></tr><tr><td>4</td><td>片数据C分区</td><td>同上</td></tr><tr><td>5</td><td>IDR图像的片</td><td>5</td></tr><tr><td>6</td><td>补充增强信息单元（SEI）</td><td>0</td></tr><tr><td>7</td><td>序列参数集</td><td>非0</td></tr><tr><td>8</td><td>图像参数集</td><td>非0</td></tr><tr><td>9</td><td>分界符</td><td>0</td></tr><tr><td>10</td><td>序列结束</td><td>0</td></tr><tr><td>11</td><td>码流结束</td><td>0</td></tr><tr><td>12</td><td>填充</td><td>0</td></tr><tr><td>13..23</td><td>保留</td><td>0</td></tr><tr><td>24..31</td><td>不保留</td><td>0</td></tr></tbody></table><h3 id="RBSP"><a href="#RBSP" class="headerlink" title="RBSP"></a>RBSP</h3><p>RBSP数据是下表中的一种</p><table><thead><tr><th>RBSP类型</th><th>所写</th><th>描述</th></tr></thead><tbody><tr><td>参数集</td><td>PS</td><td>序列的全局信息，如图像尺寸，视频格式等</td></tr><tr><td>增强信息</td><td>SEI</td><td>视频序列解码的增强信息</td></tr><tr><td>图像界定符</td><td>PD</td><td>视频图像的边界</td></tr><tr><td>编码片</td><td>SLICE</td><td>编码片的头信息和数据</td></tr><tr><td>数据分割</td><td>DP</td><td>片层的数据，用于错误恢复解码</td></tr><tr><td>序列结束符</td><td></td><td>表明一个序列的结束，下一个图像为IDR图像</td></tr><tr><td>流结束符</td><td></td><td>表明该流中已没有图像</td></tr><tr><td>填充数据</td><td></td><td>亚元数据，用于填充字节</td></tr></tbody></table><p>参数集:包括序列参数集 SPS  和图像参数集 PPS</p><p><strong>SPS</strong> 包含的是针对一连续编码视频序列的参数，如标识符<br>seq_parameter_set_id、帧数及 POC 的约束、参考帧数目、解码图像尺寸和帧场编码模式选择标识等等。</p><p><strong>PPS</strong>对应的是一个序列中某一幅图像或者某几幅图像，<br>其参数如标识符 pic_parameter_set_id、可选的 seq_parameter_set_id、熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系数调整标识等等。</p><p>数据分割：组成片的编码数据存放在 3 个独立的 DP（数据分割，A、B、C）中，各自包含一个编码片的子集。</p><p>分割Ａ包含片头和片中每个宏块头数据。</p><p>分割Ｂ包含帧内和 SI 片宏块的编码残差数据。</p><p>分割 C包含帧间宏块的编码残差数据。</p><p>每个分割可放在独立的 NAL 单元并独立传输。</p><h3 id="NAL的开始和结束"><a href="#NAL的开始和结束" class="headerlink" title="NAL的开始和结束"></a>NAL的开始和结束</h3><p>编码器将每个NAL各自独立、完整地放入一个分组，因为分组都有头部，解码器可以方便地检测出NAL的分界，并依次取出NAL进行解码。<br>每个NAL前有一个起始码 0x00 00 01（或者0x00 00 00 01），解码器检测每个起始码，作为一个NAL的起始标识，当检测到下一个起始码时，当前NAL结束。</p><p>同时H.264规定，当检测到0x000000时，也可以表征当前NAL的结束。那么NAL中数据出现0x000001或0x000000时怎么办？H.264引入了防止竞争机制，如果编码器检测到NAL数据存在0x000001或0x000000时，编码器会在最后个字节前插入一个新的字节0x03，这样：</p><p>0x000000－&gt;0x00000300<br>0x000001－&gt;0x00000301<br>0x000002－&gt;0x00000302<br>0x000003－&gt;0x00000303<br>解码器检测到0x000003时，把03抛弃，恢复原始数据（脱壳操作）。解码器在解码时，首先逐个字节读取NAL的数据，统计NAL的长度，然后再开始解码。</p><h3 id="NALU的顺序要求"><a href="#NALU的顺序要求" class="headerlink" title="NALU的顺序要求"></a>NALU的顺序要求</h3><ol><li><p>序列参数集NAL单元<br>必须在传送所有以此参数集为参考的其他NAL单元之前传送，不过允许这些NAL单元中间出现重复的序列参数集NAL单元。<br>所谓重复的详细解释为：序列参数集NAL单元都有其专门的标识，如果两个序列参数集NAL单元的标识相同，就可以认为后一个只不过是前一个的拷贝，而非新的序列参数集</p></li><li><p>图像参数集NAL单元<br>必须在所有以此参数集为参考的其他NAL单元之前传送，不过允许这些NAL单元中间出现重复的图像参数集NAL单元，这一点与上述的序列参数集NAL单元是相同的</p></li><li><p>不同基本编码图像中的片段（slice）单元和数据划分片段（data partition）单元在顺序上不可以相互交叉，即不允许属于某一基本编码图像的一系列片段（slice）单元和数据划分片段（data partition）单元中忽然出现另一个基本编码图像的片段（slice）单元片段和数据划分片段（data partition）单元。</p></li><li><p>参考图像的影响：如果一幅图像以另一幅图像为参考，则属于前者的所有片段（slice）单元和数据划分片段（data partition）单元必须在属于后者的片段和数据划分片段之后，无论是基本编码图像还是冗余编码图像都必须遵守这个规则。</p></li><li><p>基本编码图像的所有片段（slice）单元和数据划分片段（data partition）单元必须在属于相应冗余编码图像的片段（slice）单元和数据划分片段（data partition）单元之前。</p></li><li><p>如果数据流中出现了连续的无参考基本编码图像，则图像序号小的在前面。</p></li><li><p>如果arbitrary_slice_order_allowed_flag置为1，一个基本编码图像中的片段（slice）单元和数据划分片段（data partition）单元的顺序是任意的，如果arbitrary_slice_order_allowed_flag置为零，则要按照片段中第一个宏块的位置来确定片段的顺序，若使用数据划分，则A类数据划分片段在B类数据划分片段之前，B类数据划分片段在C类数据划分片段之前，而且对应不同片段的数据划分片段不能相互交叉，也不能与没有数据划分的片段相互交叉。</p></li><li><p>如果存在SEI（补充增强信息）单元的话，它必须在它所对应的基本编码图像的片段（slice）单元和数据划分片段（data partition）单元之前，并同时必须紧接在上一个基本编码图像的所有片段（slice）单元和数据划分片段（data partition）单元后边。假如SEI属于多个基本编码图像，其顺序仅以第一个基本编码图像为参照。</p></li><li><p>如果存在图像分割符的话，它必须在所有SEI 单元、基本编码图像的所有片段slice）单元和数据划分片段（data partition）单元之前，并且紧接着上一个基本编码图像那些NAL单元。</p></li><li><p>如果存在序列结束符，且序列结束符后还有图像，则该图像必须是IDR（即时解码器刷新）图像。序列结束符的位置应当在属于这个IDR图像的分割符、SEI 单元等数据之前，且紧接着前面那些图像的NAL单元。如果序列结束符后没有图像了，那么它的就在比特流中所有图像数据之后。</p></li><li><p>流结束符在比特流中的最后</p></li></ol><h3 id="H264元素分层结构"><a href="#H264元素分层结构" class="headerlink" title="H264元素分层结构"></a>H264元素分层结构</h3><p>H.264编码器输出的Bit流中，每个Bit都隶属于某个句法元素。句法元素被组织成有层次的结构，分别描述各个层次的信息。<br><img src="/2018/12/27/流媒体/H264/h264分析/h264_bits.gif" alt=""></p><p>句法元素被组织成序列、图像、片、宏块和子宏块5个层次，这样的结构中，每一层的头部和它的数据部分形成管理与被管理的强依赖关系，头部的句法元素是该层数据的核心，而一旦头部丢失，数据部分的信息几乎不可能再被正确解码出来，尤其在序列层及图像层。<br><img src="/2018/12/27/流媒体/H264/h264分析/h264_layers.gif" alt=""></p><p>在 H.264 中，分层结构最大的不同是取消了序列层和图像层，并将原本属于序列和图像头部的大部分句法元素游离出来形成序列和图像两级参数集，其余的部分则放入片层。<br>参数集是一个独立的数据单位，不依赖于参数集外的其他句法元素。一个参数集不对应某一个特定的图像或序列，同一序列参数集可以被多个图像参数集引用，同理，同一个图像参数集也可以被多个图像引用。只在编码器认为需要更新参数集的内容时，才会发出新的参数集。<br>复杂通信中的码流中可能出现的数据单位：<br><img src="/2018/12/27/流媒体/H264/h264分析/h264_layers2.gif" alt=""></p><p>IDR: 在H.264中，图像以序列为单位进行组织。一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。      IDR 图像一定是 I 图像，但 I 图像不一定是 IDR 图像。I帧之后的图像有可能会使用I帧之前的图像做运动参考。</p><p><img src="/2018/12/27/流媒体/H264/h264分析/h264_stream.jpg" alt=""></p><p>参考</p><blockquote><p><a href="http://www.360doc.com/content/14/0813/15/12697_401555631.shtml" title="H264编码原理和IBP帧" target="_blank" rel="noopener">H264编码原理和IBP帧</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/yibu_refresh/article/details/52829643" title="视频格式封装——H264" target="_blank" rel="noopener">视频格式封装——H264</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>live555分析-RTSP通信</title>
      <link href="/2018/12/26/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-RTSP%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/12/26/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-RTSP%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>RTSP是一种基于文本的协议，负责定义具体的控制信息、操作方法、状态码及描述与RTP之间的交互</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>OPTIONS</td><td>获得服务器提供的可用方法</td></tr><tr><td>DESCRIBE</td><td>获得会话描述信息</td></tr><tr><td>SETUP</td><td>客户端请求建立会话，确定传输模式</td></tr><tr><td>TEARDOWN</td><td>客户端发起关闭会话请求</td></tr><tr><td>PLAY</td><td>客户端发起播放请求</td></tr></tbody></table><p><a href="https://blog.csdn.net/deliapu/article/details/79199023" target="_blank" rel="noopener">https://blog.csdn.net/deliapu/article/details/79199023</a></p><h1 id="RTSP-RTP-RTCP简介"><a href="#RTSP-RTP-RTCP简介" class="headerlink" title="RTSP/RTP/RTCP简介"></a>RTSP/RTP/RTCP简介</h1><ul><li>RTP：实时传输协议（Real-time Transport Protocol）RTP/RTCP是实际传输数据的协议 RTP传输音频/视频数据，如果是PLAY，Server发送到Client端，如果是RECORD，可以由Client发送到Server 整个RTP协议由两个密切相关的部分组成：RTP数据协议和RTP控制协议（即RTCP)</li><li>RTSP：实时流协议（Real Time Streaming Protocol，RTSP）RTSP的请求主要有DESCRIBE,SETUP,PLAY,PAUSE,TEARDOWN,OPTIONS等，顾名思义可以知道起对话和控制作用 RTSP的对话过程中SETUP可以确定RTP/RTCP使用的端口，PLAY/PAUSE/TEARDOWN可以开始或者停止RTP的发送，等等</li><li>RTCP：RTP/RTCP是实际传输数据的协议 RTCP包括Sender Report和Receiver Report，用来进行音频/视频的同步以及其他用途，是一种控制协议</li></ul><h2 id="RTSP协议分析"><a href="#RTSP协议分析" class="headerlink" title="RTSP协议分析"></a>RTSP协议分析</h2><p><img src="/2018/12/26/流媒体/live555分析-RTSP通信/rtsp_summary.JPG" alt=""></p><p>由wireshark抓包来看，客户端地址为192.168.248.1,这是因为服务器是在虚拟机中跑的，采用NAT模式。故客户端连接服务端是通过虚拟网卡进行访问的，所以和客户端实际地址不符</p><p>由图可知，vlc实际上是通过rtsp over tcp,首先客户端和服务端建连，进行三次握手</p><pre><code>C                         S|    SYN,Seq = 0          ||    --------------&gt;      ||   SYN,Seq = 0, Ack = 1  | |   &lt;---------------      ||   ACK, Seq = 1, Ack = 1 ||   ----------------&gt;     |</code></pre><ul><li><p>建连成功后，vlc发送一个OPTIONS,请求获得服务器提供的可用方法</p><pre><code>OPTIONS rtsp://192.168.248.128:8554/test.264 RTSP/1.0CSeq: 2User-Agent: LibVLC/3.0.0 (LIVE555 Streaming Media v2016.11.28)RTSP/1.0 200 OKCSeq: 2Date: Wed, May 09 2018 16:47:04 GMTPublic: OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, GET_PARAMETER, SET_PARAMETER由OPTIONS Ack可知，live555 rtsp服务器支持OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, GET_PARAMETER, SET_PARAMETER方法</code></pre></li><li><p>请求获得SDP会话消息</p><pre><code>DESCRIBE rtsp://192.168.248.128:8554/test.264 RTSP/1.0CSeq: 3User-Agent: LibVLC/3.0.0 (LIVE555 Streaming Media v2016.11.28)Accept: application/sdpRTSP/1.0 200 OKCSeq: 3Date: Wed, May 09 2018 16:47:04 GMTContent-Base: rtsp://192.168.248.128:8554/test.264/Content-Type: application/sdpContent-Length: 519v=0  //protocol versiono=- 1525884424436139 1 IN IP4 192.168.248.128 //owners=H.264 Video, streamed by the LIVE555 Media Server //session namei=test.264 //session infot=0 0 //time &lt;start&gt; &lt;end&gt;a=tool:LIVE555 Streaming Media v2017.10.28 //&lt;属性&gt;a=type:broadcasta=control:*a=range:npt=0-a=x-qt-text-nam:H.264 Video, streamed by the LIVE555 Media Servera=x-qt-text-inf:test.264m=video 0 RTP/AVP 96 //media name and transport addressc=IN IP4 0.0.0.0 //connect infob=AS:500 // same as ca=rtpmap:96 H264/90000a=fmtp:96 packetization-mode=1;profile-level-id=4D4033;sprop-parameter-sets=Z01AM5JUDAS0IAAAAwBAAAAM0eMGVA==,aO48gA==a=control:track1 //视频流通道1</code></pre><p>  SDP定义了一些对此会话的描述信息</p></li><li><p>建立会话，确定传输模式</p><pre><code>SETUP rtsp://192.168.248.128:8554/test.264/track1 RTSP/1.0CSeq: 4User-Agent: LibVLC/3.0.0 (LIVE555 Streaming Media v2016.11.28)Transport: RTP/AVP;unicast;client_port=57814-57815RTSP/1.0 200 OKCSeq: 4Date: Wed, May 09 2018 16:47:04 GMTTransport: RTP/AVP;unicast;destination=192.168.248.1;source=192.168.248.128;client_port=57814-57815;server_port=6970-6971Session: ECAAF3DE;timeout=65</code></pre><p>  确定RTP/AVP协议传输，确定ip和端口号，客户端ip:192.168.248.1,RTP port:57814, RTCP port:57815;服务端ip:192.168.248.128 RTP和RTCP端口号分别为6970-6971</p></li><li><p>发送播放请求</p><pre><code>PLAY rtsp://192.168.248.128:8554/test.264/ RTSP/1.0CSeq: 5User-Agent: LibVLC/3.0.0 (LIVE555 Streaming Media v2016.11.28)Session: ECAAF3DERange: npt=0.000-RTSP/1.0 200 OKCSeq: 5Date: Wed, May 09 2018 16:47:04 GMTRange: npt=0.000-Session: ECAAF3DERTP-Info: url=rtsp://192.168.248.128:8554/test.264/track1;seq=54629;rtptime=1046126938</code></pre><p>  Range:0.000-标示播放到视频结束，客户端返回通道1,</p></li><li><p>关闭请求</p><pre><code>TEARDOWN rtsp://192.168.248.128:8554/test.264/ RTSP/1.0CSeq: 6User-Agent: LibVLC/3.0.0 (LIVE555 Streaming Media v2016.11.28)Session: ECAAF3DERTSP/1.0 200 OKCSeq: 6</code></pre></li></ul><p>RTSP已经分析完毕，现在对RTP H264进行梳理一下了</p><h2 id="H264-over-RTP分析"><a href="#H264-over-RTP分析" class="headerlink" title="H264 over RTP分析"></a>H264 over RTP分析</h2><h3 id="RTP-HEADER"><a href="#RTP-HEADER" class="headerlink" title="RTP HEADER"></a>RTP HEADER</h3><p><img src="/2018/12/26/流媒体/live555分析-RTSP通信/rtp_header.JPG" alt=""></p><ul><li>V: RTP version</li><li>P: 填充标志，if P = 1, 则在payload后面填充一个或者多个额外的8位组，非有效载荷的一部分</li><li>X: 拓展标志，if X = 1, 则在RTP包头后有一个拓展报头(需特殊处理)</li><li>CC: CSRC计数器，标示CSRC个数</li><li>M:标记，不同载荷有不同含义，对于视频，标示一帧的结束；对于音频，标记会话的开始(Payload FU也有S和E)</li><li>PT: 有效载荷类型</li><li>squence number:序列号，标示RTP报文序列号，可用来检查丢包，音视频包sequence是分别计数的</li><li>Timestamp:90HZ评率，用于计算延迟和延迟抖动，并进行同步控制</li><li>SSRC： 标示同步信源，随机选择的，参加同一视频会议的两个SSRC不能相同</li><li>CSRC: 可有0~15个，每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源。</li></ul><p><img src="/2018/12/26/流媒体/live555分析-RTSP通信/rtp_header_package.JPG" alt=""></p><ul><li>V: rtp version, 2</li><li>P: 0 无填充</li><li>X: 0 无拓展</li><li>CC: 0 CSRC</li><li>M：0</li><li>PT: DynamicRTP-Type-9</li><li>Sequence number: 54629</li><li>Timestamp:1046126938</li><li>SSRC: 0x89312047</li></ul><h3 id="RTP-Payload"><a href="#RTP-Payload" class="headerlink" title="RTP Payload"></a>RTP Payload</h3><p>H264定义了三种不同的基本的载荷结构，接收端可通过RTP Payload的Type字段辨别</p><pre><code>+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|F|NRI|  Type   |+---------------+</code></pre><p>RTP payload H和H264的NALU头结构是一样的，但type是特殊的格式，而h264type只取1~23是有效值</p><p>FH type:</p><ul><li>24 STAP-A 单一时间的组合包</li><li>25 STAP-B 单一时间的组合包</li><li>26 MTAP16 多个时间的组合包</li><li>27 MTAP24 多个时间的组合包</li><li>28 FU-A 分片的单元</li><li>29 FU-B 分片的单元</li><li>30-31 无定义</li></ul><h3 id="单一NAL单元模式"><a href="#单一NAL单元模式" class="headerlink" title="单一NAL单元模式"></a>单一NAL单元模式</h3><p>一个RTP仅仅由一个完整的NALU组成，此时RTP NAL Header和原始的H、264的头类型相同。</p><p>对于NALU的长度小于MTU，一般采用单一NAL单元模式， 原始的H264 NALU单元常由[start code] [NALU header] [NALU Payload]三部分组成，start code必须是”00 00 00 01”或”00 00 01”，其后是FH, 然后都是Payload</p><p>RTP打包时取出”00 00 00 01”或者”00 00 01”开始码，其他数据封包即可</p><pre><code> 0                  1                  2                  3  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 01 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |F|NRI|  type  |                                              |+-+-+-+-+-+-+-+-+                                              ||                                                              ||              Bytes 2..n of a Single NALunit                ||                                                              ||                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                              :...OPTIONAL RTP padding        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><h3 id="组合封包模式"><a href="#组合封包模式" class="headerlink" title="组合封包模式"></a>组合封包模式</h3><p>当NALU长度特别小时，可将几个NALU单元封在一个RTP包中<br>，有四种组合方式STAP-A(24)、STAP-B(25)、MTAP16(26)、MTAP24(27)</p><pre><code> 0                  1                  2                  3  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 01 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                         RTPHeader                          |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |STAP-A NAL HDR|         NALU 1Size           | NALU 1HDR    | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                        NALU 1 Data                          |:                                                              :+              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|              | NALU 2Size                  | NALU 2 HDR    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                        NALU 2 Data                          |:                                                              :|                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                              :...OPTIONAL RTP padding        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><h3 id="分片封包模式"><a href="#分片封包模式" class="headerlink" title="分片封包模式"></a>分片封包模式</h3><p>FU-A</p><pre><code>0                  1                  2                  3  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 01 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | FU indicator  |   FUheader  |                              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              ||                                                              ||                        FU payload                           ||                                                              ||                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                              :...OPTIONAL RTP padding        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>其中FU indicator格式</p><pre><code>+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|F|NRI|  Type   |+---------------+</code></pre><p>FU header格式<br>     +—————+<br>     |0|1|2|3|4|5|6|7|<br>     +-+-+-+-+-+-+-+-+<br>     |S|E|R|  Type   |<br>     +—————+</p><ul><li>S: 1是分片NAL单元的开始</li><li>E: 1只是NAL单元的结束</li><li>R: 必须为0</li></ul><p>其中FU indicator前三个bit = NALU的F和NRI,FU header的type = NALU的type</p><p>nal_uniy_type = (fu_indicator &amp; 0xe0) | (fu_header &amp; 0x1f)</p><p>-|-|-<br>0 | undefine |<br>1~23 | NALU | NAL单一NAL单元模式<br>24 | STAP-A |<br>25 | STAP-B |<br>26 | MTAP16 |<br>27 | MTAP24 |<br>28 | FU-A |<br>29 | FU-B |<br>30 ~31 | undefined</p><p>当NALU长度超过MTU时，就必须对NALU单元进行分片分包</p><p>Tips:<br>这两天对RTSP、RTP协议梳理了一下， 对以下还有疑问.<br>RTP可以跑在TCP或者UDP协议上 查看协议并未看到RTP Protocol有对粘包的问题有所处理(RTP header并无一个RTP包长度字段或者包界限符)。虽然RTP protocol规定了一个package不能大于MTU,避免被协议栈分包(TCP是传输的数据流,而RTP是数据报文,如果使用TCP传输就无法知道RTP包有多长,不知如何区分RTP包),但MTU分包只是粘包的其中一个原因</p><ul><li>应用层调用write方法，将应用层的缓冲区中的数据拷贝到套接字的发送缓冲区。而发送缓冲区有一个SO_SNDBUF的限制，如果应用层的缓冲区数据大小大于套接字发送缓冲区的大小，则数据需要进行多次的发送。</li><li>TCP所传输的报文段有MSS的限制，如果套接字缓冲区的大小大于MSS，也会导致消息的分割发送。</li><li>链路层最大发送单元MTU，在IP层会进行数据的分片。</li><li>接收端接收BUF不足以接收所有的stream,故对数据分多次保存。</li></ul><h1 id="SDP格式"><a href="#SDP格式" class="headerlink" title="SDP格式"></a>SDP格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">v=&lt;version&gt; </span><br><span class="line">o=&lt;username&gt; &lt;session id&gt; &lt;version&gt; &lt;network type&gt; &lt;address type&gt; &lt;address&gt; </span><br><span class="line">s=&lt;session name&gt; </span><br><span class="line">i=&lt;session description&gt; </span><br><span class="line">u=&lt;URI&gt; </span><br><span class="line">e=&lt;email address&gt; </span><br><span class="line">p=&lt;phone number&gt; </span><br><span class="line">c=&lt;network type&gt; &lt;address type&gt; &lt;connection address&gt; </span><br><span class="line">b=&lt;modifier&gt;:&lt;bandwidth-value&gt; </span><br><span class="line">t=&lt;start time&gt; &lt;stop time&gt; </span><br><span class="line">r=&lt;repeat interval&gt; &lt;active duration&gt; &lt;list of offsets from start-time&gt; </span><br><span class="line">z=&lt;adjustment time&gt; &lt;offset&gt; &lt;adjustment time&gt; &lt;offset&gt; .... </span><br><span class="line">k=&lt;method&gt; </span><br><span class="line">k=&lt;method&gt;:&lt;encryption key&gt; </span><br><span class="line">a=&lt;attribute&gt; </span><br><span class="line">a=&lt;attribute&gt;:&lt;value&gt; </span><br><span class="line">m=&lt;media&gt; &lt;port&gt; &lt;transport&gt; &lt;fmt list&gt; </span><br><span class="line">v = （协议版本） </span><br><span class="line">o = （所有者/创建者和会话标识符） </span><br><span class="line">s = （会话名称） </span><br><span class="line">i = * （会话信息） </span><br><span class="line">u = * （URI 描述） </span><br><span class="line">e = * （Email 地址） </span><br><span class="line">p = * （电话号码） </span><br><span class="line">c = * （连接信息） </span><br><span class="line">b = * （带宽信息） </span><br><span class="line">z = * （时间区域调整） </span><br><span class="line">k = * （加密密钥） </span><br><span class="line">a = * （0 个或多个会话属性行） </span><br><span class="line">时间描述： </span><br><span class="line">t = （会话活动时间） </span><br><span class="line">r = * （0或多次重复次数） </span><br><span class="line">媒体描述： </span><br><span class="line">m = （媒体名称和传输地址） </span><br><span class="line">i = * （媒体标题） </span><br><span class="line">c = * （连接信息 — 如果包含在会话层则该字段可选） </span><br><span class="line">b = * （带宽信息） </span><br><span class="line">k = * （加密密钥） </span><br><span class="line">a = * （0 个或多个媒体属性行）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>live555分析-rtsp_client接入</title>
      <link href="/2018/12/24/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-rtsp-client%E6%8E%A5%E5%85%A5/"/>
      <url>/2018/12/24/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-rtsp-client%E6%8E%A5%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>live555 在accept新的socket client， 保存其socket,addr,并将rtspServer保存在成员变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">createNewClientConnection(clientSocket, clientAddr);</span><br><span class="line"></span><br><span class="line">GenericMediaServer::ClientConnection</span><br><span class="line">::ClientConnection(GenericMediaServer&amp; ourServer, int clientSocket, struct sockaddr_in clientAddr)</span><br><span class="line">  : fOurServer(ourServer), fOurSocket(clientSocket), fClientAddr(clientAddr) &#123;</span><br><span class="line">  // Add ourself to our &apos;client connections&apos; table:</span><br><span class="line">  fOurServer.fClientConnections-&gt;Add((char const*)this, this);</span><br><span class="line">  </span><br><span class="line">  // Arrange to handle incoming requests:</span><br><span class="line">  resetRequestBuffer();</span><br><span class="line">  envir().taskScheduler()</span><br><span class="line">    .setBackgroundHandling(fOurSocket, SOCKET_READABLE|SOCKET_EXCEPTION, incomingRequestHandler, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并为socket注册readable handle <code>incomingRequestHandler</code>,接下来进入rtsp协议处理部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void GenericMediaServer::ClientConnection::incomingRequestHandler() &#123;</span><br><span class="line">  struct sockaddr_in dummy; // &apos;from&apos; address, meaningless in this case</span><br><span class="line">  </span><br><span class="line">  int bytesRead = readSocket(envir(), fOurSocket, &amp;fRequestBuffer[fRequestBytesAlreadySeen], fRequestBufferBytesLeft, dummy);</span><br><span class="line">  handleRequestBytes(bytesRead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取的data保存在fRequestBuffer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line">void RTSPServer::RTSPClientConnection::handleRequestBytes(int newBytesRead) &#123;</span><br><span class="line">  int numBytesRemaining = 0;</span><br><span class="line">  ++fRecursionCount;</span><br><span class="line">  </span><br><span class="line">  do &#123;</span><br><span class="line">    RTSPServer::RTSPClientSession* clientSession = NULL;</span><br><span class="line"></span><br><span class="line">    //如果BufferLeftSpace不足已接收new byte, 丢弃</span><br><span class="line">    if (newBytesRead &lt; 0 || (unsigned)newBytesRead &gt;= fRequestBufferBytesLeft) &#123;</span><br><span class="line">      // Either the client socket has died, or the request was too big for us.</span><br><span class="line">      // Terminate this connection:</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">      fprintf(stderr, &quot;RTSPClientConnection[%p]::handleRequestBytes() read %d new bytes (of %d); terminating connection!\n&quot;, this, newBytesRead, fRequestBufferBytesLeft);</span><br><span class="line">#endif</span><br><span class="line">      fIsActive = False;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Boolean endOfMsg = False;</span><br><span class="line">    unsigned char* ptr = &amp;fRequestBuffer[fRequestBytesAlreadySeen];</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    ptr[newBytesRead] = &apos;\0&apos;;</span><br><span class="line">    fprintf(stderr, &quot;RTSPClientConnection[%p]::handleRequestBytes() %s %d new bytes:%s\n&quot;,</span><br><span class="line">      this, numBytesRemaining &gt; 0 ? &quot;processing&quot; : &quot;read&quot;, newBytesRead, ptr);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    if (fClientOutputSocket != fClientInputSocket &amp;&amp; numBytesRemaining == 0) &#123;</span><br><span class="line">      // We&apos;re doing RTSP-over-HTTP tunneling, and input commands are assumed to have been Base64-encoded.</span><br><span class="line">      // We therefore Base64-decode as much of this new data as we can (i.e., up to a multiple of 4 bytes).</span><br><span class="line">      </span><br><span class="line">      // But first, we remove any whitespace that may be in the input data:</span><br><span class="line">      unsigned toIndex = 0;</span><br><span class="line">      for (int fromIndex = 0; fromIndex &lt; newBytesRead; ++fromIndex) &#123;</span><br><span class="line">  char c = ptr[fromIndex];</span><br><span class="line">  if (!(c == &apos; &apos; || c == &apos;\t&apos; || c == &apos;\r&apos; || c == &apos;\n&apos;)) &#123; // not &apos;whitespace&apos;: space,tab,CR,NL</span><br><span class="line">    ptr[toIndex++] = c;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newBytesRead = toIndex;//跳过无效字符</span><br><span class="line">      </span><br><span class="line">      unsigned numBytesToDecode = fBase64RemainderCount + newBytesRead;</span><br><span class="line">      unsigned newBase64RemainderCount = numBytesToDecode%4;</span><br><span class="line">      numBytesToDecode -= newBase64RemainderCount;</span><br><span class="line">      if (numBytesToDecode &gt; 0) &#123;</span><br><span class="line">  ptr[newBytesRead] = &apos;\0&apos;;</span><br><span class="line">  unsigned decodedSize;</span><br><span class="line">  unsigned char* decodedBytes = base64Decode((char const*)(ptr-fBase64RemainderCount), numBytesToDecode, decodedSize);</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">  fprintf(stderr, &quot;Base64-decoded %d input bytes into %d new bytes:&quot;, numBytesToDecode, decodedSize);</span><br><span class="line">  for (unsigned k = 0; k &lt; decodedSize; ++k) fprintf(stderr, &quot;%c&quot;, decodedBytes[k]);</span><br><span class="line">  fprintf(stderr, &quot;\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">  // Copy the new decoded bytes in place of the old ones (we can do this because there are fewer decoded bytes than original):</span><br><span class="line">  unsigned char* to = ptr-fBase64RemainderCount;</span><br><span class="line">  for (unsigned i = 0; i &lt; decodedSize; ++i) *to++ = decodedBytes[i];</span><br><span class="line">  </span><br><span class="line">  // Then copy any remaining (undecoded) bytes to the end:</span><br><span class="line">  for (unsigned j = 0; j &lt; newBase64RemainderCount; ++j) *to++ = (ptr-fBase64RemainderCount+numBytesToDecode)[j];</span><br><span class="line">  </span><br><span class="line">  newBytesRead = decodedSize - fBase64RemainderCount + newBase64RemainderCount;</span><br><span class="line">    // adjust to allow for the size of the new decoded data (+ remainder)</span><br><span class="line">  delete[] decodedBytes;</span><br><span class="line">      &#125;</span><br><span class="line">      fBase64RemainderCount = newBase64RemainderCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unsigned char* tmpPtr = fLastCRLF + 2;</span><br><span class="line">    if (fBase64RemainderCount == 0) &#123; // no more Base-64 bytes remain to be read/decoded</span><br><span class="line">      // Look for the end of the message: &lt;CR&gt;&lt;LF&gt;&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">      if (tmpPtr &lt; fRequestBuffer) tmpPtr = fRequestBuffer;</span><br><span class="line">      while (tmpPtr &lt; &amp;ptr[newBytesRead-1]) &#123;</span><br><span class="line">  if (*tmpPtr == &apos;\r&apos; &amp;&amp; *(tmpPtr+1) == &apos;\n&apos;) &#123;</span><br><span class="line">    if (tmpPtr - fLastCRLF == 2) &#123; // This is it:</span><br><span class="line">      endOfMsg = True;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    fLastCRLF = tmpPtr;</span><br><span class="line">  &#125;</span><br><span class="line">  ++tmpPtr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /************************************************/</span><br><span class="line">    fRequestBuffer</span><br><span class="line">    --------------------------------------------------</span><br><span class="line">    |fRequestBytesAlreadySeen|fRequestBufferBytesLeft|</span><br><span class="line">    --------------------------------------------------</span><br><span class="line">    /************************************************/</span><br><span class="line"></span><br><span class="line">    fRequestBufferBytesLeft -= newBytesRead;</span><br><span class="line">    fRequestBytesAlreadySeen += newBytesRead;</span><br><span class="line">    </span><br><span class="line">    if (!endOfMsg) break; // subsequent reads will be needed to complete the request</span><br><span class="line">    </span><br><span class="line">    // Parse the request string into command name and &apos;CSeq&apos;, then handle the command:</span><br><span class="line">    fRequestBuffer[fRequestBytesAlreadySeen] = &apos;\0&apos;;</span><br><span class="line">    char cmdName[RTSP_PARAM_STRING_MAX];</span><br><span class="line">    char urlPreSuffix[RTSP_PARAM_STRING_MAX];</span><br><span class="line">    char urlSuffix[RTSP_PARAM_STRING_MAX];</span><br><span class="line">    char cseq[RTSP_PARAM_STRING_MAX];</span><br><span class="line">    char sessionIdStr[RTSP_PARAM_STRING_MAX];</span><br><span class="line">    unsigned contentLength = 0;</span><br><span class="line">    fLastCRLF[2] = &apos;\0&apos;; // temporarily, for parsing</span><br><span class="line"></span><br><span class="line">    //解析rtsp消息</span><br><span class="line">    Boolean parseSucceeded = parseRTSPRequestString((char*)fRequestBuffer, fLastCRLF+2 - fRequestBuffer,</span><br><span class="line">                cmdName, sizeof cmdName,</span><br><span class="line">                urlPreSuffix, sizeof urlPreSuffix,</span><br><span class="line">                urlSuffix, sizeof urlSuffix,</span><br><span class="line">                cseq, sizeof cseq,</span><br><span class="line">                sessionIdStr, sizeof sessionIdStr,</span><br><span class="line">                contentLength);</span><br><span class="line">    fLastCRLF[2] = &apos;\r&apos;; // restore its value</span><br><span class="line">    Boolean playAfterSetup = False;</span><br><span class="line"></span><br><span class="line">    //解析成功，处理RTSP command</span><br><span class="line">    //OPTIONS DESCRIBE SETUP TEARDOWN PLAY PAUSE </span><br><span class="line">    if (parseSucceeded) &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">      fprintf(stderr, &quot;parseRTSPRequestString() succeeded, returning cmdName \&quot;%s\&quot;, urlPreSuffix \&quot;%s\&quot;, urlSuffix \&quot;%s\&quot;, CSeq \&quot;%s\&quot;, Content-Length %u, with %d bytes following the message.\n&quot;, cmdName, urlPreSuffix, urlSuffix, cseq, contentLength, ptr + newBytesRead - (tmpPtr + 2));</span><br><span class="line">#endif</span><br><span class="line">      // If there was a &quot;Content-Length:&quot; header, then make sure we&apos;ve received all of the data that it specified:</span><br><span class="line">      if (ptr + newBytesRead &lt; tmpPtr + 2 + contentLength) break; // we still need more data; subsequent reads will give it to us </span><br><span class="line">      </span><br><span class="line">      // If the request included a &quot;Session:&quot; id, and it refers to a client session that&apos;s</span><br><span class="line">      // current ongoing, then use this command to indicate &apos;liveness&apos; on that client session:</span><br><span class="line">      Boolean const requestIncludedSessionId = sessionIdStr[0] != &apos;\0&apos;;</span><br><span class="line">      if (requestIncludedSessionId) &#123;</span><br><span class="line">  clientSession</span><br><span class="line">    = (RTSPServer::RTSPClientSession*)(fOurRTSPServer.lookupClientSession(sessionIdStr));</span><br><span class="line">  if (clientSession != NULL) clientSession-&gt;noteLiveness();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // We now have a complete RTSP request.</span><br><span class="line">      // Handle the specified command (beginning with commands that are session-independent):</span><br><span class="line">      fCurrentCSeq = cseq;</span><br><span class="line">      if (strcmp(cmdName, &quot;OPTIONS&quot;) == 0) &#123;</span><br><span class="line">  // If the &quot;OPTIONS&quot; command included a &quot;Session:&quot; id for a session that doesn&apos;t exist,</span><br><span class="line">  // then treat this as an error:</span><br><span class="line">  if (requestIncludedSessionId &amp;&amp; clientSession == NULL) &#123;</span><br><span class="line">    handleCmd_sessionNotFound();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Normal case:</span><br><span class="line">    handleCmd_OPTIONS();</span><br><span class="line">  &#125;</span><br><span class="line">      &#125; else if (urlPreSuffix[0] == &apos;\0&apos; &amp;&amp; urlSuffix[0] == &apos;*&apos; &amp;&amp; urlSuffix[1] == &apos;\0&apos;) &#123;</span><br><span class="line">  // The special &quot;*&quot; URL means: an operation on the entire server.  This works only for GET_PARAMETER and SET_PARAMETER:</span><br><span class="line">  if (strcmp(cmdName, &quot;GET_PARAMETER&quot;) == 0) &#123;</span><br><span class="line">    handleCmd_GET_PARAMETER((char const*)fRequestBuffer);</span><br><span class="line">  &#125; else if (strcmp(cmdName, &quot;SET_PARAMETER&quot;) == 0) &#123;</span><br><span class="line">    handleCmd_SET_PARAMETER((char const*)fRequestBuffer);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    handleCmd_notSupported();</span><br><span class="line">  &#125;</span><br><span class="line">      &#125; else if (strcmp(cmdName, &quot;DESCRIBE&quot;) == 0) &#123;</span><br><span class="line">  handleCmd_DESCRIBE(urlPreSuffix, urlSuffix, (char const*)fRequestBuffer);</span><br><span class="line">      &#125; else if (strcmp(cmdName, &quot;SETUP&quot;) == 0) &#123;</span><br><span class="line">  Boolean areAuthenticated = True;</span><br><span class="line"></span><br><span class="line">  if (!requestIncludedSessionId) &#123;</span><br><span class="line">    // No session id was present in the request.</span><br><span class="line">    // So create a new &quot;RTSPClientSession&quot; object for this request.</span><br><span class="line"></span><br><span class="line">    // But first, make sure that we&apos;re authenticated to perform this command:</span><br><span class="line">    char urlTotalSuffix[2*RTSP_PARAM_STRING_MAX];</span><br><span class="line">        // enough space for urlPreSuffix/urlSuffix&apos;\0&apos;</span><br><span class="line">    urlTotalSuffix[0] = &apos;\0&apos;;</span><br><span class="line">    if (urlPreSuffix[0] != &apos;\0&apos;) &#123;</span><br><span class="line">      strcat(urlTotalSuffix, urlPreSuffix);</span><br><span class="line">      strcat(urlTotalSuffix, &quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    strcat(urlTotalSuffix, urlSuffix);</span><br><span class="line">    if (authenticationOK(&quot;SETUP&quot;, urlTotalSuffix, (char const*)fRequestBuffer)) &#123;</span><br><span class="line">      clientSession</span><br><span class="line">        = (RTSPServer::RTSPClientSession*)fOurRTSPServer.createNewClientSessionWithId();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      areAuthenticated = False;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (clientSession != NULL) &#123;</span><br><span class="line">    clientSession-&gt;handleCmd_SETUP(this, urlPreSuffix, urlSuffix, (char const*)fRequestBuffer);</span><br><span class="line">    playAfterSetup = clientSession-&gt;fStreamAfterSETUP;</span><br><span class="line">  &#125; else if (areAuthenticated) &#123;</span><br><span class="line">    handleCmd_sessionNotFound();</span><br><span class="line">  &#125;</span><br><span class="line">      &#125; else if (strcmp(cmdName, &quot;TEARDOWN&quot;) == 0</span><br><span class="line">     || strcmp(cmdName, &quot;PLAY&quot;) == 0</span><br><span class="line">     || strcmp(cmdName, &quot;PAUSE&quot;) == 0</span><br><span class="line">     || strcmp(cmdName, &quot;GET_PARAMETER&quot;) == 0</span><br><span class="line">     || strcmp(cmdName, &quot;SET_PARAMETER&quot;) == 0) &#123;</span><br><span class="line">  if (clientSession != NULL) &#123;</span><br><span class="line">    clientSession-&gt;handleCmd_withinSession(this, cmdName, urlPreSuffix, urlSuffix, (char const*)fRequestBuffer);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    handleCmd_sessionNotFound();</span><br><span class="line">  &#125;</span><br><span class="line">      &#125; else if (strcmp(cmdName, &quot;REGISTER&quot;) == 0 || strcmp(cmdName, &quot;DEREGISTER&quot;) == 0) &#123;</span><br><span class="line">  // Because - unlike other commands - an implementation of this command needs</span><br><span class="line">  // the entire URL, we re-parse the command to get it:</span><br><span class="line">  char* url = strDupSize((char*)fRequestBuffer);</span><br><span class="line">  if (sscanf((char*)fRequestBuffer, &quot;%*s %s&quot;, url) == 1) &#123;</span><br><span class="line">    // Check for special command-specific parameters in a &quot;Transport:&quot; header:</span><br><span class="line">    Boolean reuseConnection, deliverViaTCP;</span><br><span class="line">    char* proxyURLSuffix;</span><br><span class="line">    parseTransportHeaderForREGISTER((const char*)fRequestBuffer, reuseConnection, deliverViaTCP, proxyURLSuffix);</span><br><span class="line"></span><br><span class="line">    handleCmd_REGISTER(cmdName, url, urlSuffix, (char const*)fRequestBuffer, reuseConnection, deliverViaTCP, proxyURLSuffix);</span><br><span class="line">    delete[] proxyURLSuffix;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    handleCmd_bad();</span><br><span class="line">  &#125;</span><br><span class="line">  delete[] url;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">  // The command is one that we don&apos;t handle:</span><br><span class="line">  handleCmd_notSupported();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">      fprintf(stderr, &quot;parseRTSPRequestString() failed; checking now for HTTP commands (for RTSP-over-HTTP tunneling)...\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">      // The request was not (valid) RTSP, but check for a special case: HTTP commands (for setting up RTSP-over-HTTP tunneling):</span><br><span class="line">      char sessionCookie[RTSP_PARAM_STRING_MAX];</span><br><span class="line">      char acceptStr[RTSP_PARAM_STRING_MAX];</span><br><span class="line">      *fLastCRLF = &apos;\0&apos;; // temporarily, for parsing</span><br><span class="line">      parseSucceeded = parseHTTPRequestString(cmdName, sizeof cmdName,</span><br><span class="line">                urlSuffix, sizeof urlPreSuffix,</span><br><span class="line">                sessionCookie, sizeof sessionCookie,</span><br><span class="line">                acceptStr, sizeof acceptStr);</span><br><span class="line">      *fLastCRLF = &apos;\r&apos;;</span><br><span class="line">      if (parseSucceeded) &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">  fprintf(stderr, &quot;parseHTTPRequestString() succeeded, returning cmdName \&quot;%s\&quot;, urlSuffix \&quot;%s\&quot;, sessionCookie \&quot;%s\&quot;, acceptStr \&quot;%s\&quot;\n&quot;, cmdName, urlSuffix, sessionCookie, acceptStr);</span><br><span class="line">#endif</span><br><span class="line">  // Check that the HTTP command is valid for RTSP-over-HTTP tunneling: There must be a &apos;session cookie&apos;.</span><br><span class="line">  Boolean isValidHTTPCmd = True;</span><br><span class="line">  if (strcmp(cmdName, &quot;OPTIONS&quot;) == 0) &#123;</span><br><span class="line">    handleHTTPCmd_OPTIONS();</span><br><span class="line">  &#125; else if (sessionCookie[0] == &apos;\0&apos;) &#123;</span><br><span class="line">    // There was no &quot;x-sessioncookie:&quot; header.  If there was an &quot;Accept: application/x-rtsp-tunnelled&quot; header,</span><br><span class="line">    // then this is a bad tunneling request.  Otherwise, assume that it&apos;s an attempt to access the stream via HTTP.</span><br><span class="line">    if (strcmp(acceptStr, &quot;application/x-rtsp-tunnelled&quot;) == 0) &#123;</span><br><span class="line">      isValidHTTPCmd = False;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      handleHTTPCmd_StreamingGET(urlSuffix, (char const*)fRequestBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (strcmp(cmdName, &quot;GET&quot;) == 0) &#123;</span><br><span class="line">    handleHTTPCmd_TunnelingGET(sessionCookie);</span><br><span class="line">  &#125; else if (strcmp(cmdName, &quot;POST&quot;) == 0) &#123;</span><br><span class="line">    // We might have received additional data following the HTTP &quot;POST&quot; command - i.e., the first Base64-encoded RTSP command.</span><br><span class="line">    // Check for this, and handle it if it exists:</span><br><span class="line">    unsigned char const* extraData = fLastCRLF+4;</span><br><span class="line">    unsigned extraDataSize = &amp;fRequestBuffer[fRequestBytesAlreadySeen] - extraData;</span><br><span class="line">    if (handleHTTPCmd_TunnelingPOST(sessionCookie, extraData, extraDataSize)) &#123;</span><br><span class="line">      // We don&apos;t respond to the &quot;POST&quot; command, and we go away:</span><br><span class="line">      fIsActive = False;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    isValidHTTPCmd = False;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!isValidHTTPCmd) &#123;</span><br><span class="line">    handleHTTPCmd_notSupported();</span><br><span class="line">  &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">  fprintf(stderr, &quot;parseHTTPRequestString() failed!\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">  handleCmd_bad();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    fprintf(stderr, &quot;sending response: %s&quot;, fResponseBuffer);</span><br><span class="line">#endif</span><br><span class="line">    send(fClientOutputSocket, (char const*)fResponseBuffer, strlen((char*)fResponseBuffer), 0);</span><br><span class="line">    </span><br><span class="line">    if (playAfterSetup) &#123;</span><br><span class="line">      // The client has asked for streaming to commence now, rather than after a</span><br><span class="line">      // subsequent &quot;PLAY&quot; command.  So, simulate the effect of a &quot;PLAY&quot; command:</span><br><span class="line">      clientSession-&gt;handleCmd_withinSession(this, &quot;PLAY&quot;, urlPreSuffix, urlSuffix, (char const*)fRequestBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Check whether there are extra bytes remaining in the buffer, after the end of the request (a rare case).</span><br><span class="line">    // If so, move them to the front of our buffer, and keep processing it, because it might be a following, pipelined request.</span><br><span class="line">    unsigned requestSize = (fLastCRLF+4-fRequestBuffer) + contentLength;</span><br><span class="line">    numBytesRemaining = fRequestBytesAlreadySeen - requestSize;</span><br><span class="line">    resetRequestBuffer(); // to prepare for any subsequent request</span><br><span class="line">    </span><br><span class="line">    if (numBytesRemaining &gt; 0) &#123;</span><br><span class="line">      memmove(fRequestBuffer, &amp;fRequestBuffer[requestSize], numBytesRemaining);</span><br><span class="line">      newBytesRead = numBytesRemaining;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (numBytesRemaining &gt; 0);</span><br><span class="line">  </span><br><span class="line">  --fRecursionCount;</span><br><span class="line">  if (!fIsActive) &#123;</span><br><span class="line">    if (fRecursionCount &gt; 0) closeSockets(); else delete this;</span><br><span class="line">    // Note: The &quot;fRecursionCount&quot; test is for a pathological situation where we reenter the event loop and get called recursively</span><br><span class="line">    // while handling a command (e.g., while handling a &quot;DESCRIBE&quot;, to get a SDP description).</span><br><span class="line">    // In such a case we don&apos;t want to actually delete ourself until we leave the outermost call.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>live555分析-TaskScheduler分析</title>
      <link href="/2018/12/21/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-TaskScheduler%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/21/%E6%B5%81%E5%AA%92%E4%BD%93/live555%E5%88%86%E6%9E%90-TaskScheduler%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="TaskScheduler类"><a href="#TaskScheduler类" class="headerlink" title="TaskScheduler类"></a>TaskScheduler类</h1><p>TaskScheduler是任务调度的基类， 其类关系如图所示</p><p><img src="/2018/12/21/流媒体/live555分析-TaskScheduler分析/TaskScheduler.PNG" alt=""></p><p>首先可从代码调用关系开始着手分析</p><p>BasicTaskScheduler0主要初始化一些参数，包括socket、 event handle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BasicTaskScheduler0::BasicTaskScheduler0()</span><br><span class="line">  : fLastHandledSocketNum(-1), fTriggersAwaitingHandling(0), fLastUsedTriggerMask(1), fLastUsedTriggerNum(MAX_NUM_EVENT_TRIGGERS-1) &#123;</span><br><span class="line">  fHandlers = new HandlerSet;</span><br><span class="line">  for (unsigned i = 0; i &lt; MAX_NUM_EVENT_TRIGGERS; ++i) &#123;</span><br><span class="line">    fTriggeredEventHandlers[i] = NULL;</span><br><span class="line">    fTriggeredEventClientDatas[i] = NULL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskScheduler* scheduler = BasicTaskScheduler::createNew();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BasicTaskScheduler::BasicTaskScheduler(unsigned maxSchedulerGranularity)</span><br><span class="line">  : fMaxSchedulerGranularity(maxSchedulerGranularity), fMaxNumSockets(0)</span><br><span class="line">#if defined(__WIN32__) || defined(_WIN32)</span><br><span class="line">  , fDummySocketNum(-1)</span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">  FD_ZERO(&amp;fReadSet);</span><br><span class="line">  FD_ZERO(&amp;fWriteSet);</span><br><span class="line">  FD_ZERO(&amp;fExceptionSet);</span><br><span class="line"></span><br><span class="line">  if (maxSchedulerGranularity &gt; 0) schedulerTickTask(); // ensures that we handle events frequently</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UsageEnvironment<em> env = BasicUsageEnvironment::createNew(</em>scheduler);</p><p>scheduler作为一个参数作为UsageEnvironment的构造参数， 实际上UsageEnvironment是将其作为一个成员变量进行保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UsageEnvironment::UsageEnvironment(TaskScheduler&amp; scheduler)</span><br><span class="line">  : liveMediaPriv(NULL), groupsockPriv(NULL), fScheduler(scheduler) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在开始分析live555 server创建过程可以看出,使用引用的taskScheduler将readhandle注册到taskscheduler,当read event触发时，taskscheduer进入注册的event进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rtspServer = RTSPServer::createNew(*env, rtspServerPortNum, authDB);</span><br><span class="line"></span><br><span class="line">GenericMediaServer</span><br><span class="line">::GenericMediaServer(UsageEnvironment&amp; env, int ourSocket, Port ourPort,</span><br><span class="line">             unsigned reclamationSeconds)</span><br><span class="line">  : Medium(env),</span><br><span class="line">    fServerSocket(ourSocket), fServerPort(ourPort), fReclamationSeconds(reclamationSeconds),</span><br><span class="line">    fServerMediaSessions(HashTable::create(STRING_HASH_KEYS)),</span><br><span class="line">    fClientConnections(HashTable::create(ONE_WORD_HASH_KEYS)),</span><br><span class="line">    fClientSessions(HashTable::create(STRING_HASH_KEYS)) &#123;</span><br><span class="line">  ignoreSigPipeOnSocket(fServerSocket); // so that clients on the same host that are killed don&apos;t also kill us</span><br><span class="line">  </span><br><span class="line">  // Arrange to handle connections from others:</span><br><span class="line">  env.taskScheduler().turnOnBackgroundReadHandling(fServerSocket, incomingConnectionHandler, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="setBackgroundHandling分析"><a href="#setBackgroundHandling分析" class="headerlink" title="setBackgroundHandling分析"></a>setBackgroundHandling分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void BasicTaskScheduler</span><br><span class="line">  ::setBackgroundHandling(int socketNum, int conditionSet, BackgroundHandlerProc* handlerProc, void* clientData) &#123;</span><br><span class="line">  if (socketNum &lt; 0) return;</span><br><span class="line">#if !defined(__WIN32__) &amp;&amp; !defined(_WIN32) &amp;&amp; defined(FD_SETSIZE)</span><br><span class="line">  if (socketNum &gt;= (int)(FD_SETSIZE)) return;</span><br><span class="line">#endif</span><br><span class="line">  FD_CLR((unsigned)socketNum, &amp;fReadSet);</span><br><span class="line">  FD_CLR((unsigned)socketNum, &amp;fWriteSet);</span><br><span class="line">  FD_CLR((unsigned)socketNum, &amp;fExceptionSet);</span><br><span class="line">  if (conditionSet == 0) &#123;</span><br><span class="line">    fHandlers-&gt;clearHandler(socketNum);</span><br><span class="line">    if (socketNum+1 == fMaxNumSockets) &#123;</span><br><span class="line">      --fMaxNumSockets;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fHandlers-&gt;assignHandler(socketNum, conditionSet, handlerProc, clientData);</span><br><span class="line">    if (socketNum+1 &gt; fMaxNumSockets) &#123;</span><br><span class="line">      fMaxNumSockets = socketNum+1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (conditionSet&amp;SOCKET_READABLE) FD_SET((unsigned)socketNum, &amp;fReadSet);</span><br><span class="line">    if (conditionSet&amp;SOCKET_WRITABLE) FD_SET((unsigned)socketNum, &amp;fWriteSet);</span><br><span class="line">    if (conditionSet&amp;SOCKET_EXCEPTION) FD_SET((unsigned)socketNum, &amp;fExceptionSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用hash进行sockerNum &lt;====&gt; handlerProc,client映射；具体可见HandlerSet<br>::assignHandler</p><p>至此rtspservice初始化已经完成，下面介绍client connect处理<br>GenericMediaServer::incomingConnectionHandlerOnSocket</p><ul><li>监听connect消息，accept serverSocket</li><li>ignoreSigPipeOnSocket,send已经的关闭的套接字时,收到SIGPIPE信号,系统对该信号的默认处理方式是程序直接退出</li><li>makeSocketNonBlocking,设置socket no block</li><li>设置client send buffer,默认50K</li><li>创建client connection</li></ul><p>client connection处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTSPServer::RTSPClientConnection</span><br><span class="line">::RTSPClientConnection(RTSPServer&amp; ourServer, int clientSocket, struct sockaddr_in clientAddr)</span><br><span class="line">  : GenericMediaServer::ClientConnection(ourServer, clientSocket, clientAddr),</span><br><span class="line">    fOurRTSPServer(ourServer), fClientInputSocket(fOurSocket), fClientOutputSocket(fOurSocket),</span><br><span class="line">    fIsActive(True), fRecursionCount(0), fOurSessionCookie(NULL) &#123;</span><br><span class="line">  resetRequestBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clientConnection保存RTSPServer、clientSocket、clientAddr</p><p>接下来进入TaskScheduler的doEventLoop函数,taskscheduler yield函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">void BasicTaskScheduler::SingleStep(unsigned maxDelayTime) &#123;</span><br><span class="line">  fd_set readSet = fReadSet; // make a copy for this select() call</span><br><span class="line">  fd_set writeSet = fWriteSet; // ditto</span><br><span class="line">  fd_set exceptionSet = fExceptionSet; // ditto</span><br><span class="line"></span><br><span class="line">  DelayInterval const&amp; timeToDelay = fDelayQueue.timeToNextAlarm();</span><br><span class="line">  struct timeval tv_timeToDelay;</span><br><span class="line">  tv_timeToDelay.tv_sec = timeToDelay.seconds();</span><br><span class="line">  tv_timeToDelay.tv_usec = timeToDelay.useconds();</span><br><span class="line">  // Very large &quot;tv_sec&quot; values cause select() to fail.</span><br><span class="line">  // Don&apos;t make it any larger than 1 million seconds (11.5 days)</span><br><span class="line">  const long MAX_TV_SEC = MILLION;</span><br><span class="line">  if (tv_timeToDelay.tv_sec &gt; MAX_TV_SEC) &#123;</span><br><span class="line">    tv_timeToDelay.tv_sec = MAX_TV_SEC;</span><br><span class="line">  &#125;</span><br><span class="line">  // Also check our &quot;maxDelayTime&quot; parameter (if it&apos;s &gt; 0):</span><br><span class="line">  if (maxDelayTime &gt; 0 &amp;&amp;</span><br><span class="line">      (tv_timeToDelay.tv_sec &gt; (long)maxDelayTime/MILLION ||</span><br><span class="line">       (tv_timeToDelay.tv_sec == (long)maxDelayTime/MILLION &amp;&amp;</span><br><span class="line">    tv_timeToDelay.tv_usec &gt; (long)maxDelayTime%MILLION))) &#123;</span><br><span class="line">    tv_timeToDelay.tv_sec = maxDelayTime/MILLION;</span><br><span class="line">    tv_timeToDelay.tv_usec = maxDelayTime%MILLION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int selectResult = select(fMaxNumSockets, &amp;readSet, &amp;writeSet,  &amp;exceptionSet, &amp;tv_timeToDelay);  //监听事件</span><br><span class="line">  if (selectResult &lt; 0) &#123;</span><br><span class="line">#if defined(__WIN32__) || defined(_WIN32)</span><br><span class="line">    int err = WSAGetLastError();</span><br><span class="line">    // For some unknown reason, select() in Windoze sometimes fails with WSAEINVAL if</span><br><span class="line">    // it was called with no entries set in &quot;readSet&quot;.  If this happens, ignore it:</span><br><span class="line">    if (err == WSAEINVAL &amp;&amp; readSet.fd_count == 0) &#123;</span><br><span class="line">      err = EINTR;</span><br><span class="line">      // To stop this from happening again, create a dummy socket:</span><br><span class="line">      if (fDummySocketNum &gt;= 0) closeSocket(fDummySocketNum);</span><br><span class="line">      fDummySocketNum = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">      FD_SET((unsigned)fDummySocketNum, &amp;fReadSet);</span><br><span class="line">    &#125;</span><br><span class="line">    if (err != EINTR) &#123;</span><br><span class="line">#else</span><br><span class="line">    if (errno != EINTR &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">#endif</span><br><span class="line">    // Unexpected error - treat this as fatal:</span><br><span class="line">#if !defined(_WIN32_WCE)</span><br><span class="line">    perror(&quot;BasicTaskScheduler::SingleStep(): select() fails&quot;);</span><br><span class="line">    // Because this failure is often &quot;Bad file descriptor&quot; - which is caused by an invalid socket number (i.e., a socket number</span><br><span class="line">    // that had already been closed) being used in &quot;select()&quot; - we print out the sockets that were being used in &quot;select()&quot;,</span><br><span class="line">    // to assist in debugging:</span><br><span class="line">    fprintf(stderr, &quot;socket numbers used in the select() call:&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">      if (FD_ISSET(i, &amp;fReadSet) || FD_ISSET(i, &amp;fWriteSet) || FD_ISSET(i, &amp;fExceptionSet)) &#123;</span><br><span class="line">        fprintf(stderr, &quot; %d(&quot;, i);</span><br><span class="line">        if (FD_ISSET(i, &amp;fReadSet)) fprintf(stderr, &quot;r&quot;);</span><br><span class="line">        if (FD_ISSET(i, &amp;fWriteSet)) fprintf(stderr, &quot;w&quot;);</span><br><span class="line">        if (FD_ISSET(i, &amp;fExceptionSet)) fprintf(stderr, &quot;e&quot;);</span><br><span class="line">        fprintf(stderr, &quot;)&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fprintf(stderr, &quot;\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">    internalError();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //调用注册的event handle</span><br><span class="line">  // Call the handler function for one readable socket:</span><br><span class="line">  HandlerIterator iter(*fHandlers);</span><br><span class="line">  HandlerDescriptor* handler;</span><br><span class="line">  // To ensure forward progress through the handlers, begin past the last</span><br><span class="line">  // socket number that we handled:</span><br><span class="line">  if (fLastHandledSocketNum &gt;= 0) &#123;</span><br><span class="line">    while ((handler = iter.next()) != NULL) &#123;</span><br><span class="line">      if (handler-&gt;socketNum == fLastHandledSocketNum) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (handler == NULL) &#123;</span><br><span class="line">      fLastHandledSocketNum = -1;</span><br><span class="line">      iter.reset(); // start from the beginning instead</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ((handler = iter.next()) != NULL) &#123;</span><br><span class="line">    int sock = handler-&gt;socketNum; // alias</span><br><span class="line">    int resultConditionSet = 0;</span><br><span class="line">    if (FD_ISSET(sock, &amp;readSet) &amp;&amp; FD_ISSET(sock, &amp;fReadSet)/*sanity check*/) resultConditionSet |= SOCKET_READABLE;</span><br><span class="line">    if (FD_ISSET(sock, &amp;writeSet) &amp;&amp; FD_ISSET(sock, &amp;fWriteSet)/*sanity check*/) resultConditionSet |= SOCKET_WRITABLE;</span><br><span class="line">    if (FD_ISSET(sock, &amp;exceptionSet) &amp;&amp; FD_ISSET(sock, &amp;fExceptionSet)/*sanity check*/) resultConditionSet |= SOCKET_EXCEPTION;</span><br><span class="line">    if ((resultConditionSet&amp;handler-&gt;conditionSet) != 0 &amp;&amp; handler-&gt;handlerProc != NULL) &#123;</span><br><span class="line">      fLastHandledSocketNum = sock;</span><br><span class="line">          // Note: we set &quot;fLastHandledSocketNum&quot; before calling the handler,</span><br><span class="line">          // in case the handler calls &quot;doEventLoop()&quot; reentrantly.</span><br><span class="line">      (*handler-&gt;handlerProc)(handler-&gt;clientData, resultConditionSet);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (handler == NULL &amp;&amp; fLastHandledSocketNum &gt;= 0) &#123;</span><br><span class="line">    // We didn&apos;t call a handler, but we didn&apos;t get to check all of them,</span><br><span class="line">    // so try again from the beginning:</span><br><span class="line">    iter.reset();</span><br><span class="line">    while ((handler = iter.next()) != NULL) &#123;</span><br><span class="line">      int sock = handler-&gt;socketNum; // alias</span><br><span class="line">      int resultConditionSet = 0;</span><br><span class="line">      if (FD_ISSET(sock, &amp;readSet) &amp;&amp; FD_ISSET(sock, &amp;fReadSet)/*sanity check*/) resultConditionSet |= SOCKET_READABLE;</span><br><span class="line">      if (FD_ISSET(sock, &amp;writeSet) &amp;&amp; FD_ISSET(sock, &amp;fWriteSet)/*sanity check*/) resultConditionSet |= SOCKET_WRITABLE;</span><br><span class="line">      if (FD_ISSET(sock, &amp;exceptionSet) &amp;&amp; FD_ISSET(sock, &amp;fExceptionSet)/*sanity check*/) resultConditionSet |= SOCKET_EXCEPTION;</span><br><span class="line">      if ((resultConditionSet&amp;handler-&gt;conditionSet) != 0 &amp;&amp; handler-&gt;handlerProc != NULL) &#123;</span><br><span class="line">    fLastHandledSocketNum = sock;</span><br><span class="line">        // Note: we set &quot;fLastHandledSocketNum&quot; before calling the handler,</span><br><span class="line">            // in case the handler calls &quot;doEventLoop()&quot; reentrantly.</span><br><span class="line">    (*handler-&gt;handlerProc)(handler-&gt;clientData, resultConditionSet);</span><br><span class="line">    break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (handler == NULL) fLastHandledSocketNum = -1;//because we didn&apos;t call a handler</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Also handle any newly-triggered event (Note that we do this *after* calling a socket handler,</span><br><span class="line">  // in case the triggered event handler modifies The set of readable sockets.)</span><br><span class="line">  if (fTriggersAwaitingHandling != 0) &#123;</span><br><span class="line">    if (fTriggersAwaitingHandling == fLastUsedTriggerMask) &#123;</span><br><span class="line">      // Common-case optimization for a single event trigger:</span><br><span class="line">      fTriggersAwaitingHandling &amp;=~ fLastUsedTriggerMask;</span><br><span class="line">      if (fTriggeredEventHandlers[fLastUsedTriggerNum] != NULL) &#123;</span><br><span class="line">    (*fTriggeredEventHandlers[fLastUsedTriggerNum])(fTriggeredEventClientDatas[fLastUsedTriggerNum]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Look for an event trigger that needs handling (making sure that we make forward progress through all possible triggers):</span><br><span class="line">      unsigned i = fLastUsedTriggerNum;</span><br><span class="line">      EventTriggerId mask = fLastUsedTriggerMask;</span><br><span class="line"></span><br><span class="line">      do &#123;</span><br><span class="line">    i = (i+1)%MAX_NUM_EVENT_TRIGGERS;</span><br><span class="line">    mask &gt;&gt;= 1;</span><br><span class="line">    if (mask == 0) mask = 0x80000000;</span><br><span class="line"></span><br><span class="line">    if ((fTriggersAwaitingHandling&amp;mask) != 0) &#123;</span><br><span class="line">      fTriggersAwaitingHandling &amp;=~ mask;</span><br><span class="line">      if (fTriggeredEventHandlers[i] != NULL) &#123;</span><br><span class="line">        (*fTriggeredEventHandlers[i])(fTriggeredEventClientDatas[i]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fLastUsedTriggerMask = mask;</span><br><span class="line">      fLastUsedTriggerNum = i;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">      &#125; while (i != fLastUsedTriggerNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Also handle any delayed event that may have come due.</span><br><span class="line">  fDelayQueue.handleAlarm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++回调函数的实现</title>
      <link href="/2018/12/19/C++/C-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/12/19/C++/C-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在c++中，回调函数是一个非常常用的一种解耦技巧， 实际上通过函数指针作为参数传递给另一个函数，当这个指针被用来调用其指向的函数，回调函数通常在特定的事件或者条件发生时由另外一方调用， 用于对该事件或者条件进行响应</p><h1 id="C-成员函数作为回调函数"><a href="#C-成员函数作为回调函数" class="headerlink" title="C++成员函数作为回调函数"></a>C++成员函数作为回调函数</h1><p>对于非静态成员来说， 默认情况下参数列表都包含this指针，such as ‘void Method:fun(<em>**, Method</em> this)’,C++通过传递一个指向自身的指针给其成员函数从而实现成员函数可以访问C++的数据成员， 由于this指针的作用，使得一个CALLBACK型的成员函数作为回调函数安装就会因为隐含的this指针使得函数参数个数不匹配</p><p>解决方法:</p><ul><li><p>回调函数为普通函数， 在函数体内执行成员函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class MyClass  </span><br><span class="line">&#123;  </span><br><span class="line">    pthread_t TID;  </span><br><span class="line">public:  </span><br><span class="line">    void func()  </span><br><span class="line">    &#123;  </span><br><span class="line">        //子线程执行代码  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    bool startThread()  </span><br><span class="line">    &#123;//启动子线程  </span><br><span class="line">        int ret = pthread_create( &amp;TID , NULL , callback , this );  </span><br><span class="line">        if( ret != 0 )  </span><br><span class="line">            return false;  </span><br><span class="line">        else  </span><br><span class="line">            return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">static void* callback( void* arg )  </span><br><span class="line">&#123;//回调函数  </span><br><span class="line">    ((MyClass*)arg)-&gt;func();调用成员函数  </span><br><span class="line">    return NULL;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    MyClass a;  </span><br><span class="line">    a.startThread();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回调函数为类静态函数， 在内部调用其成员函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class MyClass  </span><br><span class="line">&#123;  </span><br><span class="line">    static MyClass* CurMy;//存储回调函数调用的对象  </span><br><span class="line">    static void* callback(void*);//回调函数  </span><br><span class="line">    pthread_t TID;  </span><br><span class="line">    void func()  </span><br><span class="line">    &#123;  </span><br><span class="line">        //子线程执行代码  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    void setCurMy()  </span><br><span class="line">    &#123;//设置当前对象为回调函数调用的对象  </span><br><span class="line">        CurMy = this;  </span><br><span class="line">    &#125;  </span><br><span class="line">public:  </span><br><span class="line">    bool startThread()  </span><br><span class="line">    &#123;//启动子线程  </span><br><span class="line">        setCurMy();  </span><br><span class="line">        int ret = pthread_create( &amp;TID , NULL , MyClass::callback , NULL );  </span><br><span class="line">        if( ret != 0 )  </span><br><span class="line">            return false;  </span><br><span class="line">        else  </span><br><span class="line">            return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">MyClass* MyClass::CurMy = NULL;  </span><br><span class="line">void* MyClass::callback(void*)  </span><br><span class="line">&#123;  </span><br><span class="line">    CurMy-&gt;func();  </span><br><span class="line">    return NULL;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    MyClass a;  </span><br><span class="line">    a.startThread();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/19/hello-world/"/>
      <url>/2018/12/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github访问提速</title>
      <link href="/2018/12/01/other/github%E8%AE%BF%E9%97%AE%E6%8F%90%E9%80%9F/"/>
      <url>/2018/12/01/other/github%E8%AE%BF%E9%97%AE%E6%8F%90%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>github的CDN被屏蔽，由于网络代理商的原因，所以访问下载很慢。Ping github.com 时，速度只有300多ms。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>绕过dns解析，在本地直接绑定host，该方法也可加速其他因为CDN被屏蔽导致访问慢的网站</p><ul><li>访问ipaddress网站<a href="https://www.ipaddress.com/，查看网站对应的IP地址，输入网址则可查阅到对应的IP地址，这是一个查询域名映射关系的工具" target="_blank" rel="noopener">https://www.ipaddress.com/，查看网站对应的IP地址，输入网址则可查阅到对应的IP地址，这是一个查询域名映射关系的工具</a></li><li>查询 github.global.ssl.fastly.net 和 github.com 两个地址</li><li>将ip和domain name加到/etc/hosts中</li><li>重启网络 /etc/init.d/networking restart</li><li>Done</li></ul>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组地址操作</title>
      <link href="/2018/11/14/other/%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/11/14/other/%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>对指针取址和对数组取地址含义是不同的</p><p>arr和&amp;arr结果都是数组的首地址，但是他们类型不相同</p><p>arr表示&amp;arr[0],即数组首元素取址</p><p>arr+1=首地址+sizeof(char)</p><p>&amp;arr虽值为数组首元素地址，但类型为:类型(*)[数组个数],所以&amp;arr+1=首地址+sizeof(arr)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">char arr[] = &quot;123455678&quot;;</span><br><span class="line"></span><br><span class="line">printf(&quot;arr:%p\n&quot;,arr);</span><br><span class="line">printf(&quot;&amp;arr[0]:%p\n&quot;,&amp;arr[0]);</span><br><span class="line">printf(&quot;arr+1:%p\n&quot;,arr+1);</span><br><span class="line"></span><br><span class="line">char *p = arr;</span><br><span class="line">printf(&quot;p:%p\n&quot;, p); </span><br><span class="line">printf(&quot;&amp;p:%p\n&quot;,&amp;p);</span><br><span class="line">printf(&quot;p+1:%p\n&quot;,p+1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr:0x7ffec43c2e80</span><br><span class="line">&amp;arr[0]:0x7ffec43c2e80</span><br><span class="line">arr+1:0x7ffec43c2e81</span><br><span class="line">p:0x7ffec43c2e80</span><br><span class="line">&amp;p:0x7ffec43c2e78</span><br><span class="line">p+1:0x7ffec43c2e81</span><br></pre></td></tr></table></figure><p>对数组名取地址曾经踩过大坑，如下</p><p>dbus_message_append_args中参数要求传入间接指针，<br>错误用法，对&amp;arr其实类型为char(*)[]，而非char**,导致访问非法内存crash<br>const char arr[] = “Hello World”;<br>dbus_message_append_args (message,<br>                          DBUS_TYPE_INT32, &amp;v_INT32,<br>                          DBUS_TYPE_STRING, &amp;arr,<br>                          DBUS_TYPE_INVALID)</p><p>正确用法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dbus_int32_t v_INT32 = 42;</span><br><span class="line">const char *v_STRING = &quot;Hello World&quot;;</span><br><span class="line">dbus_message_append_args (message,</span><br><span class="line">                          DBUS_TYPE_INT32, &amp;v_INT32,</span><br><span class="line">                          DBUS_TYPE_STRING, &amp;v_STRING,</span><br><span class="line">                          DBUS_TYPE_INVALID);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RTMP</title>
      <link href="/2018/10/13/%E6%B5%81%E5%AA%92%E4%BD%93/RTMP/RTMP/"/>
      <url>/2018/10/13/%E6%B5%81%E5%AA%92%E4%BD%93/RTMP/RTMP/</url>
      
        <content type="html"><![CDATA[<p>从腾讯云中看到一篇对RTMP介绍比较好的文章<br>转自<a href="https://cloud.tencent.com/developer/article/1004970" target="_blank" rel="noopener">视频协议学习：推流拉流都擅长的 RTMP</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RTMP(Real Time Message Protocol)是进行实时通信协议的网络，用于Flash/AIR平台及支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信</p><p>RTMP有多个变种</p><ol><li>RTMP工作在TCP之上，默认使用端口1935；</li><li>RTMPE在RTMP的基础上增加了加密功能；</li><li>RTMPT封装在HTTP请求之上，可穿透防火墙；</li><li>RTMPS类似RTMPT，增加了TLS/SSL的安全功能；</li><li>RTMFP使用UDP进行传输的RTMP</li></ol><p><strong>rtmp协议中基本的数据单元称为消息（Message）。当rtmp协议在互联网中传输数据的时候，消息会被拆分成更小的单元，称为消息块（Chunk）。Rtmp的交互过程可以理解成独有的握手过程、控制命令传输、音视频数据传输</strong></p><h1 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h1><p>RTMP 握手由三个固定长度的块组成，而不是像其他协议一样的带有报头的可变长度的块。客户端 (发起连接请求的终端) 和服务器端各自发送相同的三块。便于演示，当发送自客户端时这些块被指定为 C0、C1 和 C2；当发送自服务器端时这些块分别被指定为 S0、S1 和 S2。以下是握手过程中传递的包格式介绍：</p><p><img src="/2018/10/13/流媒体/RTMP/RTMP/rtmp_handshake_package.png" alt=""></p><p>RTMP握手以客户端发送 C0 和 C1 块开始，客户端必须接收到 S1 才能发送 C2，客户端必须接收到 S2 才能发送任何其他数据，服务器端必须接收到 C0 才能发送 S0 和 S1，也可以等待接收到 C1 再发送 S0 和 S1，服务器端必须接收到 C1 才能发送 S2，服务器端必须接收到 C2 才能发送任何其他数据。以下为RTMP的握手过程图介绍：</p><p><img src="/2018/10/13/流媒体/RTMP/RTMP/rtmp_handshank_process.png" alt=""></p><p>规范要求RTMP需要一个一个的发送握手包，但是实际上客户端发送C0+C1，服务端发送S0+S1+S2，再客户端在发送C2结束握手。</p><h1 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h1><p>RTMP基础数据单位是消息，当RTMP协议在交互过程中，消息会被拆分成更小的单元，称为消息块（Chunk）。</p><p><img src="/2018/10/13/流媒体/RTMP/RTMP/rtmp_chunk.png" alt=""></p><h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>消息头包含以下信息</p><ul><li>MessageType: 消息类型,1Byte</li><li>Length:有效负载字节数,3Byte大端</li><li>Timestamp:时间戳，4Byte大端</li><li>MessageStreamID：消息流ID</li></ul><p><a href="https://blog.csdn.net/defonds/article/details/17534903" target="_blank" rel="noopener">Adobe 官方公布的 RTMP 规范</a></p>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>thinking_in_uml</title>
      <link href="/2018/07/31/%E6%9E%B6%E6%9E%84/thinking-in-uml/"/>
      <url>/2018/07/31/%E6%9E%B6%E6%9E%84/thinking-in-uml/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/shaobing012/p/4914667.html" target="_blank" rel="noopener">比较好的UML类图实例</a></p><p><a href="https://www.cnblogs.com/alex-blog/articles/2704214.html" target="_blank" rel="noopener">UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）</a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象是将世界看成一个个独立的对象， 相互之间没有因果关系。只有在某个外部驱动下，对象之间才会根据某种规律相互传递信息。</p><p>将对客观事物建立一种抽象的方法用以表征事物并获得对事物本身的理解，同时将理解概念化， 将逻辑组织起来构成一种对所观察的对象的内部结构和工作原理的便于理解的表达</p><p>面向对象分析</p><ul><li>一切都是对象</li><li>对象都是独立的</li><li>对象都具有原子性</li><li>对象都是可抽象的</li><li>对象都具有层次性</li></ul><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul><li>类：类是对对象某一方面特征的归纳和抽象，对象则是类实例化的结果</li><li>属性: 对象特征，描述与对象有关的属性的角色，只有对象单独具有的特征才能建模成熟悉，否则应使用与类关联关系或聚合关系对特征进行建模</li><li>方法: 访问对象或者影响其他对象属性或关系的唯一方法，访问和改变对象的属性</li><li>可见性:<ul><li>公有: 属性和方法对其他模型元素可见</li><li>保护: 属性及方法支队类本身，子类及友元可见</li><li>私有: 属性和方法支队类本身和友元可视</li></ul></li></ul><h2 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h2><ul><li>关联 <img src="/2018/07/31/架构/thinking-in-uml/relation.jpg" alt=""></li></ul><p>描述不同类的对象的结构关系，强关联关系。用于定义对象之间静态的、天然的结构。和依赖关系不同，依赖关系表示对象之间临时性的、动态的关系。在最终代码中， 关联对象通常以成员变量的形式表示。与依赖相比，关联的两个对象不会互相直接使用，一般都是由外部对象来访问，例如， 外部访问者可以通过员工对象获得公司的对象。<br>关联关系一般不强调对象， 当A-B时，默认A和B之间相互知道对方的存在，表示对象相互拥有对方的实例变量<br>//单向关联</p><pre><code>class Person{};class Friend{    Person* mpPerson;};//eg.2//双向关联class A;class B{    A* pA;};class A{    B* pB;};//eg.3//自身关联class C{    C* pC;}</code></pre><ul><li>依赖关系 <img src="/2018/07/31/架构/thinking-in-uml/depend.jpg" alt=""></li></ul><p>描述一个对象在运行期会使用到另一个对象的关系，与关联关系不同，依赖关系是一种临时的关系，通常在运行期产生，并且随着场景的不同，依赖关系会发生变化。在代码中一般体现为类的构造方法，类方法的传入参数。依赖关系处理临时知道对方外， 还会使用对方的属性和方法。被依赖的对象改变会导致依赖对象的修改。例如A保存了B对象的实例，但A对象对B对象没有操作，A仅仅是知道B对象，应使用关联关系，并且B修改方法后，A并无变化。如果A对象在某个场景中使用B对象的属性或方法，则B的修改会导致A的修改，这时A依赖于B。</p><pre><code>class Car{};class House{};class Person{    void buy(Car&amp; car){}    void buy(House* pHouse){}};</code></pre><ul><li>实现关系 <img src="/2018/07/31/架构/thinking-in-uml/realize.jpg" alt=""></li></ul><p>指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系</p><pre><code>class FInterface{    virtual void it();};class SC:public FInterface{    void it(){}}</code></pre><ul><li>泛化关系 <img src="/2018/07/31/架构/thinking-in-uml/generalization.jpg" alt=""></li></ul><p>说明两个对象之间的继承关系，表示一个类是另一类的继承，继承而的的类为子类，意味祖先的定义对于后代的对象也是有效的</p><p><code>父类 父类实例＝new 子类();</code></p><ul><li>聚合关系 <img src="/2018/07/31/架构/thinking-in-uml/aggregation.jpg" alt=""></li></ul><p>聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； </p><pre><code>class CPU{};class Memory{};class Computer{    CPU* mpCPU;    Memory* mpMemory;};</code></pre><ul><li>组合关系 <img src="/2018/07/31/架构/thinking-in-uml/composition.jpg" alt=""></li></ul><p>组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分； </p><pre><code>class Leg{};class Arm{};class Person{    Leg mLeg;    Arm mArm;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unsigned关键字</title>
      <link href="/2018/07/14/other/unsigned%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/07/14/other/unsigned%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[转] <a href="https://blog.csdn.net/a997013919/article/details/76684179" target="_blank" rel="noopener">无法忽视的unsigned关键字</a></p></blockquote><h2 id="对unsigned解释"><a href="#对unsigned解释" class="headerlink" title="对unsigned解释"></a>对unsigned解释</h2><p>整型的每一种都分有无符号（unsigned）和有符号（signed）两种类型（float和double总是带符号的），在默认情况下声明的整型变量都是有符号的类型（char有点特别），如果需声明无符号类型的话就需要在类型前加上unsigned。无符号版本和有符号版本的区别就是无符号类型能保存2倍于有符号类型的正整数数据，比如16位系统中一个short能存储的数据的范围为-32768~32767，而unsigned能存储的数据范围则是0~65535。由于在计算机中,整数是以补码形式存放的。根据最高位的不同，如果是1,有符号数的话就是负数；如果是无符号数,则都解释为正数。另外，unsigned若省略后一个关键字，大多数编译器都会认为是unsigned int。</p><pre><code>char c = 0xc9;printf(&quot;A:c = %2x\n&quot;,(unsigned char)c);printf(&quot;B:c = %2x\n&quot;,c &amp; 0xff);printf(&quot;C:c = %2x\n&quot;,c);输出如下：A:c = c9B:c = c9C:c = ffffffc9</code></pre><p>　首先我们必须知道，printf()函数的%x(X)输出的是Int型别的16进制格式。所以char型别的c变量会被转换成Int型别。</p><p>　其次，我们的知道计算机是用补码表示数据的</p><ul><li><p>情况C:</p><p>  　　　c的补码：11001001（0xc9）。</p><p>  　　　c的反码：11001000（0xc9）。</p><p>  　　　c的原码：10110111（0xc9）。　</p><p>  　　　因为char型别是带符号的，所以最高位的1这里视为负号。</p><p>  　　　把c转换成Int型别   char  —–&gt; Int</p><p>  　　　Int_c的原码：10000000 00000000 00000000 00110111（把c原码的最高位1  提到最高位。其余高位补0）。</p><p>  　　　Int_c的反码：11111111 11111111 11111111 11001000</p><p>  　　　Int_c的补码：11111111 11111111 11111111 11001001(0xffffffc9)。</p><p>  　　　所以打印出来看似诡异的值其实是合情合理的。如何避免？看AB情况。</p></li></ul><ul><li><p>情况B:</p><p>  　　我们在情况C的基础上将c与0xff做&amp;操作。</p><p>  　　Int_c的补码：11111111 11111111 11111111 11001001(0xffffffc9)。</p><p>  　　　　　　　　 &amp;</p><p>  　　　　　　　　 00000000 00000000 00000000 11111111</p><p>  　　最终结果为： 00000000 00000000 00000000 11001001(0xc9)。</p></li></ul><ul><li><p>情况A:</p><p>  　　　c的补码：11001001（0xc9）。</p><p>  　　　c的反码：11001001（0xc9）。</p><p>  　　　c的原码：11001001（0xc9）。　</p><p>  　　　这里强制转换c为unsigned char型别。因此最高位的1不是正负号</p><p>  　　　把c转换成Int型别   char  —–&gt; Int</p><p>  　　　Int_c的原码：00000000 00000000 00000000 11001001（把c原码的最高位1  提到最高位。其余高位补0）。</p><p>  　　　Int_c的反码：00000000 00000000 00000000 11001001</p><p>  　　　Int_c的补码：00000000 00000000 00000000 11001001(0xc9)。</p><p>  以32位机为例，int 分为无符号 unsigned 和有符号 signed 两种类型，默认为signed。二者的区别就是无符号类型能保存2倍于有符号类型的数据。32位下，signed int 的表示范围为：-2147483648 ~ 2147483647 (最高位做符号位)。unsigned int 的表示范围为：0 ~ 4294967295 （不保留符号位）。我们都知道，两个不同的数据类型在进行混合使用时，会自动进行类型转换。其转换原则就是：向着精度更高、长度更长的方向转换。也就是我们平常见到的 char 转为 int ，int 转为 long，float 转为 double  . etc.</p></li></ul><p>相关资料:</p><blockquote><p><a href="http://www.cnblogs.com/acool/p/4790069.html" target="_blank" rel="noopener">C语言打印16进制出现0xffffff现象的问题剖析</a></p></blockquote><blockquote><p><a href="http://www.cnblogs.com/acool/p/4790069.html" target="_blank" rel="noopener">unsigned关键字，你真的懂了吗</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI网络模型</title>
      <link href="/2018/06/13/%E7%BD%91%E7%BB%9C/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/06/13/%E7%BD%91%E7%BB%9C/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="OSI网络模型"><a href="#OSI网络模型" class="headerlink" title="OSI网络模型"></a>OSI网络模型</h1><table><thead><tr><th>OSI七层网络模型</th><th>TCP/IP四层模型</th><th>功能</th><th>协议</th><th>数据单位</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>面向用户应用，为用户提供对各种网络资源的方便访问服务</td><td>TFTP、HTTP、SNMP</td><td>消息</td></tr><tr><td>表示层</td><td>-</td><td>对来自应用层的命令和数据进行解析，对各种语法赋予相应的含义，并按照一定的格式传送给会话层</td><td>Telnet、SNMP</td><td>消息</td></tr><tr><td>会话层</td><td>-</td><td>向两个实体提供建立和使用连接的方法</td><td>SMTP、DNS</td><td>消息</td></tr><tr><td>传输层</td><td>传输层</td><td>向用户提供可靠的端到端差错和流量控制，保证报文的正确传输</td><td>TCP UDP</td><td>段segment / 数据包Packet</td></tr><tr><td>网络层</td><td>网络层</td><td>控制数据链路层和传输层之间的信息转发、建立、维持和中指网络连接</td><td>IP 、ICMP、ARP、RARP</td><td>包packet</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>负责建立和管理节点间链路</td><td>Ethernet、Arpanet、PPP</td><td>帧Frame</td></tr><tr><td>物理层</td><td>-</td><td>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输</td><td>IEEE 802.A, IEEE 802.2 -  IEEE 802.11</td><td>比特流Bit</td></tr></tbody></table><p><img src="/2018/06/13/网络/OSI七层模型/osi_model.jpg" alt=""></p><h2 id="数据包说明"><a href="#数据包说明" class="headerlink" title="数据包说明"></a>数据包说明</h2><p><img src="/2018/06/13/网络/OSI七层模型/segment.gif" alt=""></p><p><img src="/2018/06/13/网络/OSI七层模型/segment_flow.jpg" alt=""></p><p>参考</p><blockquote><p><a href="https://zhidao.baidu.com/question/192109576.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/192109576.html</a><br><a href="https://www.cnblogs.com/jeanschen/p/3762475.html" target="_blank" rel="noopener">https://www.cnblogs.com/jeanschen/p/3762475.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2018/05/29/%E7%BD%91%E7%BB%9C/HTTP/"/>
      <url>/2018/05/29/%E7%BD%91%E7%BB%9C/HTTP/</url>
      
        <content type="html"><![CDATA[<p>HTTP报文是面向文本的，每个字段都是ANSII码串，各个字段长度不确定</p><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><ul><li><p>request line</p><p>  由请求方法字段、URL、HTTP协议版本组成，空格分割，例如Get /index/html HTTP/1.1</p><ul><li><p>Get</p><p>  常见的请求模式，当客户端要从服务器中读取文档.Get方法要求服务器将URL定位的资源放到响应报文的数据部分，回送给客户端。请求参数附加在URL后面，？代表URL的结束和请求参数的开始，长度受限制, 一般最多1024byte。/index.jsp?id=100&amp;op=bind</p></li><li><p>POST</p><p>  POST会将请求参数封装到HTTP请求数据中，以名称/值得形式出现,可以传输大量的数据，传送的数据大小没有显示也不会显示在URL</p><pre><code>POST /search HTTP/1.1Accept:image/git,image/x-xbitmap,image/jpeg,image/pjpegReferer:&lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn&lt;/a&gt;Accept-Langel:zh-cnAccept-Encoding:gzip,deflateHost:&lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;Connection:Keep-AliveCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_rhl=zh-CN&amp;source=hp&amp;q=domety</code></pre><p>POST请求行中不包含数据字符串，数据保存在”请求内容部分”，各数据&amp;符号个靠,POST大多用于页面的表单中</p></li><li><p>HEAD</p><p>   类似于GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容，当只需要查看页面状态时,使用HEAD非常高效，省去页面的内容</p></li><li>PUT</li><li>DELETE</li><li>OPTIONS</li><li>TRACE</li><li>CONNECT</li></ul></li><li><p>header 由关键字/值对组成,每行一堆，”:”分隔</p><ul><li>User-Agent:产生请求的浏览器类型</li><li>Accept:客户端可识别的内容类型列表</li><li>Host:请求的主机名</li></ul></li><li><p>blank line</p><p>  每个请求头之间是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p></li><li><p>request body</p><p>  请求数据不再GET中使用，而是在POST方法中使用，适用于需要客户需要填写表单的场合。最常用的请求头是Content-Type和Content-Length。</p></li></ul><h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><pre><code>&lt;status-line&gt;&lt;headers&gt;&lt;blank link&gt;[&lt;response-body&gt;]</code></pre><ul><li><p>状态行</p><p>  格式如下<br>  HTTP-Version Staus-Code Reason-Phrase CRLF</p><ul><li>HTTP-Version表示HTTP协议版本</li><li><p>Status-Code服务器返回的响应状态代码</p><ul><li>1xx:指示消息–表示请求已接收，继续处理</li><li>2xx:成功– 表示请求一杯成功接收、理解、接收</li><li>3xx:重定向–要完成请求必须进行更进一步的操作</li><li>4xx:客户端错误–请求有语法或请求无法实现</li><li>5xx:服务端错误–服务器未能实现合法的请求</li></ul></li><li><p>Reason-Phrase状态代码的文本描述</p><ul><li>200 OK:客户端请求成功</li><li>400 Bad Request:客户端请求有语法错误，不能被服务器所理解</li><li>401 Unathorized:请求未经授权，必须和WWW-Authenticate报头域一起使用</li><li>403 Forbidden:服务器接收到请求，但拒绝提供服务</li><li>404 Not Found:请求资源不存在</li><li>500 Internal Server Error:服务器发布不可预期的错误</li><li>503 Server Unavailable:服务器当前不能处理客户端的请求，一段时间后可能恢复正常，</li></ul></li></ul></li><li><p>消息报头</p></li><li><p>响应正文</p><pre><code>HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122＜html＞＜head＞＜title＞Wrox Homepage＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞</code></pre></li></ul><p>GET及POST区别</p><ul><li><p>GET提交，请求的数据附加在URL之后，以？分割 URL和数据，多个参数&amp;连接，如果是英文字母/数字原样发送，空格转为+，中文或者其他字符使用BASE64加密,例%E4%BD%A0</p></li><li><p>POST提交,把提交的数据放于HTTP包包体中<request-body></request-body></p></li></ul><p>传输数据的大小</p><ul><li><p>HTTP协议没有对传输的数据大小进行限制，HTTP规范也没对URL长度限制,实际开发过程中主要的限制有:</p><ul><li>GET:特定的浏览器及服务器对URL长度限制，例如IE(2K+35)字节。</li><li>POST:由于不是通过URL传值，理论上数据不受限，但各个WEB服务器会规定对POST提交数据大小进行限制</li></ul></li><li><p>安全性</p><p>  POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬坑笔记</title>
      <link href="/2018/05/29/other/%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/29/other/%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="爬坑笔记"><a href="#爬坑笔记" class="headerlink" title="爬坑笔记"></a>爬坑笔记</h1><p>本文对日常工作及学习中遇到的问题做个记录</p><blockquote><p>2018/5/18 1:01:33 </p></blockquote><p>编译QT UI使用QMake实在很方面，不过打算将自己的一系列代码集成到一个project上，所以使用CMake编译，比较曲折</p><h2 id="undefined-reference-vtable-for-VideoDevice"><a href="#undefined-reference-vtable-for-VideoDevice" class="headerlink" title="undefined reference vtable for VideoDevice"></a>undefined reference vtable for VideoDevice</h2><pre><code>class VideoDevice: public QObject{    Q_OBJECTpublic:    explicit VideoDevice(QObject *parent = nullptr);       VideoDevice(QString dev_name);    int open_device();    int close_device();.....</code></pre><p>定义一个类VideoDevice继承于QObject，编译出现cmake error: undefined reference to <code>vtable for VideoDevice&#39;错误， 一般这是虚函数没有提供实现造成的，不过</code>VideoDevice`并不是一个虚函数，所以和这个没有关系，很有可能是Q_OBJECT这个宏造成的，查阅资料说明Q_OBJECT 元对象一般是由moc XXX.cpp生成moc文件实现的，在CMakeList指定了VideoDevice.h 的moc文件， error fix.</p><p><strong>QT5_WRAP_CPP(video_device_moc include/videodevice.h)</strong></p><p>发现的确生成了一个moc文件，此cpp对videodevice.h生成了一些元对象，和信号和槽相关</p><pre><code>QT_BEGIN_MOC_NAMESPACEQT_WARNING_PUSHQT_WARNING_DISABLE_DEPRECATEDstruct qt_meta_stringdata_VideoDevice_t {    QByteArrayData data[4];    char stringdata0[39];};#define QT_MOC_LITERAL(idx, ofs, len) \    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \    qptrdiff(offsetof(qt_meta_stringdata_VideoDevice_t, stringdata0) + ofs \        - idx * sizeof(QByteArrayData)) \    )static const qt_meta_stringdata_VideoDevice_t qt_meta_stringdata_VideoDevice = {    {QT_MOC_LITERAL(0, 0, 11), // &quot;VideoDevice&quot;QT_MOC_LITERAL(1, 12, 13), // &quot;display_error&quot;QT_MOC_LITERAL(2, 26, 0), // &quot;&quot;QT_MOC_LITERAL(3, 27, 11) // &quot;std::string&quot;    },    &quot;VideoDevice\0display_error\0\0std::string&quot;};#undef QT_MOC_LITERALstatic const uint qt_meta_data_VideoDevice[] = { // content:       7,       // revision       0,       // classname       0,    0, // classinfo       1,   14, // methods       0,    0, // properties       0,    0, // enums/sets       0,    0, // constructors       0,       // flags       1,       // signalCount // signals: name, argc, parameters, tag, flags       1,    1,   19,    2, 0x06 /* Public */, // signals: parameters    QMetaType::Void, 0x80000000 | 3,    2,       0        // eod};void VideoDevice::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a){    if (_c == QMetaObject::InvokeMetaMethod) {        VideoDevice *_t = static_cast&lt;VideoDevice *&gt;(_o);        Q_UNUSED(_t)        switch (_id) {        case 0: _t-&gt;display_error((*reinterpret_cast&lt; std::string(*)&gt;(_a[1]))); break;        default: ;        }    } else if (_c == QMetaObject::IndexOfMethod) {        int *result = reinterpret_cast&lt;int *&gt;(_a[0]);        void **func = reinterpret_cast&lt;void **&gt;(_a[1]);        {            typedef void (VideoDevice::*_t)(std::string );            if (*reinterpret_cast&lt;_t *&gt;(func) == static_cast&lt;_t&gt;(&amp;VideoDevice::display_error)) {                *result = 0;                return;            }        }    }}const QMetaObject VideoDevice::staticMetaObject = {    { &amp;QObject::staticMetaObject, qt_meta_stringdata_VideoDevice.data,      qt_meta_data_VideoDevice,  qt_static_metacall, nullptr, nullptr}};const QMetaObject *VideoDevice::metaObject() const{    return QObject::d_ptr-&gt;metaObject ? QObject::d_ptr-&gt;dynamicMetaObject() : &amp;staticMetaObject;}void *VideoDevice::qt_metacast(const char *_clname){    if (!_clname) return nullptr;    if (!strcmp(_clname, qt_meta_stringdata_VideoDevice.stringdata0))        return static_cast&lt;void*&gt;(this);    return QObject::qt_metacast(_clname);}int VideoDevice::qt_metacall(QMetaObject::Call _c, int _id, void **_a){    _id = QObject::qt_metacall(_c, _id, _a);    if (_id &lt; 0)        return _id;    if (_c == QMetaObject::InvokeMetaMethod) {        if (_id &lt; 1)            qt_static_metacall(this, _c, _id, _a);        _id -= 1;    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {        if (_id &lt; 1)            *reinterpret_cast&lt;int*&gt;(_a[0]) = -1;        _id -= 1;    }    return _id;}// SIGNAL 0void VideoDevice::display_error(std::string _t1){    void *_a[] = { nullptr, const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(&amp;_t1)) };    QMetaObject::activate(this, &amp;staticMetaObject, 0, _a);}QT_WARNING_POPQT_END_MOC_NAMESPACE</code></pre><h2 id="lib-x86-64-linux-gnu-libpthread-so-0-1-error-error-adding-symbol"><a href="#lib-x86-64-linux-gnu-libpthread-so-0-1-error-error-adding-symbol" class="headerlink" title="/lib/x86_64-linux-gnu/libpthread.so.0:-1: error: error adding symbol"></a>/lib/x86_64-linux-gnu/libpthread.so.0:-1: error: error adding symbol</h2><p>使用cmake 编译ffmpeg发现 …reference to symbol ‘pthread_create@@GLIBC_2.2.5, 发现是依赖于pthread<br>在连接库中加上-lpthread即可</p><p>fmmpeg库之间有依赖关系，需要按顺序加载lib, make加载顺序为从右向左，故左边的库依赖于右边</p><p>-lavcodec -lavdevice -lavfilter -lavformat -lavutil -lpostproc -lswresample -lswscale -lx264 -lpthread</p><h2 id="关于stm32-freertos异常死机问题"><a href="#关于stm32-freertos异常死机问题" class="headerlink" title="关于stm32 freertos异常死机问题"></a>关于stm32 freertos异常死机问题</h2><blockquote><p>2018/5/22 22:05:01 </p></blockquote><ul><li>MCU: stm32</li><li>OS: FreeRTOS</li><li>问题描述: 最近项目任务，需要利用CMSIS接口对FreeRTOS做了一层封装，以实现多平台抽象，改造运行时很快挂死了。使用JLINK时DEBUG,发现运行时常常在某些函数时挂死，但不常是同一函数，发现通常是在函数退出时挂掉，初步怀疑是栈太小被破坏了，导致函数返回跑偏，栈大小改大同样。继续跟踪发现虽然挂的地点不同，但都进入了同一个函数，DEFAULTXXX, 发现此函数位于启动函数中，如果未设置中断函数，发生中断会自动进入DEFAULTXXX, 可能是我链接时未将中断处理函数链接上，将中断实现函数链接FIX (0.0 醉了，  十足小白)</li></ul><h2 id="FreeRTOS-线程函数问题"><a href="#FreeRTOS-线程函数问题" class="headerlink" title="FreeRTOS 线程函数问题"></a>FreeRTOS 线程函数问题</h2><p>一直在linux环境下工作，对STM32 OVER RTOS不是很熟悉， 利用CMSIS OS over FreeRTOS封装Thread;编写测试用例时发现线程函数直接退出会进入FreeRTOS内部一个函数，Tips要求线程函数一直loop或者退出时调用vTaskDelete（NULL）删除自己。</p><p>查看了一些资料，发现FreeRTOS不能类似于linux线程直接退出处于僵死状态，需要线程内部调用vTaskDelete（NULL）删除自己或者别的线程调用vTaskDelete（thread_id）。 猜测FreeRTOSCreate时是将任务加入到task list,每隔一段时间调用一次，调用vTaskDelete则将任务从task list中移除；  如果函数直接退出但task list还在task list中， 时间片到达时运行task， 函数已经退出可能导致task不知如何运行，被集中运行到了DEFAULT THREAD FUNCTION中了.</p><h2 id="utils-qt-ffmpeg-rtsp-src-mainwindow-ui’-is-not-valid问题"><a href="#utils-qt-ffmpeg-rtsp-src-mainwindow-ui’-is-not-valid问题" class="headerlink" title="utils/qt/ffmpeg_rtsp/src/mainwindow.ui’ is not valid问题"></a>utils/qt/ffmpeg_rtsp/src/mainwindow.ui’ is not valid问题</h2><blockquote><p>2018/5/23 23:00:41 </p></blockquote><ul><li><p>背景: 最近在<a href="https://github.com/CuijianSa/utils" target="_blank" rel="noopener">utils</a>项目中使用ffmpeg+QT+cmake 播放h264视频流, 编译UI时报错</p><pre><code>Generating ui_mainwindow.hFile &apos;/home/cuijian/share/git/utils/qt/ffmpeg_rtsp/src/mainwindow.ui&apos; is not validqt/ffmpeg_rtsp/CMakeFiles/ffmpeg_rtsp_automoc.dir/build.make:57: recipe for target &apos;qt/ffmpeg_rtsp/CMakeFiles/ffmpeg_rtsp_automoc&apos; failedCMakeFiles/Makefile2:615: recipe for target &apos;qt/ffmpeg_rtsp/CMakeFiles/ffmpeg_rtsp_automoc.dir/all&apos; failedAUTOUIC: error: process for ui_mainwindow.h needed by &quot;/home/cuijian/share/git/utils/qt/ffmpeg_rtsp/src/mainwindow.cpp&quot;failed:</code></pre></li><li>思路: 在CMakeLists中已经指定了QT5_WRAP_UI指定了UI文件,QT5_WRAP_UI(ui_mainwindow mainwindow.ui)，编译log却在下级src查询*ui.h文件，和预期不符。然后查询Makefile查看的UI路径，发现路径正常<pre><code>`./qt/ffmpeg_rtsp/CMakeFiles/ffmpeg_rtsp.dir/build.make:    cd /home/cuijian/share/git/build-utils-Desktop_Qt_5_9_2_GCC_64bit-Debug/qt/ffmpeg_rtsp &amp;&amp; /home/cuijian/Qt5.9.2/5.9.2/gcc_64/bin/uic -o /home/cuijian/share/git/build-utils-Desktop_Qt_5_9_2_GCC_64bit-Debug/qt/ffmpeg_rtsp/ui_mainwindow.h /home/cuijian/share/git/utils/qt/ffmpeg_rtsp/mainwindow.ui`</code></pre></li></ul><p>THANK Gooole，遍历了几篇文章找到蛛丝马迹， 因为我mainwindow.cpp是位于src目录下，而编译器也在src下搜寻ui_mainwindow.h，和设置的UI路径不符（实际上ui_mainwindow.h位于CMakeLists同级目录），应该和自动配置有关，查看了CMAKE_UIC命令，尝试把CMAKE_AUTOUIC关闭按照cmake设定的UI编译解决。  阻塞了两晚… </p><h2 id="程序随机挂死问题，DEBUG无异常"><a href="#程序随机挂死问题，DEBUG无异常" class="headerlink" title="程序随机挂死问题，DEBUG无异常"></a>程序随机挂死问题，DEBUG无异常</h2><blockquote><p>2018/5/24 22:34:34 </p></blockquote><p>很简单的一个问题。<br>主要是同事开启了Watchdog, merge代码未喂狗。导致挂死，debug看不出异常… </p><h2 id="吐槽一下ARM-CMSIS—OS接口"><a href="#吐槽一下ARM-CMSIS—OS接口" class="headerlink" title="吐槽一下ARM CMSIS—OS接口"></a>吐槽一下ARM CMSIS—OS接口</h2><blockquote><p>2018/5/29 1:27:39 </p></blockquote><p>最近做使用CMSIS over freertos封装实现项目HAL, 发现不合理的地方</p><ol><li><p>osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)   </p><p> count为semaphore可用资源量， 跟踪代码发现在freertos stm32中其内部实现为count同时被设为最大资源量和初始值。 ===&gt; 无法将初始值设为0(因为count也指定了最大资源)</p></li><li><p>CMSIS_5-develop包中提供了Template， 使用C++对CMSIS_OS进行了一次封装， 不过发现Mutex.cpp没有调用osMutexDelete释放互斥量,会引起资源泄露的问题,其sample如下:</p><pre><code>#include &quot;Mutex.h&quot;#include &lt;string.h&gt;//#include &quot;error.h&quot;namespace rtos {Mutex::Mutex() {#ifdef CMSIS_OS_RTX    memset(_mutex_data, 0, sizeof(_mutex_data));    _osMutexDef.mutex = _mutex_data;#endif    _osMutexId = osMutexCreate(&amp;_osMutexDef);    if (_osMutexId == NULL) {//        error(&quot;Error initializing the mutex object\n&quot;);    }}osStatus Mutex::lock(uint32_t millisec) {    return osMutexWait(_osMutexId, millisec);}bool Mutex::trylock() {    return (osMutexWait(_osMutexId, 0) == osOK);}osStatus Mutex::unlock() {    return osMutexRelease(_osMutexId);}}</code></pre></li></ol><h2 id="undefined-reference-vtable-for"><a href="#undefined-reference-vtable-for" class="headerlink" title="undefined reference vtable for"></a>undefined reference vtable for</h2><blockquote><p>2018/5/30 0:08:23 </p></blockquote><p>C++ 继承基类编译出现undefined reference vtable for XXX,这是由于编译器在子类未发现纯虚函数在子类的实现，虚拟函数table。 在子类实现虚函数即可</p><h1 id="FFmpeg-RTSP-缩放花屏"><a href="#FFmpeg-RTSP-缩放花屏" class="headerlink" title="FFmpeg RTSP 缩放花屏"></a>FFmpeg RTSP 缩放花屏</h1><p>使用开源库ffmpeg播放RTSP(H264=&gt;RGB24), 使用sws_getContext()出现花屏。原因在与缩放后width没有16字节对齐</p><ol><li>将缩放后的宽度16字节对齐</li><li><p>sws_scale时picture.linesize分别设置RGB字节数（缩放后宽度所占BYTE，</p><pre><code>scaleWidth = CELING_2_POWER(width / scale, 16);scaleHeight = CELING_2_POWER(height / scale, 16);pSwsCtx = sws_getContext(width, height, pCodecCtx-&gt;pix_fmt, scaleWidth, scaleHeight, AV_PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);pixbyte = scaleWidth * 3;picture.linesize[0] = picture.linesize[1] = picture.linesize[2] = pixbyte;sws_scale(pSwsCtx, pFrame-&gt;data, pFrame-&gt;linesize, 0, height, picture.data, picture.linesize)</code></pre></li></ol><h1 id="类互相引用导致一方类定义不可达"><a href="#类互相引用导致一方类定义不可达" class="headerlink" title="类互相引用导致一方类定义不可达"></a>类互相引用导致一方类定义不可达</h1><blockquote><p>2018/6/21 23:40:39 </p></blockquote><ol><li>class A 成员函数形参为class B*，这种情景很常见(在另一个类中修改本类的成员变量，或者保存本类的对象指针)，比如观察者模式及状态模式。</li><li>class A及class B都包含宏用于防重复包含，而在类中直接include 对方头文件必会导致有一方类实现不可达</li></ol><p><strong>解决方法:</strong><br>.h中使用class 对方类声明，在.cpp包含对方头文件。.cpp不存在重复包含的问题。程序会在符号表中查找该函数的实现。</p><h1 id="C-构造函数调用虚函数问题"><a href="#C-构造函数调用虚函数问题" class="headerlink" title="C++构造函数调用虚函数问题"></a>C++构造函数调用虚函数问题</h1><blockquote><p>2018/7/4 23:35:59 </p></blockquote><ul><li>问题描述</li></ul><p>class A 继承于class Base,基类和子类构造都调用虚函数Function,实例化class A的对象时，子类和基类的Function都会被调用一遍</p><p>原因:</p><ul><li>在基类子对象构造期间，编译器直接调用基类版本的虚函数。在子类对象构造期间，编译器直接调用基类虚函数的版本。并没有走虚机制。虽然在基类子对象的构造期间，虚表指针指向的是基类的Virtual Table，在进入子类对象构造后，虚表指针指向的是子类对象的Virtual Table</li></ul><p>故以下输出为:</p><p>Base::Fuction<br>A::Fuction </p><pre><code>class Base  {  public:      Base()      {          Fuction();      }      virtual void Fuction()      {          cout &lt;&lt; &quot;Base::Fuction&quot; &lt;&lt; endl;      }  };  class A : public Base  {  public:      A()      {          Fuction();      }      virtual void Fuction()      {          cout &lt;&lt; &quot;A::Fuction&quot; &lt;&lt; endl;      }  };  A a;  </code></pre><p>==&gt;使用多态时， 注意勿在构造函数中调用虚函数， 否则会造成无法执行到子类虚函数，引起异常也不好排查</p><h1 id="ubuntu输入密码后无法进入系统"><a href="#ubuntu输入密码后无法进入系统" class="headerlink" title="ubuntu输入密码后无法进入系统"></a>ubuntu输入密码后无法进入系统</h1><blockquote><p>2018/7/17 0:32:26 </p></blockquote><p>查看~/.xsession-errors，发现dbus未起来导致dbus-deamon异常，unity一个服务termintor.</p><p>最近工作上需要用到dbus, 所以在本机编译dbus源码，并make install安装到系统中,可能破坏掉了原先ubuntu内部的dbus配置。</p><p>手动删除安装的dbus配置， 重启解决。</p><p>教训:以后专门建立一个package防止源码，编译程序时指定package路径，尽量与系统隔离。</p><h1 id="函数返回的string生命周期问题"><a href="#函数返回的string生命周期问题" class="headerlink" title="函数返回的string生命周期问题"></a>函数返回的string生命周期问题</h1><blockquote><p>2018/8/2 23:41:17 </p></blockquote><pre><code>std::string toString(){    return std::string(data);}int iterCalback() {    char *argv[2];    if(cb) {        argv[0] = key.toString().c_str();        argv[1] = value.toString().c_str();        cb(argc, argv);    }}</code></pre><p>示例如上， 获取key及value的字符串常量传递给callback,发现argv[0]及argv[1]同一个地址且指向同一字符串</p><p>原因： 理解错函数返回string生命周期的问题， string_key通过函数返回，toString()执行完毕后，临时变量string其生命周期已经结束， 栈空间将会被收回。执行下一函数获取string_value,将会key复用的占用的空间(不一定同一栈地址)</p><p>note:函数返回的临时变量在函数调用结束时即被销毁。</p><h1 id="对数组名取址"><a href="#对数组名取址" class="headerlink" title="对数组名取址"></a>对数组名取址</h1><blockquote><p>2018/8/13 22:37:29 </p></blockquote><p>数组名的值是个常量，是数组第一个元素的地址，它的数据类型取决于数组的类型。以下为例</p><pre><code>int a[2] = {1,2}printf(&quot;a = %p\n&quot;, a); // Iprintf(&quot;&amp;a = %p\n&quot;, &amp;a); // IIprintf(&quot;a + 1 = %p\n&quot;, a + 1);// IIIprintf(&quot;&amp;a + 1 = %p\n&quot;, &amp;a + 1);// IVa = 0x804a014&amp;a = 0x804a014a + 1 = 0x804a018&amp;a + 1 = 0x804a01c</code></pre><p>对数组名取址=数组第一个元素的地址.<br>今天趟坑，dbus需要传入一个二级指针，自己傻乎乎的直接对数组取值传入，实际上还是首元素的地址。dbus函数内部认为其为二级指针，使用一个变量指向其指向的值， 并将其当做字符串的地址。实际上是把数组的数据当做字符串的地址。导致非法访问core dump</p><h1 id="对隐形调用函数大坑说明"><a href="#对隐形调用函数大坑说明" class="headerlink" title="对隐形调用函数大坑说明"></a>对隐形调用函数大坑说明</h1><blockquote><p>2018/8/17 0:23:04</p></blockquote><p>背景:x86 linux 64位系统<br>proxy接收到message-proxy消息， 进行解析打包传出后总是挂掉。<br>原以为是函数内部拼接字符串错误， 使用log后发现出入参都很正常， 原以为是函数栈被踩导致函数调用结束后跑偏导致core dump, 后来使用log发现程序是可以调用函数返回的， 对返回值打印其地址时发现地址只有4个字节， 而返回值却有8个字节， 其前4个字节时相同的， 也就是表示丢了高4个字节。查看编译Log时发现调用func时将char <em>转为integet.在64位系统中char</em>就是8byte, 而int 为4byte；这段日志提示了我编译器进行了隐藏转换， 后来发现调用库文件没有显式包含函数声明导致编辑器自动默认声明。导致char* =&gt; int， 而对截断后的地址进行访问造成非法访问内存空间crash</p><p>教训:<br>不要放过任何一个warning,为了减少大坑，还是将所有的warning解决</p><p>示例如下:调用函数未现实声明被调用的函数，造成编译器自动声明函数， 其返回值为int,这也是warning说明int数据传给了char*,所以point被截断了<br><code>warning: initialization makes pointer from integer without a cast [-Wint-conversion]</code></p><pre><code> 1 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 #include &lt;string.h&gt; 4  5  6 char *get_msg_id() 7 { 8     char *p = malloc(32); 9     if(p) {10         strcpy(p, &quot;msg_id:32&quot;);11     }12     printf(&quot;%p\n&quot;, p);13     return p;14 } 1 #include &lt;stdio.h&gt; 2  3 int main() 4 { 5     char *p = get_msg_id(); 6     printf(&quot;%p&quot;,p); 7 }</code></pre><h1 id="关于CGO-musllibc问题"><a href="#关于CGO-musllibc问题" class="headerlink" title="关于CGO+musllibc问题"></a>关于CGO+musllibc问题</h1><ul><li>golang github issue:<a href="https://github.com/golang/go/issues/28909" target="_blank" rel="noopener">https://github.com/golang/go/issues/28909</a></li></ul><p>首先简单说明下uclibc、eglibc、glibc及musl-libc区别</p><ol><li><p>Glibc glibc = GNU C Library 是GNU项（GNU Project）目，所实现的 C语言标准库（C standard library）。 目前，常见的桌面和服务器中的GNU/Linux类的系统中，都是用的这套C语言标准库。 其实现了常见的C库的函数，支持很多种系统平台，功能很全，但是也相对比较臃肿和庞大。</p></li><li><p>uClibc 一个小型的C语言标准库，主要用于嵌入式。 其最开始设计用于uClinux（注：uClinux不支持MMU），因此比较适用于微处理器中。 对应的，此处的u意思是μ，Micro，微小的意思。 uClibc的特点：</p><ul><li>uClibc比glibc要小很多。</li><li>uClibc是独立的，为了应用于嵌入式系统中，完全重新实现出来的。和glibc在源码结构和二进制上，都不兼容。</li></ul></li><li><p>EGLIBC EGLIBC = Embedded GLIBC EGLIBC是，（后来）glibc的原创作组织FSF所（新）推出的，glibc的一种变体，目的在于将glibc用于嵌入式系统。 EGLIBC的目标是： </p><ul><li>保持源码和二进制级别的兼容于Glibc 源代码架构和ABI层面兼容 如果真正实现了这个目标，那意味着，你之前用glibc编译的程序，可以直接用eglibc替换，而不需要重新编译。 这样就可以复用之前的很多的程序了。 </li><li>降低(内存)资源占用/消耗</li><li>使更多的模块为可配置的（以实现按需裁剪不需要的模块）</li><li><p>提高对于交叉编译(cross-compilation)和交叉测试(cross-testing)的支持 Eglibc的最主要特点就是可配置，这样对于嵌入式系统中，你所不需要的模块，比如NIS，locale等，就可以裁剪掉，不把其编译到库中，使得降低生成的库的大小了</p><p>更多特点，可以去看：Eglibc的特点 【glibc, uClibc, Elibc的渊源/历史/区别/联系】 </p><ol><li>写程序，需要用到很多c语言的库函数。所有的库函数加起来，就是对应的C语言（标准）函数库。 </li><li>目前在普通GNU/Linux系统中所用的C语言标准库，叫做glibc。其功能很全，函数很多，但是代码太多，编译出来的函数库的大小也很大，即资源占用也很多。</li><li>而嵌入式系统中，也需要C语言写代码实现特定功能，也需要用到C语言函数库，但是由于嵌入式系统中，一般资源比较有限，所以不适合直接使用（太占用资源的）gLibc。 4. 所以有人就又（没有参考glibc，而是从头开始，）重新实现了一个用于嵌入式系统中的，代码量不是很大的，资源占用相对较少的，C语言函数库，叫做uClibc。并且，uClibc不支持MMU（内存管理单元）。 </li><li>而后来，glibc的开发者，又推出个Embedded glibc，简称eglibc，其主要目的也是将glibc用于嵌入式领域。 相应最大的改动就在于，把更多的库函数，改为可配置的，这样，如果你的嵌入式系统中不需要某些函数，就可以裁剪掉，不把该函数编译到你的eglibc库中，使得最终生成的eglibc库的大小变小，最终符合你的嵌入式系统的要求（不能超过一定的大小），这样，就实现了，把glibc引用于嵌入式系统中的目的了。 </li></ol></li></ul></li></ol><pre><code>可以简单的理解为： glibc，uClibc，eglibc都是C语言函数库： 1. uClibc是嵌入式系统中用的，glibc是桌面系统用的  2. eglibc也是嵌入式系统中用的，是glibc的嵌入式版本，和glibc在源码和二进制上兼容。</code></pre><ol start="4"><li>Musl-libc C语言标准库Musl-libc项目发布了1.0版。Musl是一个轻量级的C标准库，设计作为GNU C library (glibc)、 uClibc或Android Bionic的替代用于嵌入式操作系统和移动设备。它遵循POSIX 2008规格和 C99 标准，采用MIT许可证授权，使用Musl的Linux发行版和项目包括sabotage，bootstrap-linux，LightCube OS等等。</li></ol><p>golang + C混编时， cgo依赖于底层c库。cgo在muslibc支持程序不是很好<br>muslibc初始化时为将环境变量写入init_array造成cgo获取argv为空</p><p>解决方法:</p><p>使用patchelf 工具修改已编译运行程序的依赖库位置和指定库链接器</p><ul><li>patchelf –set-rpath</li><li>patchelf –set-interpreter</li></ul>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
