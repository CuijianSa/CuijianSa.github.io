<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>CuijianSa.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="CuijianSa.github.io">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="CuijianSa.github.io">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CuijianSa.github.io">
  
    <link rel="alternate" href="/atom.xml" title="CuijianSa.github.io" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CuijianSa.github.io</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Olin&#39;s blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-linux/linux应用程序加载" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/27/linux/linux应用程序加载/" class="article-date">
  <time datetime="2019-04-27T14:57:42.000Z" itemprop="datePublished">2019-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/27/linux/linux应用程序加载/">linux应用程序加载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">|             APPLICATION                 |</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">---------------------- --------------------         </span><br><span class="line">| libc.so ld-linux.so| | LD_LOADER|libso.z|</span><br><span class="line">---------------------- --------------------</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line">|            LINUX KERNEL                 |</span><br><span class="line">-------------------------------------------</span><br></pre></td></tr></table></figure>
<p>在同一个ARCH Machine, 一个完整的运行库都是可以运行的<br>ld-linux.so和libc.so强关联</p>
<h1 id="静态库搜索路径"><a href="#静态库搜索路径" class="headerlink" title="静态库搜索路径"></a>静态库搜索路径</h1><ul>
<li>gcc先从-L搜索</li>
<li>再从LIBRARY_PATH路径搜索</li>
<li>再从/usr /usr/lib /usr/local/lib. 这是由compile gcc编写在程序中</li>
</ul>
<h1 id="动态库搜索路径"><a href="#动态库搜索路径" class="headerlink" title="动态库搜索路径"></a>动态库搜索路径</h1><ul>
<li>编译目标代码时指定的动态库搜索路径-L</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径/lib /usr/lib/ /usr/local/lib</li>
</ul>
<h1 id="静态链接-编译时"><a href="#静态链接-编译时" class="headerlink" title="静态链接(编译时)"></a>静态链接(编译时)</h1><p>链接器将函数的代码从其所在地（目标文件或静态链接库中）拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码</p>
<p>为创建可执行文件，链接器必须要完成的主要任务：</p>
<ul>
<li>符号解析：把目标文件中符号的定义和引用联系起来</li>
<li>重定位：把符号定义和内存地址对应起来，然后修改所有对符号的引用</li>
</ul>
<h1 id="动态链接-加载、运行时"><a href="#动态链接-加载、运行时" class="headerlink" title="动态链接(加载、运行时)"></a>动态链接(加载、运行时)</h1><p>在此种方式下，函数的定义在动态链接库或共享对象的目标文件中。在编译的链接阶段，动态链接库只提供符号表和其他少量信息用于保证所有符号引用都有定义，保证编译顺利通过。动态链接器(ld-linux.so)链接程序在运行过程中根据记录的共享对象的符号定义来动态加载共享库，然后完成重定位。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码</p>
<h1 id="加载工程"><a href="#加载工程" class="headerlink" title="加载工程"></a>加载工程</h1><p>加载器首先创建如上图所示的内存映像，然后根据段头部表，把目标文件拷贝到内存的数据和代码段中。然后，加载器跳转到程序入口点（即符号_start 的地址），执行启动代码（startup code）</p>
<ul>
<li>AR ：创建静态库，插入、删除、列出和提取成员</li>
<li>STRINGS ：列出目标文件中所有可以打印的字符串</li>
<li>STRIP ：从目标文件中删除符号表信息</li>
<li>NM ：列出目标文件符号表中定义的符号</li>
<li>SIZE ：列出目标文件中节的名字和大小</li>
<li>READELF ：显示一个目标文件的完整结构，包括ELF 头中编码的所有信息</li>
<li>OBJDUMP ：显示目标文件的所有信息，最有用的功能是反汇编.text节中的二进制指令</li>
<li>LDD ：列出可执行文件在运行时需要的共享库</li>
<li>PATCHELF : ELF解析工具</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/27/linux/linux应用程序加载/" data-id="cjuzodosk000410vcaoyhq29y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络/epoll框架" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/网络/epoll框架/" class="article-date">
  <time datetime="2019-04-08T14:25:18.000Z" itemprop="datePublished">2019-04-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/08/网络/epoll框架/">epoll框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The  epoll  API performs a similar task to poll(2): monitoring multiple</span><br><span class="line">       file descriptors to see if I/O is possible on any of them.   The  epoll</span><br><span class="line">       API can be used either as an edge-triggered or a level-triggered inter‐</span><br><span class="line">       face and scales well to large numbers of watched file descriptors.  The</span><br><span class="line">       following  system  calls  are  provided  to  create and manage an epoll</span><br><span class="line">       instance:</span><br><span class="line"></span><br><span class="line">       *  epoll_create(2) creates a new epoll  instance  and  returns  a  file</span><br><span class="line">          descriptor  referring to that instance.  (The more recent epoll_cre‐</span><br><span class="line">          ate1(2) extends the functionality of epoll_create(2).)</span><br><span class="line"></span><br><span class="line">       *  Interest in particular  file  descriptors  is  then  registered  via</span><br><span class="line">          epoll_ctl(2).   The  set of file descriptors currently registered on</span><br><span class="line">          an epoll instance is sometimes called an epoll set.</span><br><span class="line"></span><br><span class="line">       *  epoll_wait(2) waits for I/O events, blocking the calling  thread  if</span><br><span class="line">          no events are currently available.</span><br></pre></td></tr></table></figure>
<h1 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h1><ul>
<li>int epoll_create(int size)<ul>
<li>描述: 创建一个epoll实例，为new epoll实例返回一个文件描述符， 可用close(2)关闭文件描述符</li>
</ul>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data &#123;</span><br><span class="line">       void        *ptr;</span><br><span class="line">       int          fd;</span><br><span class="line">       uint32_t     u32;</span><br><span class="line">       uint64_t     u64;</span><br><span class="line">   &#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">   struct epoll_event &#123;</span><br><span class="line">       uint32_t     events;      /* Epoll events */</span><br><span class="line">       epoll_data_t data;        /* User data variable */</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>op:<ul>
<li>EPOLL_CTL_ADD: Register  the  target  file  descriptor fd on the epoll instance referred to by the file descriptor epfd and associate the  event event with the internal file linked to fd.</li>
<li>EPOLL_CTL_MOD: Change  the event event associated with the target file descriptor fd.</li>
<li>EPOLL_CTL_DEL: Remove (deregister) the target file descriptor fd from the epoll instance  referred  to by epfd.  The event is ignored and can be NULL (but see BUGS below).</li>
</ul>
</li>
<li>event<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
</li>
</ul>
</li>
<li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout):等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
</li>
</ul>
<h1 id="ET、LT工作模式"><a href="#ET、LT工作模式" class="headerlink" title="ET、LT工作模式"></a>ET、LT工作模式</h1><ul>
<li>LT（水平触发）模式下，只要这个文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；</li>
<li>ET（边缘触发）模式下，在它检测到有 I/O 事件时，通过 epoll_wait 调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，如可读，则必须将该文件描述符一直读到空，让 errno 返回 EAGAIN 为止，否则下次的 epoll_wait 不会返回余下的数据，会丢掉事件。如果ET模式不是非阻塞的，那这个一直读或一直写势必会在最后一次阻塞。</li>
</ul>
<p>epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知</p>
<h1 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXLEN 1024</span><br><span class="line">#define MAX_OPEN_FD 1024</span><br><span class="line">#define SERV_PORT 8000</span><br><span class="line"></span><br><span class="line">void setnonblocking(int sock)</span><br><span class="line">&#123;</span><br><span class="line">    int opts;</span><br><span class="line">    opts = fcntl(sock, F_GETFL);</span><br><span class="line">    if (opts &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fcntl(sock,GETFL)&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = opts | O_NONBLOCK;</span><br><span class="line">    if (fcntl(sock, F_SETFL, opts) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fcntl(sock,SETFL,opts)&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int listenfd, connfd, efd;</span><br><span class="line">    char buf[MAXLEN];</span><br><span class="line">    struct sockaddr_in cliaddr, servaddr;</span><br><span class="line">    socklen_t clilen = sizeof(cliaddr);</span><br><span class="line">    struct epoll_event ep[MAX_OPEN_FD], tep;</span><br><span class="line"></span><br><span class="line">    if (-1 == (listenfd = socket(AF_INET, SOCK_STREAM, 0)))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; __LINE__ &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    if (-1 == (bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr))))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; __LINE__ &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(listenfd,20);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(MAX_OPEN_FD);</span><br><span class="line">    tep.events = EPOLLIN;</span><br><span class="line">    tep.data.fd = listenfd;</span><br><span class="line"></span><br><span class="line">    if (-1 == epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; __LINE__ &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t nready = epoll_wait(efd, ep, MAX_OPEN_FD - 1, -1);</span><br><span class="line">        for (unsigned int i = 0; i &lt; nready; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //new client connect</span><br><span class="line">            if (ep[i].data.fd == listenfd)</span><br><span class="line">            &#123;</span><br><span class="line">                connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">                tep.events = EPOLLIN;</span><br><span class="line">                tep.data.fd = connfd;</span><br><span class="line">                if (-1 == epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep))</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; __LINE__ &lt;&lt; strerror(errno) &lt;&lt; endl;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123; //read client dataa</span><br><span class="line">                connfd = ep[i].data.fd;</span><br><span class="line">                int bytes = read(connfd, buf, MAXLEN);</span><br><span class="line">                //peer socket is close</span><br><span class="line">                if (bytes == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    epoll_ctl(efd, EPOLL_CTL_DEL, connfd, NULL);</span><br><span class="line">                    close(connfd);</span><br><span class="line">                    cout &lt;&lt; &quot;client[&quot; &lt;&lt; i &lt;&lt; &quot;] is close&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    for (int j = 0; j &lt; bytes; ++j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        buf[j] = toupper(buf[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // write to client</span><br><span class="line">                    write(connfd, buf, bytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311" target="_blank" rel="noopener">epoll原理详解及epoll反应堆模型</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/08/网络/epoll框架/" data-id="cjuzodotm001p10vcj7vrzatg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编译框架/cmake-基本命令" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/04/编译框架/cmake-基本命令/" class="article-date">
  <time datetime="2019-04-03T16:16:14.000Z" itemprop="datePublished">2019-04-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编译框架/">编译框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/04/编译框架/cmake-基本命令/">cmake-基本命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h1><ul>
<li>指定构建系统生成器: -G<ul>
<li>使用: -G可以指定编译器，当前平台支持的编译器名词可通过cmake –help查看，例如cmake -G “Visual Stdio 15 2017”</li>
</ul>
</li>
<li>CMakeCache.txt<ul>
<li>存放制定工程的设置，比如:变量、选项等</li>
<li>对于同一个变量，如果Cache文件里面有设置，那么CMakeLists文件里就会优先<br>使用Cache文件里面的同名变量。</li>
<li>CMakeLists里面通过设置了一个Cache里面没有的变量，那就将这个变量的值写<br>入到Cache里面</li>
<li>例子：<ul>
<li>SET (var 1024)<br>  //变量var的值被设置成1024，如果变量var在Cache中已经存在，该命令不会覆盖cache里面的值</li>
<li>SET (var 1024 ..CACHE..)//如果var在Cache中存在，就优先使用Cache里面的值，如果不存在，就将该值写<br>入Cache里面</li>
<li>SET (var..CACHE..FORCE)//无论Cache里面是否存在，都始终使用该值</li>
</ul>
</li>
</ul>
</li>
<li>添加变量到Cache文件中:-D<ul>
<li>注意：-D后面不能有空格，例如：cmake -DCMAKE_BUILD_TYPE:STRING=Debug</li>
</ul>
</li>
<li>从Cache文件中删除变量: -U<ul>
<li>从Cache文件中删除变量，支持* 和？通配符</li>
</ul>
</li>
<li>CMake命令行模式: -E<ul>
<li>非平台相关的命令，chdir、copy及copy_if_different等</li>
<li>cmake -E help进行查询</li>
</ul>
</li>
<li>打印运行的每一行CMake<ul>
<li>命令行选项:–trace,打印运行的每一行CMake</li>
<li>命令： –trace-source=”filename”打印有关filenae的执行</li>
</ul>
</li>
<li>设置编译参数<ul>
<li>add_definitions(-DENABLED)</li>
</ul>
</li>
<li>设置默认值命令: option<ul>
<li>设置自定义的宏，option(MY-MESSAGE “this is my message” ON)<ul>
<li>第一项: 默认值名称</li>
<li>第二项: 注释</li>
<li>第三项: 默认值,默认OFF</li>
<li>=== cmake -DMY-MESSAGE=on ../,命令行加D</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="基础简介"><a href="#基础简介" class="headerlink" title="基础简介"></a>基础简介</h1><ul>
<li>指定最低版本:cmake_minimnum_required(VERSION 3.1)</li>
<li>指定版本范围:cmake_minimnum_required(VERSION 3.1…3.12)</li>
<li>设置生成项目名称:project(MyProject)</li>
<li>RROJECT_SOURCE_DIR和CMAKE_SOURCE_DIR都指向工程的根目录</li>
<li>PROJECT_BINARY_DIR和CMAKE_BINARY_DIR都指向target编译的目录</li>
<li>生成可执行文件<ul>
<li>add_executable(exaname srcname)</li>
<li>aux_source_directory(<dir> <variable>)</variable></dir></li>
</ul>
</li>
<li>生成lib<ul>
<li>add_library(libname [SHARED| STATIC|MODULE] [EXCLUDE_FROM_ALL] source1  source2 …sourceN})<ul>
<li>[SHARED | STATIC | MODULE]: (动态库| 静态库| 模块)</li>
<li>[EXCLUDE_FROM_ALL]:该库不会被默认构建</li>
</ul>
</li>
</ul>
</li>
<li>添加头文件目录:<ul>
<li>target_include_directories(<target>[SYSTEM][BEFORE]&lt;INTERFACE|PUBLIC|PRIVATE&gt;[items1..]&lt;INTERFACE|PUBLIC|PRIVATE&gt;[items2..]…)<ul>
<li>target_include_directories(RigelEditor PUBLIC ./include/rgeditor),表示给RigelEditor这个子项目添加一个库文件的路径</li>
</ul>
</target></li>
<li>tinclude_directores([AFTER|BEFORE][SYSTEM] dir1 [dir2…])<ul>
<li>[AFTER|BEFORE]:添加到列表之前后之后</li>
<li>[SYSTEM]:把被包含的路径当作系统包含路径来处理</li>
</ul>
</li>
<li>两条指令的作用都是讲将include的目录添加到目标区别在于include_directories<br>是CMake编译所有目标的目录进行添加，target_include_directories是将<br>CMake编译的指定的特定目标的包含目录进行添加</li>
</ul>
</li>
<li>添加链接的库文件路径<ul>
<li>target_link_libraries(<target>[item1 ] [[debug|optimized|general]<item>]…)<ul>
<li>给目标设置链接设置链接时使用的库</li>
<li>debug：调试</li>
<li>optimized： 所有其他的配置类型</li>
<li>general：所有的配置</li>
</ul>
</item></target></li>
<li>link_libraries:<ul>
<li>给当前工程链接需要的库文件，全路径</li>
</ul>
</li>
</ul>
</li>
<li><p>控制目标的属性</p>
<ul>
<li>target有自己的属性集，如果我们没有显示的设置这些target的属性的话，CMake默认是<br>由相关的全局属性来填充target的属性</li>
<li>命令:set_target_properties(target1 target2 … PROPERTIES 属性名称1 值 属性名称1 值 …)</li>
<li>控制编译选项的属性:COMPILE_FLAGS</li>
<li>控制链接选项的属性:LINK_FLAGS</li>
<li>控制输出路径的属性:EXECUTABLE_OUTPUT_PATH、LIBRARY_OUTPUT_PATH</li>
<li>such as:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(exe</span><br><span class="line">    PROPERTIES</span><br><span class="line">    LINK_FLAGS -satic</span><br><span class="line">    LINK_FLAGS_RELEASE -s)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变量和缓存</p>
<ul>
<li>局部变量:<ul>
<li>CMakeLists.txt相当于一个函数，第一个执行的CMakeLists.txt相当于主函数，正<br>常设置的变量不能跨越CMakeLists.txt文件，相当于局部变量只在当前函数域里<br>面作用一样，</li>
<li>设置变量：set(MY_VARIABLE “value”)</li>
<li>变量的名称通常大写</li>
<li>访问变量：${MY_VARIABLE}</li>
</ul>
</li>
<li>缓存变量:<ul>
<li>cache变量，相当于全局变量，都是在第一个执行的CMakeLists.txt<br>里面被设置的，不过在子项目的CMakeLists.txt文件里面也是可以修改这个变量<br>的，此时会影响父目录的CMakeLists.txt，这些变量用来配置整个工程，配置好<br>之后对整个工程使用</li>
<li>设置缓存变量：set(MY_CACHE_VALUE “cache_value” CACHE INTERNAL<br>“THIS IS MY CACHE VALUE”)</li>
</ul>
</li>
<li>环境变量：<ul>
<li>set(ENV{variable_name} value)</li>
<li>$ENV{varibale_name}</li>
</ul>
</li>
<li>内置变量:<ul>
<li>CMAKE_C_COMPILER:指定C编译器</li>
<li>CMAKE_CXX_COMPILER:指定C++编译器</li>
<li>EXECUTABLE_OUTPUT_PATH:指定可执行文件的存放路径</li>
<li>LIBRARY_OUT_PATH:指定库文件的放置路径</li>
<li>CMAKE_CURRENT_SOURCE_DIR:当前CMakeLists.txt所在的路径</li>
<li>CMAKE_BUILD_TYPE: Debug or Release</li>
<li>CMAKE_SOURCE_DIR: 工程的顶层目录</li>
<li>CMAKE_BINARY_DIR:当前构建的目录</li>
<li>CMAKE_CURRENT_LIST_LINE:内置变量所在的行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="控制语法"><a href="#控制语法" class="headerlink" title="控制语法"></a>控制语法</h1><ul>
<li><p>if</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(expression)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line">else(expression)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">endif(expression)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>基本语法</p>
<ul>
<li>expression: 空、N、NO、OFF、FALSE、NOTFOUND </li>
<li>if(not exp)</li>
<li>if(var1 and var2)</li>
<li>if(var1 or var2)</li>
<li>if(COMMAND cmd)</li>
<li>if(EXISTS dir)</li>
<li>if(EXISTS file)</li>
<li>if(file1 | S_NEWER_THAN file2):当file1比file2新，或file/file2有一个不能存在时为真，文件名需使用全路径</li>
<li>if(IS_DIRECTORY dir)</li>
<li>if(DEFINED var)</li>
<li>if(string MATCHES regex)，匹配正则表达式regex,such as   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF(&quot;hello &quot; MATCHES &quot;ell&quot;)</span><br><span class="line">MESSAGE(&quot;true&quot;)</span><br><span class="line">ENDIF(&quot;hello &quot; MATCHES &quot;ell&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数字表达式</p>
<ul>
<li>if(var LESS number)</li>
<li>if(var GREATER number)</li>
<li>if(var EQUAL number)</li>
</ul>
</li>
<li>字母表顺序<ul>
<li>if(var1 STRLESS var2)</li>
<li>if(var1 STRGREATER var2)</li>
<li>if(var1 STREQUAL var2</li>
</ul>
</li>
</ul>
</li>
<li><p>While</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE(condition)</span><br><span class="line">    COMMAND1(ARGS...)</span><br><span class="line">    COMMAND2(ARGS...)</span><br><span class="line">ENDWHILE(condition)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Foreach</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOREACH(loop_var arg1 arg2)</span><br><span class="line">    COMMAND1(ARGS...)</span><br><span class="line">    COMMAND2(ARGS...)</span><br><span class="line">ENDFOREACH(loop_var)</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏和函数</p>
<ul>
<li><p>宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">macro([arg1 [arg2 [arg3]]])</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">endmacro()</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数(function)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function([arg1 [arg2 [arg3]]])</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">endfunction()</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数和宏的区别还在于，函数很难将计算结果传出来，使用宏就可以将一些值简单的<br>传出来</p>
</li>
<li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    macro(macroTest)</span><br><span class="line">    set(test1 &quot;aaa&quot;)</span><br><span class="line">    endmacro()</span><br><span class="line">    function(funTest)</span><br><span class="line">    set(test2 &quot;bbb&quot;)</span><br><span class="line">    endfunction()</span><br><span class="line">    macroTest()</span><br><span class="line">    message(&quot;$&#123;test1&#125;&quot;)</span><br><span class="line">    funTest()</span><br><span class="line">    message(&quot;$&#123;test2&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    运行上面这个代码，就会显示“aaa”，因为函数里面的test1是局部的，出了这个函</span><br><span class="line">数就出了他的作用域</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对文件的操作</p>
<ul>
<li>file(WRITE filename “message to write” …):WRITE选项会写一条消息到名为filename中，如果文件存在，则会覆<br>盖原文件，如果文件不存在，他将创建该文件</li>
<li>file(APPEND filename “message to write”… )</li>
<li>file(READ filename variable [LIMIT numBytes] [OFFSET offset] [HEX])</li>
<li>file(STRINGS filename variable [LIMIT_COUNT num] [LIMIT_INPUT<br>numBytes] [LIMIT_OUTPUT numBytes] [LENGTH_MINIMUM numBytes]<br>[LENGTH_MAXIMUM numBytes] [NEWLINE_CONSUME] [REGEX regex]<br>[NO_HEX_CONVERSION]</li>
<li>file(GLOB variable [RELATIVE path] [globbing expressions]…)</li>
<li>file(GLOB_RECURSE variable [RELATIVE path] [FOLLOW_SYMLINKS]<br>[globbing expressions]…)</li>
<li>file(REMOVE [file1…])</li>
<li>file(REMOVE_RECURSE [file1…])</li>
<li>file(MAKE_DIIRECOTRY [direcotry1 direcotry2 …])</li>
</ul>
</li>
</ul>
<h1 id="运行其他程序"><a href="#运行其他程序" class="headerlink" title="运行其他程序"></a>运行其他程序</h1><ul>
<li>execute_process<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">execute_process(COMMAND &lt;cmd1&gt; [args1...]]</span><br><span class="line">[COMMAND &lt;cmd2&gt; [args2...] [...]]</span><br><span class="line">[WORKING_DIRECTORY &lt;directory&gt;]</span><br><span class="line">[TIMEOUT &lt;seconds&gt;]</span><br><span class="line">[RESULT_VARIABLE &lt;variable&gt;]</span><br><span class="line">[OUTPUT_VARIABLE &lt;variable&gt;]</span><br><span class="line">[ERROR_VARIABLE &lt;variable&gt;]</span><br><span class="line">[INPUT_FILE &lt;file&gt;]</span><br><span class="line">[OUTPUT_FILE &lt;file&gt;]</span><br><span class="line">[ERROR_FILE &lt;file&gt;]</span><br><span class="line">[OUTPUT_QUIET]</span><br><span class="line">[ERROR_QUIET]</span><br><span class="line">[OUTPUT_STRIP_TRAILING_WHITESPACE]</span><br><span class="line">[ERROR_STRIP_TRAILING_WHITESPACE])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这条指令可以执行系统命令，将输出保存到cmake变量或文件中去，运行<br>一个或多个给定的命令序列，每一个进程的标准输出通过管道流向下一个进程的<br>标准输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set(MAKE_CMD &quot;/src/bin/make.bat&quot;)</span><br><span class="line">MESSAGE(&quot;COMMAND: $&#123;MAKE_CMD&#125;&quot;)</span><br><span class="line">execute_process(COMMAND &quot;$&#123;MAKE_CMD&#125;&quot;</span><br><span class="line">RESULT_VARIABLE CMD_ERROR</span><br><span class="line">OUTPUT_FILE CMD_OUTPUT)</span><br><span class="line">MESSAGE( STATUS &quot;CMD_ERROR:&quot; $&#123;CMD_ERROR&#125;)</span><br><span class="line">MESSAGE( STATUS &quot;CMD_OUTPUT:&quot; $&#123;CMD_OUTPUT&#125;)</span><br><span class="line">输出：</span><br><span class="line">COMMAND:/src/bin/make.bat</span><br><span class="line">CMD_ERROR:No such file or directory</span><br><span class="line">CMD_OUTPUT:</span><br><span class="line">（因为这个路径下面没有这个文件</span><br></pre></td></tr></table></figure>
<ul>
<li><p>构建时的运行命令</p>
<ul>
<li><p>调用python生成头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find_package(PythonInterp REQUIRED)</span><br><span class="line">add_custom_command(OUTPUT</span><br><span class="line">    &quot;#&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp&quot;</span><br><span class="line">    COMMAND &quot;$&#123;PYTHON_EXECUTABLE&#125;&quot;</span><br><span class="line">    &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/scripts/GenerateHeader.py&quot; --argument</span><br><span class="line">    DEPENDS some_target)</span><br><span class="line"></span><br><span class="line">    add_custom_target(generate_header ALL</span><br><span class="line">        DEPNENDS &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Generated.hpp&quot;)</span><br><span class="line">    install(FILES $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/include/Gererated.hpp</span><br><span class="line">    DESTIATION include)</span><br></pre></td></tr></table></figure>
</li>
<li><p>find_package:查找链接库<br>  如果编译的过程使用了外部的库，事先并不知道其头文件和链接库的位置，得在编译命<br>令中加上包含外部库的查找路径，CMake中使用find_package方法</p>
<ul>
<li>find_package()查找***.cmake顺序<ul>
<li>首先查找CMAKE_MODULE_PATH路径</li>
<li>然会会在../.cmake/package或者../user/local/shared/的包路径查找&lt;库大写&gt;Config.cmake或者&lt;库名称小写&gt;-config.cmake</li>
</ul>
</li>
<li><p>**.cmake都会定义下面这些变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NAME&gt;_FOUND</span><br><span class="line">&lt;NAME&gt;_INCLUDE_DIRS or &lt;NAME&gt;_INCLUDES</span><br><span class="line">&lt;NAME&gt;_LIBRAROES or &lt;NAME&gt;_LIBRARIES or &lt;NAME&gt;_LIBS</span><br><span class="line">&lt;NAME&gt;_DEFINITIONS</span><br></pre></td></tr></table></figure>
</li>
<li><p>可通过cmake –help-module-list查看当前CMake中有那些支持的模块</p>
</li>
</ul>
</li>
<li><p>find模块<br>  find_path和find_library查找模块的头文件及库文件，然后将结果放到<name>_INCLUDE_DIR和<name>_LIBRARY</name></name></p>
<ul>
<li>find_path()</li>
<li>find_path(<var> name1[path1 path2 …])        </var></li>
</ul>
</li>
<li><p>add_custom_command:为工程添加一个自定义的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(TARGET target</span><br><span class="line">        PRE_BUILD | PRE_LINK| POST_BUILD</span><br><span class="line">        COMMAND command1[ARGS] [args1...]</span><br><span class="line">        [COMMAND command2[ARGS] [args2...] ...]</span><br><span class="line">        [WORKING_DIRECTORYdir]</span><br><span class="line">        [COMMENT comment][VERBATIM])</span><br></pre></td></tr></table></figure>
<ul>
<li>PRE_BUILD:在其他依赖项执行欠执行</li>
<li>PRE_LINK: 其他依赖项执行完成后执行</li>
<li>POST_BUILD:在目标构建后执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(TARGET $&#123;PROJECT_NAME&#125;</span><br><span class="line">    POST_BUILD</span><br><span class="line">    COMMAND $&#123;CMAKE_COMMAND&#125; -E sleep 5)</span><br><span class="line">add_custom_command(TARGET test_elf</span><br><span class="line">    PRE_BUILD</span><br><span class="line">    COMMAND</span><br><span class="line">    move /cfg/start.o $&#123;CMAKE_BINAARY_DIR&#125;/.)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>add_custom_command: 添加自定义命令产生一个输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(OUTPUT output1 [output2 ...]</span><br><span class="line">    COMMAND command1[ARGS][arg1...]</span><br><span class="line">    [COMMAND command2[ARGS][arg2...]..]</span><br><span class="line">    [MAIN_DEPENDCY depend]</span><br><span class="line">    [DEPENDS[depend...]]</span><br><span class="line">    [IMPLICT_DEPENDS&lt;lang1&gt; depend1 ..]</span><br><span class="line">    [WORKING_DIRECTORY dir]</span><br><span class="line">    [COMMENT comment][VARBARTIM][APPEND])</span><br></pre></td></tr></table></figure>
</li>
<li><p>add_custom_target:增加定制目标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(Name [ALL] [command1 [args1...]]</span><br><span class="line">    [COMMAND command2 [args2...] ...]</span><br><span class="line">    [DEPENDS depend depend depend ... ]</span><br><span class="line">    [BYPRODUCTS [files...]]</span><br><span class="line">    [WORKING_DIRECTORY dir]</span><br><span class="line">    [COMMENT comment]</span><br><span class="line">    [VERBATIM] [USES_TERMINAL]</span><br><span class="line">    [SOURCES src1 [src2...]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>add_custom_command和add_custom_target区别</p>
<ul>
<li>target:add_library或者add_executable生成的exe或者库，具有许多属性集</li>
<li>target：一般来说目标是调用：add_library或者add_executable生成的exe或者库，他们具有许多属性集，这些就是所谓目标，而使用如add_custom_target定义的叫做自定义目标，因此这些“目标”区别于正常的目标，他们不生成exe或者lib，但是仍然会具有一些正常目标相同的属性，构建他们的时候，只是调用了为他们设置的命令，如果自定义目标对于其他目标有依赖，那么就会优先生成依赖的那些目标</li>
</ul>
<ul>
<li>command:自定义命令：自定义命令不是一个“可构建”的对象，并且没有可以设置的属性，自定义命令是一个在构建依赖目标之前被调用的命令，自定义命令的依赖可以通过add_custom_command(TARGET target …)形式显式设置，也可以通过add_custom_command(OUTPUT output1 …)生成文件的形式隐式设置。显示执行的时候，每次构建目标，首先会执行自定义的命令，隐式执行的时候，如果自定义的命令依赖于其他文件，则在构建目标的时候先去执行生成其他文件</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/04/编译框架/cmake-基本命令/" data-id="cjuzodott001y10vcoz39khic" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编译框架/cmake" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/编译框架/cmake/" class="article-date">
  <time datetime="2019-04-01T15:15:04.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编译框架/">编译框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/编译框架/cmake/">cmake-find_package</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h1><h2 id="cmake-find-package基本原理"><a href="#cmake-find-package基本原理" class="headerlink" title="cmake find_package基本原理"></a>cmake find_package基本原理</h2><p>find_package()首先在模块路径中寻找Find.cmake, 一次为${CMAKE_MODULE_PATH}中所有目录，cmake 会将路径赋予相应的变量</p>
<p>以bzip为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#   BZIP2_FOUND - system has BZip2</span><br><span class="line">#   BZIP2_INCLUDE_DIR - the BZip2 include directory</span><br><span class="line">#   BZIP2_LIBRARIES - Link these to use BZip2</span><br><span class="line">#   BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_</span><br><span class="line">#   BZIP2_VERSION_STRING - the version of BZip2 found (since CMake 2.8.8)</span><br><span class="line"></span><br><span class="line">set(_BZIP2_PATHS PATHS</span><br><span class="line">  &quot;[HKEY_LOCAL_MACHINE\\SOFTWARE\\GnuWin32\\Bzip2;InstallPath]&quot;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">find_path(BZIP2_INCLUDE_DIR bzlib.h $&#123;_BZIP2_PATHS&#125; PATH_SUFFIXES include)</span><br><span class="line"></span><br><span class="line">if (NOT BZIP2_LIBRARIES)</span><br><span class="line">    find_library(BZIP2_LIBRARY_RELEASE NAMES bz2 bzip2 $&#123;_BZIP2_PATHS&#125; PATH_SUFFIXES lib)</span><br><span class="line">    find_library(BZIP2_LIBRARY_DEBUG NAMES bz2d bzip2d $&#123;_BZIP2_PATHS&#125; PATH_SUFFIXES lib)</span><br><span class="line"></span><br><span class="line">    include($&#123;CMAKE_CURRENT_LIST_DIR&#125;/SelectLibraryConfigurations.cmake)</span><br><span class="line">    SELECT_LIBRARY_CONFIGURATIONS(BZIP2)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line">if (BZIP2_INCLUDE_DIR AND EXISTS &quot;$&#123;BZIP2_INCLUDE_DIR&#125;/bzlib.h&quot;)</span><br><span class="line">    file(STRINGS &quot;$&#123;BZIP2_INCLUDE_DIR&#125;/bzlib.h&quot; BZLIB_H REGEX &quot;bzip2/libbzip2 version [0-9]+\\.[^ ]+ of [0-9]+ &quot;)</span><br><span class="line">    string(REGEX REPLACE &quot;.* bzip2/libbzip2 version ([0-9]+\\.[^ ]+) of [0-9]+ .*&quot; &quot;\\1&quot; BZIP2_VERSION_STRING &quot;$&#123;BZLIB_H&#125;&quot;)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line">include($&#123;CMAKE_CURRENT_LIST_DIR&#125;/FindPackageHandleStandardArgs.cmake)</span><br><span class="line">FIND_PACKAGE_HANDLE_STANDARD_ARGS(BZip2</span><br><span class="line">                                  REQUIRED_VARS BZIP2_LIBRARIES BZIP2_INCLUDE_DIR</span><br><span class="line">                                  VERSION_VAR BZIP2_VERSION_STRING)</span><br><span class="line"></span><br><span class="line">if (BZIP2_FOUND)</span><br><span class="line">   include($&#123;CMAKE_CURRENT_LIST_DIR&#125;/CheckSymbolExists.cmake)</span><br><span class="line">   include($&#123;CMAKE_CURRENT_LIST_DIR&#125;/CMakePushCheckState.cmake)</span><br><span class="line">   cmake_push_check_state()</span><br><span class="line">   set(CMAKE_REQUIRED_QUIET $&#123;BZip2_FIND_QUIETLY&#125;)</span><br><span class="line">   set(CMAKE_REQUIRED_INCLUDES $&#123;BZIP2_INCLUDE_DIR&#125;)</span><br><span class="line">   set(CMAKE_REQUIRED_LIBRARIES $&#123;BZIP2_LIBRARIES&#125;)</span><br><span class="line">   CHECK_SYMBOL_EXISTS(BZ2_bzCompressInit &quot;bzlib.h&quot; BZIP2_NEED_PREFIX)</span><br><span class="line">   cmake_pop_check_state()</span><br><span class="line"></span><br><span class="line">    if(NOT TARGET BZip2::BZip2)</span><br><span class="line">      add_library(BZip2::BZip2 UNKNOWN IMPORTED)</span><br><span class="line">      set_target_properties(BZip2::BZip2 PROPERTIES</span><br><span class="line">        INTERFACE_INCLUDE_DIRECTORIES &quot;$&#123;BZIP2_INCLUDE_DIRS&#125;&quot;)</span><br><span class="line"></span><br><span class="line">      if(BZIP2_LIBRARY_RELEASE)</span><br><span class="line">        set_property(TARGET BZip2::BZip2 APPEND PROPERTY</span><br><span class="line">          IMPORTED_CONFIGURATIONS RELEASE)</span><br><span class="line">        set_target_properties(BZip2::BZip2 PROPERTIES</span><br><span class="line">          IMPORTED_LOCATION_RELEASE &quot;$&#123;BZIP2_LIBRARY_RELEASE&#125;&quot;)</span><br><span class="line">      endif()</span><br><span class="line"></span><br><span class="line">      if(BZIP2_LIBRARY_DEBUG)</span><br><span class="line">        set_property(TARGET BZip2::BZip2 APPEND PROPERTY</span><br><span class="line">          IMPORTED_CONFIGURATIONS DEBUG)</span><br><span class="line">        set_target_properties(BZip2::BZip2 PROPERTIES</span><br><span class="line">          IMPORTED_LOCATION_DEBUG &quot;$&#123;BZIP2_LIBRARY_DEBUG&#125;&quot;)</span><br><span class="line">      endif()</span><br><span class="line"></span><br><span class="line">      if(NOT BZIP2_LIBRARY_RELEASE AND NOT BZIP2_LIBRARY_DEBUG)</span><br><span class="line">        set_property(TARGET BZip2::BZip2 APPEND PROPERTY</span><br><span class="line">          IMPORTED_LOCATION &quot;$&#123;BZIP2_LIBRARY&#125;&quot;)</span><br><span class="line">      endif()</span><br><span class="line">    endif()</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line">mark_as_advanced(BZIP2_INCLUDE_DIR)</span><br></pre></td></tr></table></figure>
<ul>
<li>安装相应的lib,<code>sudo apt-get install libbz2-dev</code></li>
<li>查看CMake模块<code>cmake --help-module FindBZip2</code></li>
<li><p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line">message($&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_MODULE_PATH /usr/share/cmake-3.10/Modules)</span><br><span class="line">message($&#123;CMAKE_MODULE_PATH&#125;)</span><br><span class="line"></span><br><span class="line">find_package(BZip2)</span><br><span class="line"></span><br><span class="line">if (BZIP2_FOUND)</span><br><span class="line">message($&#123;BZIP2_INCLUDE_DIR&#125;)</span><br><span class="line">message($&#123;BZIP2_LIBRARIES&#125;)</span><br><span class="line">message($&#123;BZIP2_NEED_PREFIX&#125;)</span><br><span class="line">message($&#123;BZIP2_VERSION_STRING&#125;)</span><br><span class="line">endif(BZIP2_FOUND)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/cuijian/do/git/utils/test/cmake_find_package</span><br><span class="line">/usr/share/cmake-3.10/Modules</span><br><span class="line">/usr/include</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libbz2.so</span><br><span class="line">1</span><br><span class="line">1.0.6</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="编写cmake-module"><a href="#编写cmake-module" class="headerlink" title="编写cmake module"></a>编写cmake module</h2><ul>
<li>文件目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── cmake</span><br><span class="line">│   └── FindDEMOLIB.cmake</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── demo.cpp</span><br><span class="line">├── demo.h</span><br><span class="line">└── demo_main.cpp</span><br><span class="line"></span><br><span class="line">1 directory, 5 files</span><br></pre></td></tr></table></figure>
<ul>
<li><p>CMakeLists.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line">message($&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_MODULE_PATH /usr/share/cmake-3.10/Modules)</span><br><span class="line">message(&quot;CMAKE_MODULE_PATH:$&#123;CMAKE_MODULE_PATH&#125;&quot;)</span><br><span class="line"></span><br><span class="line">find_package(BZip2)</span><br><span class="line"></span><br><span class="line">if (BZIP2_FOUND)</span><br><span class="line">message($&#123;BZIP2_INCLUDE_DIR&#125;)</span><br><span class="line">message($&#123;BZIP2_LIBRARIES&#125;)</span><br><span class="line">message($&#123;BZIP2_NEED_PREFIX&#125;)</span><br><span class="line">message($&#123;BZIP2_VERSION_STRING&#125;)</span><br><span class="line">endif(BZIP2_FOUND)</span><br><span class="line"></span><br><span class="line">set(SRC_LIB demo.cpp)</span><br><span class="line">add_library(demolib STATIC $&#123;SRC_LIB&#125;)</span><br><span class="line"></span><br><span class="line">set(DESTINATION $&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">install(TARGETS demolib DESTINATION $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="line">install(FILES demo.h DESTINATION $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)</span><br><span class="line">message(&quot;CMAKE_MODULE_PATH:$&#123;CMAKE_MODULE_PATH&#125;&quot;)</span><br><span class="line">find_package(DEMOLIB)</span><br><span class="line"></span><br><span class="line">if(DEMOLIB_FOUND)</span><br><span class="line">    add_executable(demo_main demo_main.cpp)</span><br><span class="line">    message(&quot;found demo9 $&#123;DEMOLIB_INCLUDE_DIR&#125; $&#123;DEMOLIB_LIBRARY&#125;&quot;)</span><br><span class="line">    include_directories($&#123;DEMOLIB_INCLUDE_DIR&#125;)</span><br><span class="line">    target_link_libraries(demo_main $&#123;DEMOLIB_LIBRARY&#125;)</span><br><span class="line">else()</span><br><span class="line">    message(&quot;not found DEMOLIB&quot;)</span><br><span class="line">endif(DEMOLIB_FOUND)</span><br></pre></td></tr></table></figure>
</li>
<li><p>FindDEMOLIB.cmake</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message(&quot;using FindDEMOLIB.cmake find demolib&quot;)</span><br><span class="line"></span><br><span class="line">FIND_PATH(DEMOLIB_INCLUDE_DIR demo.h $&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line">message(&quot;DEMOLIB_INCLUDE_DIR:$&#123;DEMOLIB_INCLUDE_DIR&#125;&quot;)</span><br><span class="line"></span><br><span class="line">FIND_LIBRARY(DEMOLIB_LIBRARY libdemolib.a $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="line">message(&quot;DEMOLIB_LIBRARY:$&#123;DEMOLIB_LIBRARY&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if(DEMOLIB_INCLUDE_DIR AND DEMOLIB_LIBRARY)</span><br><span class="line">    set(DEMOLIB_FOUND TRUE)</span><br><span class="line">endif(DEMOLIB_INCLUDE_DIR AND DEMOLIB_LIBRARY)</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/编译框架/cmake/" data-id="cjuzodot7001210vckkoq9ny9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C++/类型转换" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/30/C++/类型转换/" class="article-date">
  <time datetime="2019-03-30T15:55:43.000Z" itemprop="datePublished">2019-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/30/C++/类型转换/">类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.cnblogs.com/chenyangchun/p/6795923.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangchun/p/6795923.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/30/C++/类型转换/" data-id="cjuzodosl000510vcjjudarcz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C++/指针详解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/C++/指针详解/" class="article-date">
  <time datetime="2019-03-29T15:18:22.000Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/C++/指针详解/">指针详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常见的指针类型"><a href="#常见的指针类型" class="headerlink" title="常见的指针类型"></a>常见的指针类型</h1><ul>
<li><em>int p</em>: int类型整形变量</li>
<li><em>int </em>p<em>: 指向int类型数据的指针；.p和</em>结合，表明p为指针，指针指向的内容为int类型</li>
<li><em>int p[3]</em>: p为int类型数组组成的数组;p和[]结合标识p是一个数组，然和int结合标识数组元素是整形</li>
<li><em>int </em>p[3]<em>: p为指向int类型指针组成的数组； p和[]结合标识p为数组， 然后和int </em>结合表示数组存储的数据类型为int*类型的指针</li>
<li><em>int (</em>p)[3]<em>: p为指向整型数据组成的数组的指针；p和</em>结合表示p为指针， 然后和[]结合表示表示p指向的是一个数组， 数组存储的值为int类型的数据</li>
<li><em>int **p</em>: 指向指针的指针，二级指针；p和<em>结合表示p为一个指针，然和</em>结合表示p指向的地址存储的值为一个int类型的指针</li>
<li><em>int (</em>p)(int)<em>: p指向有一个整形参数且返回类型为int类型的函数的指针；p和</em>结合表示p为一个指针,然后和()结合表示p指向一个函数，函数入参为int类型，且返回值为int类型</li>
<li><em>int </em>(<em>p(int</em>))[3]<em>: p是一个参数为int类型且返回值指向一个int指针组成的数组的函数;p和()结合表示p是一个函数， 且入参为int</em>, 函数返回一个指针，然后和[]结合表示指针指向一个数组， 数组的返回值为int类型的指针</li>
</ul>
<h1 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value;  </span><br><span class="line">value=array[0]; //也可写成：value=*array;  </span><br><span class="line">value=array[3]; //也可写成：value=*(array+3);  </span><br><span class="line">value=array[4]; //也可写成：value=*(array+4);</span><br></pre></td></tr></table></figure>
<p>int <em>p = array;<br>p + 3 &lt;===&gt; p + 3 </em> sizeof(int)</p>
<p><em>需注意</em><br>int arr[5]<br>对数组名取地址不代表存储数组首地址的指针的地址, arr == &amp;arr, 但他们的类型不一样</p>
<ul>
<li>arr = &amp;arr[0], 类型int *</li>
<li>&amp;arr = 指向整个数组的指针，类型int (*)[5]</li>
</ul>
<p>DBUS_EXPORT dbus_bool_t dbus_message_append_args    (   DBusMessage *   message,<br>int     first_arg_type,<br>    …<br>)<br>曾经在DBus吃过大亏， dbus_message_append_args第三个参数为void **, 传入&amp;arr会造成coredump<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBUS_EXPORT dbus_bool_t dbus_message_append_args    (   DBusMessage *   message,</span><br><span class="line">int     first_arg_type,</span><br><span class="line">    ... </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/C++/指针详解/" data-id="cjuzodosh000210vcka3ejwri" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/多进程线程通信同步总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/linux/多进程线程通信同步总结/" class="article-date">
  <time datetime="2019-03-29T14:23:00.000Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/linux/多进程线程通信同步总结/">多进程线程通信同步总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><ol>
<li>pipe and fifo</li>
</ol>
<ul>
<li>管道（pipe): 具有亲缘关系进程的通信</li>
<li>命名管道(fifo): 支持无亲缘关系进程的通信</li>
</ul>
<ol start="2">
<li>signal</li>
</ol>
<ul>
<li>用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身(signal, sigaction)</li>
</ul>
<ol start="3">
<li>消息队列</li>
</ol>
<ul>
<li>消息的链接表(msgget)有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
</ul>
<ol start="4">
<li>共享内存:</li>
</ol>
<ul>
<li>使多个进程可以访问同一块内存空间，信号量结合使用，来达到进程间的同步及互斥(shmget + shmat)</li>
</ul>
<ol start="5">
<li>信号量:</li>
</ol>
<ul>
<li>主要作为进程间以及同一进程不同线程之间的同步手段(semget + semctl)</li>
</ul>
<ol start="6">
<li>套接字:</li>
</ol>
<ul>
<li>一般的进程间通信机制，可用于不同机器之间的进程间通信(socket)</li>
</ul>
<p>进程有以下几个要素:</p>
<ul>
<li>有一段可执行程序</li>
<li>有专用的堆栈空间</li>
<li>内核有它的控制块，描述进程所占用的资源，这样，进程才能接受内核的调度</li>
<li>具有独立的存储空间</li>
</ul>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p>
<ol>
<li>互斥锁</li>
</ol>
<ul>
<li>互斥量本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量。对互斥量进行枷锁以后，其他视图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变成运行状态的线程可以对互斥量加锁，其他线程就会看到互斥量依然是锁着，只能再次阻塞等待它重新变成可用，这样，一次只有一个线程可以向前执行(pthread_mutex_lock + pthread_mutex_unlock)</li>
<li>死锁：一个线程需要访问两个或者更多不同的共享资源，而每个资源又有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发生死锁。死锁就是指多个线程/进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进<ul>
<li>预防死锁：破坏死锁产生的四个条件：互斥条件、不剥夺条件、请求和保持条件以及循环等待条件</li>
<li>避免死锁：在每次进行资源分配前，应该计算此次分配资源的安全性，如果此次资源分配不会导致系统进入不安全状态，那么将资源分配给进程，否则等待</li>
<li>检测死锁：检测到死锁后通过资源剥夺、撤销进程、进程回退等方法解除死锁</li>
</ul>
</li>
</ul>
<ol start="2">
<li>读写锁</li>
</ol>
<ul>
<li>读写锁有3种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。<br>当读写锁是写加锁状态时，在这个锁被解锁之前，所有视图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止（pthread_rwlock_rdlock+pthread_rwlock_wlock+pthread_rwlock_unlock)</li>
</ul>
<ol start="3">
<li>条件变量</li>
</ol>
<ul>
<li>互斥量用于上锁，条件变量则用于等待，并且条件变量总是需要与互斥量一起使用，运行线程以无竞争的方式等待特定的条件发生。<br>条件变量本身是由互斥量保护的，线程在改变条件变量之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种变化，因为互斥量必须在锁定之后才能计算条件(pthread_condwait+pthread_signal)</li>
</ul>
<ol start="4">
<li>信号量</li>
</ol>
<ul>
<li>信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源(sem_post+sem_wait)</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="互斥-同步"><a href="#互斥-同步" class="headerlink" title="互斥+同步"></a>互斥+同步</h2><ul>
<li>互斥: 某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的</li>
<li>同步：主要是流程上的概念，是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</li>
</ul>
<h2 id="互斥锁-条件变量-信号量"><a href="#互斥锁-条件变量-信号量" class="headerlink" title="互斥锁+条件变量+信号量"></a>互斥锁+条件变量+信号量</h2><ul>
<li>互斥锁：互斥，一个线程占用了某个资源，那么其它的线程就无法访问，直到这个线程解锁，其它线程才可以访问</li>
<li>条件变量：同步，一个线程完成了某一个动作就通过条件变量发送信号告诉别的线程，别的线程再进行某些动作。条件变量必须和互斥锁配合使用</li>
<li>信号量：同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而且信号量有一个更加强大的功能，信号量可以用作为资源计数器，把信号量的值初始化为某个资源当前可用的数量，使用一个之后递减，归还一个之后递增</li>
</ul>
<ol>
<li>信号量可以模拟条件变量，因为条件变量和互斥量配合使用，相当于信号量模拟条件变量和互斥量的组合。在生产者消费者线程池中，生产者生产数据后就会发送一个信号 pthread_cond_signal通知消费者线程，消费者线程通过pthread_cond_wait等待到了信号就可以继续执行。这是用条件变量和互斥锁实现生产者消费者线程的同步，用信号量一样可以实现</li>
<li>信号量可以模拟互斥量，因为互斥量只能为加锁或解锁（0 or 1），信号量值可以为非负整数，也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，就完成一个资源的互斥访问。前面说了，信号量主要用做多线程多任务之间的同步，而同步能够控制线程访问的流程，当信号量为单值时，必须有线程释放，其他线程才能获得，同一个时刻只有一个线程在运行（注意，这个运行不一定是访问资源，可能是计算）。如果线程是在访问资源，就相当于实现了对这个资源的互斥访问</li>
<li>互斥锁是为上锁而优化的；条件变量是为等待而优化的； 信号量既可用于上锁，也可用于等待，因此会有更多的开销和更高的复杂性</li>
<li>互斥锁，条件变量都只用于同一个进程的各线程间，而信号量（有名信号量）可用于不同进程间的同步。当信号量用于进程间同步时，要求信号量建立在共享内存区</li>
<li>互斥量必须由同一线程获取以及释放，信号量和条件变量则可以由一个线程释放，另一个线程得到</li>
<li>信号量的递增和减少会被系统自动记住，系统内部的计数器实现信号量，不必担心丢失，而唤醒一个条件变量时，如果没有相应的线程在等待该条件变量，此次唤醒会被丢失</li>
</ol>
<h1 id="好博文参考"><a href="#好博文参考" class="headerlink" title="好博文参考"></a>好博文参考</h1><ul>
<li><a href="https://blog.csdn.net/wh_sjc/article/details/70283843" target="_blank" rel="noopener">进程间的五种通信方式介绍</a></li>
<li><a href="https://blog.csdn.net/liu5320102/article/details/50764645" target="_blank" rel="noopener">线程间的通信、同步方式与进程间通信方式</a></li>
<li><a href="https://blog.csdn.net/a987073381/article/details/52029070" target="_blank" rel="noopener">linux线程间通信及同步机制总结</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/linux/多进程线程通信同步总结/" data-id="cjuzodosu000e10vcnoacfiyq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/多线程调试" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/linux/多线程调试/" class="article-date">
  <time datetime="2019-03-20T15:31:09.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/linux/多线程调试/">多线程调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol>
<li>gdb attach $PID:attach 进程</li>
<li>info threads: 显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    Id   Target Id         Frame </span><br><span class="line">* 1    Thread 0x7f8ef79ec740 (LWP 3994) &quot;thread_demo&quot; 0x00007f8ef75d1d2d in __GI___pthread_timedjoin_ex (threadid=140251998291712, thread_return=0x0, </span><br><span class="line">    abstime=0x0, block=&lt;optimized out&gt;) at pthread_join_common.c:89</span><br><span class="line">  2    Thread 0x7f8ef6898700 (LWP 3995) &quot;thread_demo&quot; 0x00007f8ef6f339d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f8ef6897ea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef6897ea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">  3    Thread 0x7f8ef6097700 (LWP 3996) &quot;thread_demo&quot; 0x00007f8ef6f339d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f8ef6096ea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef6096ea0)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>thread ID:切换当前调试的线程为指定ID的线程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Switching to thread 1 (Thread 0x7f8ef79ec740 (LWP 3994))]</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>打印堆栈信息: thread apply all bt</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hread 11 (Thread 0x7f8ef208f700 (LWP 4004)):</span><br><span class="line">#0  0x00007f8ef6f339d0 in __GI___nanosleep (</span><br><span class="line">    requested_time=requested_time@entry=0x7f8ef208eea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef208eea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">#1  0x00007f8ef6f338aa in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55</span><br><span class="line">#2  0x00005580971cdaa2 in thread_route (arg=0x0) at thread_demo.cpp:10</span><br><span class="line">#3  0x00007f8ef75d06db in start_thread (arg=0x7f8ef208f700)</span><br><span class="line">    at pthread_create.c:463</span><br><span class="line">#4  0x00007f8ef6f7088f in clone ()</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br><span class="line"></span><br><span class="line">Thread 10 (Thread 0x7f8ef2890700 (LWP 4003)):</span><br><span class="line">#0  0x00007f8ef6f339d0 in __GI___nanosleep (</span><br><span class="line">    requested_time=requested_time@entry=0x7f8ef288fea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef288fea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">#1  0x00007f8ef6f338aa in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55</span><br><span class="line">#2  0x00005580971cdaa2 in thread_route (arg=0x0) at thread_demo.cpp:10</span><br><span class="line">#3  0x00007f8ef75d06db in start_thread (arg=0x7f8ef2890700)</span><br><span class="line">    at pthread_create.c:463</span><br><span class="line">#4  0x00007f8ef6f7088f in clone ()</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>Thread apply ID1 ID2:让一个或者多个线程执行command命令</li>
<li>Set scheduler-locking off|on|step<ul>
<li>设置locking scheduler模式<ul>
<li>ON：只有当前线程运行</li>
<li>Off：所有线程都会运行</li>
<li>Step：当执行step操作时只有当前线程会运行，执行continue所有线程都会运行<ol start="7">
<li>ps aux | grep thread_demo:查看当前运行的经常</li>
<li>ps -aL | grep thread_demo:查看当前运行的轻量级进程</li>
<li>pstree -p 主线程ID:查看线程关系</li>
<li>查看线程栈结构: ps stack 线程ID</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void *thread_route(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    sleep(random());</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    pthread_t threadID[10];</span><br><span class="line">    cout&lt;&lt;&quot;pthread runing&quot;&lt;&lt;endl;</span><br><span class="line">    for(i = 0; i &lt; sizeof(threadID) / sizeof(threadID[0]); i++) &#123;</span><br><span class="line">        pthread_create(&amp;threadID[i], NULL, thread_route, NULL);</span><br><span class="line">    &#125;   </span><br><span class="line">    for(i = 0; i &lt; sizeof(threadID) / sizeof(threadID[0]); i++) &#123;</span><br><span class="line"></span><br><span class="line">        pthread_join(threadID[i], NULL);</span><br><span class="line">    &#125;   </span><br><span class="line">    cout&lt;&lt;&quot;pthread end&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/linux/多线程调试/" data-id="cjuzodosr000910vc930w8zdq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SQL/SQL语句" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/10/SQL/SQL语句/" class="article-date">
  <time datetime="2019-03-10T08:06:36.000Z" itemprop="datePublished">2019-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SQL/">SQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/10/SQL/SQL语句/">SQL语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table>
<thead>
<tr>
<th>存储类</th>
<th>Describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>NULL值</td>
</tr>
<tr>
<td>INTEGER</td>
<td>带符号整数，size=1,2,3,4,6 or 8</td>
</tr>
<tr>
<td>REAL</td>
<td>浮点值,size=8的IEEE浮点数字</td>
</tr>
<tr>
<td>TEXT</td>
<td>文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>blob数据， 类型由输入存储</td>
</tr>
</tbody>
</table>
<h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE if not exists database_name.table_name(</span><br><span class="line">   column1 datatype  PRIMARY KEY(one or more columns),</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE database_name.table_name;</span><br></pre></td></tr></table></figure>
<h1 id="插入表"><a href="#插入表" class="headerlink" title="插入表"></a>插入表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME(column1, column2, ... columnN)</span><br><span class="line">VALUES (value1, value2, ... valueN)</span><br></pre></td></tr></table></figure>
<h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name;</span><br></pre></td></tr></table></figure>
<h1 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h1><p>可应用于SELCT、UPDATE、DELETE,用来过滤记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name</span><br><span class="line">WHERE[CONDITION | EXPRESSION];</span><br></pre></td></tr></table></figure>
<h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">set column1=value1, column2=value2...., columnN=valueN</span><br><span class="line">where[CONDITION];</span><br></pre></td></tr></table></figure>
<h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE[CONDITION];</span><br></pre></td></tr></table></figure>
<h1 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h1><p>LINK匹配通配符</p>
<ul>
<li>%：表示0、1或者多个数字或字符</li>
<li>_：表示单一的数字或字符</li>
</ul>
<p>such as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET column_list FROM table_name</span><br><span class="line">where column LIKE &apos;xxx%&apos;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Glob"><a href="#Glob" class="headerlink" title="Glob"></a>Glob</h1><p>Glob匹配通配符， 大小敏感</p>
<ul>
<li>*：表示0、1或者多个数字或字符</li>
<li>?： 表示单一的数字或字符</li>
</ul>
<h1 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h1><p>Limit限制SELECT 返回的数据量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cloumn1, column2 ...</span><br><span class="line">FROM table_name</span><br><span class="line">LIMIT [no of rows]</span><br><span class="line"></span><br><span class="line">such as:</span><br><span class="line">SELECT * FROM COMPANY LIMIT 3 OFFSET 2;</span><br></pre></td></tr></table></figure>
<h1 id="Order-By"><a href="#Order-By" class="headerlink" title="Order By"></a>Order By</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE condition]</span><br><span class="line">[ORDER BY column1, coulum2, ...][ASC|DESC];</span><br></pre></td></tr></table></figure>
<h1 id="Group-By"><a href="#Group-By" class="headerlink" title="Group By"></a>Group By</h1><p>SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。<br>在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE[conditions]</span><br><span class="line">GROUP BY column1, ....</span><br><span class="line">ORDER BY column1,....;</span><br></pre></td></tr></table></figure>
<h1 id="Having-子句"><a href="#Having-子句" class="headerlink" title="Having 子句"></a>Having 子句</h1><p>Having子句允许指定条件来过滤将出现在最终结果的分组<br>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br><span class="line"></span><br><span class="line">such as:</span><br><span class="line">SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2;</span><br></pre></td></tr></table></figure>
<h1 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h1><p>DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。</p>
<p>有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul>
<li>NOT NULL: 确保某列不能为NULL</li>
<li>DEFAULT: 当莫列没有指定值时， 为该列提供默认值</li>
<li>UNIQUE: 确保某列的所有值不同</li>
<li>PRIMARY Key: 为一标识数据库表的各行和数据</li>
<li>CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件</li>
</ul>
<h1 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h1><p>SQLite 的 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段</p>
<ul>
<li>交叉连接 - CROSS JOIN</li>
<li>内连接 - INNER JOIN</li>
<li>外连接 - OUTER JOIN</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/10/SQL/SQL语句/" data-id="cjuzodoso000610vcot4vu46m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-other/getaddrinfo爬坑" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/21/other/getaddrinfo爬坑/" class="article-date">
  <time datetime="2019-02-21T14:49:41.000Z" itemprop="datePublished">2019-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/21/other/getaddrinfo爬坑/">getaddrinfo爬坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近发现了客户一个问题， LE程序自启动一直连接不上服务端， 重启程序后成功</p>
<p>查看日志， getaddrinfo一直打印Tempoary failed in name soluation</p>
<p>开机时由systemd拉起程序, 此时网络服务并没有初始化成功， 此时连接失败时符合预期的， 间隔一段时间后， 发现还一直报域名服务失败</p>
<ol>
<li>此时采用ping 服务器域名， 发现网络正常</li>
<li>编写demo, 手动执行发现可以正常获取域名</li>
</ol>
<p>一开始被getaddrinfo文档误导了,一开始也考虑过缓存的问题，但getaddrinfow文档显示为MT-safe， 就首先排除这个选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────┬───────────────┬────────────────────┐</span><br><span class="line">│Interface       │ Attribute     │ Value              │</span><br><span class="line">├────────────────┼───────────────┼────────────────────┤</span><br><span class="line">│getaddrinfo()   │ Thread safety │ MT-Safe env locale │</span><br><span class="line">├────────────────┼───────────────┼────────────────────┤</span><br><span class="line">│freeaddrinfo(), │ Thread safety │ MT-Safe            │</span><br><span class="line">│gai_strerror()  │               │                    │</span><br><span class="line">└────────────────┴───────────────┴────────────────────┘</span><br></pre></td></tr></table></figure>
<p>后期发现DNS做了一次缓存…….</p>
<p>在使用 getaddrinfo 函数的时候，实际会使用 glibc 的相关函数，glibc 在应用第一次域名解析的时候会触发 res_init() 函数的调用，res_init() 函数的作用是读取 /etc/resolv.conf 的内容, 如 nameserver 地址、负载均衡策略、重试次数、超时时间等，并将读取的这些数据放到 static 类型的 <em>res</em> 结构体中。</p>
<p>由于 Linux 的进程在使用 glibc 动态链接库全局静态变量的时候，都会在用户进程空间生成自己独立的变量副本（感兴趣的同学可以查看每个进程的 smaps 文件，glibc 在每个用户进程空间都有可读、可写的 segment），所以每个发起 DNS 解析的进程都具有独立的 <em>res</em> 结构体变量。</p>
<p>回到 salt-minio 这个具体案例，salt-minion 进程启动后发起第一次域名解析请求，该请求最后会调用底层的 res_query，第一次 res_query 会调用 res_init()，res_init() 初始化后，nameserver 地址被初始化到当前进程的 <em>res</em> 结构体中， 然而 res_init() 对于每个进程来说，只会执行一次。</p>
<p>运维同学在用户进程运行的时候修改掉 /etc/resolv.conf 中的配置，但修改配置后无法生效的根本原因就在此（因为用户进程空间的 _res 结构体中仍然存放的是老的 nameserver 配置）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The functions described below make queriesto and interpret the responses from Internet domain name servers.The API consists of a set of more modern, reentrant functions and an older set of nonreentrant functions that have been superseded. The traditional resolver interfaces such as res_init() and res_query() use some static (global) state stored in the _res structure, rendering these functions non-thread-safe. BIND 8.2 introduced a set of new interfaces res_ninit(), res_nquery(), and so on, which take a res_state as their first argument, so you can use a per-thread</span><br><span class="line"></span><br><span class="line">resolver state.The res_ninit() and res_init() functions read the configuration files (see resolv.conf(5)) to get the default domain name and name server address(es).If no server isgiven, the local host is tried. If no domain is given, that associated with thelocal host is used. It can be overridden with the environment variable LOCALDOMAIN. res_ninit() or res_init() is normally executed by the first call to one of the other functions.</span><br></pre></td></tr></table></figure>
<p>解决方法:</p>
<ol>
<li>用户进程直接调用底层的接口，并且定期调用 res_init() 以防止 /etc/resolov.conf 文件被修改而无法感知(有一定的实现成本)。</li>
<li>直接重启用户进程，使用户进程在做第一次域名解析的时候触发 res_init()</li>
<li>用户进程实现 DNS 的 client 全部功能</li>
<li>通过非常规手段修改用户进程空间的数据</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/21/other/getaddrinfo爬坑/" data-id="cjuzodosv000h10vcjxvq4mz1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/流媒体/">流媒体</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编译框架/">编译框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/27/linux/linux应用程序加载/">linux应用程序加载</a>
          </li>
        
          <li>
            <a href="/2019/04/08/网络/epoll框架/">epoll框架</a>
          </li>
        
          <li>
            <a href="/2019/04/04/编译框架/cmake-基本命令/">cmake-基本命令</a>
          </li>
        
          <li>
            <a href="/2019/04/01/编译框架/cmake/">cmake-find_package</a>
          </li>
        
          <li>
            <a href="/2019/03/30/C++/类型转换/">类型转换</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Jian.Cui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>