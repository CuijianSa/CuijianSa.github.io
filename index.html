<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>CuijianSa.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="CuijianSa.github.io">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="CuijianSa.github.io">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CuijianSa.github.io">
  
    <link rel="alternate" href="/atom.xml" title="CuijianSa.github.io" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CuijianSa.github.io</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Olin&#39;s blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-C++/指针详解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/C++/指针详解/" class="article-date">
  <time datetime="2019-03-29T15:18:22.000Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/C++/指针详解/">指针详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常见的指针类型"><a href="#常见的指针类型" class="headerlink" title="常见的指针类型"></a>常见的指针类型</h1><ul>
<li><em>int p</em>: int类型整形变量</li>
<li><em>int </em>p<em>: 指向int类型数据的指针；.p和</em>结合，表明p为指针，指针指向的内容为int类型</li>
<li><em>int p[3]</em>: p为int类型数组组成的数组;p和[]结合标识p是一个数组，然和int结合标识数组元素是整形</li>
<li><em>int </em>p[3]<em>: p为指向int类型指针组成的数组； p和[]结合标识p为数组， 然后和int </em>结合表示数组存储的数据类型为int*类型的指针</li>
<li><em>int (</em>p)[3]<em>: p为指向整型数据组成的数组的指针；p和</em>结合表示p为指针， 然后和[]结合表示表示p指向的是一个数组， 数组存储的值为int类型的数据</li>
<li><em>int **p</em>: 指向指针的指针，二级指针；p和<em>结合表示p为一个指针，然和</em>结合表示p指向的地址存储的值为一个int类型的指针</li>
<li><em>int (</em>p)(int)<em>: p指向有一个整形参数且返回类型为int类型的函数的指针；p和</em>结合表示p为一个指针,然后和()结合表示p指向一个函数，函数入参为int类型，且返回值为int类型</li>
<li><em>int </em>(<em>p(int</em>))[3]<em>: p是一个参数为int类型且返回值指向一个int指针组成的数组的函数;p和()结合表示p是一个函数， 且入参为int</em>, 函数返回一个指针，然后和[]结合表示指针指向一个数组， 数组的返回值为int类型的指针</li>
</ul>
<h1 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value;  </span><br><span class="line">value=array[0]; //也可写成：value=*array;  </span><br><span class="line">value=array[3]; //也可写成：value=*(array+3);  </span><br><span class="line">value=array[4]; //也可写成：value=*(array+4);</span><br></pre></td></tr></table></figure>
<p>int <em>p = array;<br>p + 3 &lt;===&gt; p + 3 </em> sizeof(int)</p>
<p><em>需注意</em><br>int arr[5]<br>对数组名取地址不代表存储数组首地址的指针的地址, arr == &amp;arr, 但他们的类型不一样</p>
<ul>
<li>arr = &amp;arr[0], 类型int *</li>
<li>&amp;arr = 指向整个数组的指针，类型int (*)[5]</li>
</ul>
<p>DBUS_EXPORT dbus_bool_t dbus_message_append_args    (   DBusMessage *   message,<br>int     first_arg_type,<br>    …<br>)<br>曾经在DBus吃过大亏， dbus_message_append_args第三个参数为void **, 传入&amp;arr会造成coredump<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBUS_EXPORT dbus_bool_t dbus_message_append_args    (   DBusMessage *   message,</span><br><span class="line">int     first_arg_type,</span><br><span class="line">    ... </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/C++/指针详解/" data-id="cjtu8agal00050svcilbu3vfm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/多进程线程通信同步总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/linux/多进程线程通信同步总结/" class="article-date">
  <time datetime="2019-03-29T14:23:00.000Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/linux/多进程线程通信同步总结/">多进程线程通信同步总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><ol>
<li>pipe and fifo</li>
</ol>
<ul>
<li>管道（pipe): 具有亲缘关系进程的通信</li>
<li>命名管道(fifo): 支持无亲缘关系进程的通信</li>
</ul>
<ol start="2">
<li>signal</li>
</ol>
<ul>
<li>用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身(signal, sigaction)</li>
</ul>
<ol start="3">
<li>消息队列</li>
</ol>
<ul>
<li>消息的链接表(msgget)有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
</ul>
<ol start="4">
<li>共享内存:</li>
</ol>
<ul>
<li>使多个进程可以访问同一块内存空间，信号量结合使用，来达到进程间的同步及互斥(shmget + shmat)</li>
</ul>
<ol start="5">
<li>信号量:</li>
</ol>
<ul>
<li>主要作为进程间以及同一进程不同线程之间的同步手段(semget + semctl)</li>
</ul>
<ol start="6">
<li>套接字:</li>
</ol>
<ul>
<li>一般的进程间通信机制，可用于不同机器之间的进程间通信(socket)</li>
</ul>
<p>进程有以下几个要素:</p>
<ul>
<li>有一段可执行程序</li>
<li>有专用的堆栈空间</li>
<li>内核有它的控制块，描述进程所占用的资源，这样，进程才能接受内核的调度</li>
<li>具有独立的存储空间</li>
</ul>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p>
<ol>
<li>互斥锁</li>
</ol>
<ul>
<li>互斥量本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量。对互斥量进行枷锁以后，其他视图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变成运行状态的线程可以对互斥量加锁，其他线程就会看到互斥量依然是锁着，只能再次阻塞等待它重新变成可用，这样，一次只有一个线程可以向前执行(pthread_mutex_lock + pthread_mutex_unlock)</li>
<li>死锁：一个线程需要访问两个或者更多不同的共享资源，而每个资源又有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发生死锁。死锁就是指多个线程/进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进<ul>
<li>预防死锁：破坏死锁产生的四个条件：互斥条件、不剥夺条件、请求和保持条件以及循环等待条件</li>
<li>避免死锁：在每次进行资源分配前，应该计算此次分配资源的安全性，如果此次资源分配不会导致系统进入不安全状态，那么将资源分配给进程，否则等待</li>
<li>检测死锁：检测到死锁后通过资源剥夺、撤销进程、进程回退等方法解除死锁</li>
</ul>
</li>
</ul>
<ol start="2">
<li>读写锁</li>
</ol>
<ul>
<li>读写锁有3种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。<br>当读写锁是写加锁状态时，在这个锁被解锁之前，所有视图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止（pthread_rwlock_rdlock+pthread_rwlock_wlock+pthread_rwlock_unlock)</li>
</ul>
<ol start="3">
<li>条件变量</li>
</ol>
<ul>
<li>互斥量用于上锁，条件变量则用于等待，并且条件变量总是需要与互斥量一起使用，运行线程以无竞争的方式等待特定的条件发生。<br>条件变量本身是由互斥量保护的，线程在改变条件变量之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种变化，因为互斥量必须在锁定之后才能计算条件(pthread_condwait+pthread_signal)</li>
</ul>
<ol start="4">
<li>信号量</li>
</ol>
<ul>
<li>信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源(sem_post+sem_wait)</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="互斥-同步"><a href="#互斥-同步" class="headerlink" title="互斥+同步"></a>互斥+同步</h2><ul>
<li>互斥: 某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的</li>
<li>同步：主要是流程上的概念，是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</li>
</ul>
<h2 id="互斥锁-条件变量-信号量"><a href="#互斥锁-条件变量-信号量" class="headerlink" title="互斥锁+条件变量+信号量"></a>互斥锁+条件变量+信号量</h2><ul>
<li>互斥锁：互斥，一个线程占用了某个资源，那么其它的线程就无法访问，直到这个线程解锁，其它线程才可以访问</li>
<li>条件变量：同步，一个线程完成了某一个动作就通过条件变量发送信号告诉别的线程，别的线程再进行某些动作。条件变量必须和互斥锁配合使用</li>
<li>信号量：同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而且信号量有一个更加强大的功能，信号量可以用作为资源计数器，把信号量的值初始化为某个资源当前可用的数量，使用一个之后递减，归还一个之后递增</li>
</ul>
<ol>
<li>信号量可以模拟条件变量，因为条件变量和互斥量配合使用，相当于信号量模拟条件变量和互斥量的组合。在生产者消费者线程池中，生产者生产数据后就会发送一个信号 pthread_cond_signal通知消费者线程，消费者线程通过pthread_cond_wait等待到了信号就可以继续执行。这是用条件变量和互斥锁实现生产者消费者线程的同步，用信号量一样可以实现</li>
<li>信号量可以模拟互斥量，因为互斥量只能为加锁或解锁（0 or 1），信号量值可以为非负整数，也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，就完成一个资源的互斥访问。前面说了，信号量主要用做多线程多任务之间的同步，而同步能够控制线程访问的流程，当信号量为单值时，必须有线程释放，其他线程才能获得，同一个时刻只有一个线程在运行（注意，这个运行不一定是访问资源，可能是计算）。如果线程是在访问资源，就相当于实现了对这个资源的互斥访问</li>
<li>互斥锁是为上锁而优化的；条件变量是为等待而优化的； 信号量既可用于上锁，也可用于等待，因此会有更多的开销和更高的复杂性</li>
<li>互斥锁，条件变量都只用于同一个进程的各线程间，而信号量（有名信号量）可用于不同进程间的同步。当信号量用于进程间同步时，要求信号量建立在共享内存区</li>
<li>互斥量必须由同一线程获取以及释放，信号量和条件变量则可以由一个线程释放，另一个线程得到</li>
<li>信号量的递增和减少会被系统自动记住，系统内部的计数器实现信号量，不必担心丢失，而唤醒一个条件变量时，如果没有相应的线程在等待该条件变量，此次唤醒会被丢失</li>
</ol>
<h1 id="好博文参考"><a href="#好博文参考" class="headerlink" title="好博文参考"></a>好博文参考</h1><ul>
<li><a href="https://blog.csdn.net/wh_sjc/article/details/70283843" target="_blank" rel="noopener">进程间的五种通信方式介绍</a></li>
<li><a href="https://blog.csdn.net/liu5320102/article/details/50764645" target="_blank" rel="noopener">线程间的通信、同步方式与进程间通信方式</a></li>
<li><a href="https://blog.csdn.net/a987073381/article/details/52029070" target="_blank" rel="noopener">linux线程间通信及同步机制总结</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/linux/多进程线程通信同步总结/" data-id="cjtu8agam00060svc9qn1s2qr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/多线程调试" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/linux/多线程调试/" class="article-date">
  <time datetime="2019-03-20T15:31:09.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/linux/多线程调试/">多线程调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol>
<li>gdb attach $PID:attach 进程</li>
<li>info threads: 显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    Id   Target Id         Frame </span><br><span class="line">* 1    Thread 0x7f8ef79ec740 (LWP 3994) &quot;thread_demo&quot; 0x00007f8ef75d1d2d in __GI___pthread_timedjoin_ex (threadid=140251998291712, thread_return=0x0, </span><br><span class="line">    abstime=0x0, block=&lt;optimized out&gt;) at pthread_join_common.c:89</span><br><span class="line">  2    Thread 0x7f8ef6898700 (LWP 3995) &quot;thread_demo&quot; 0x00007f8ef6f339d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f8ef6897ea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef6897ea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">  3    Thread 0x7f8ef6097700 (LWP 3996) &quot;thread_demo&quot; 0x00007f8ef6f339d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f8ef6096ea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef6096ea0)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>thread ID:切换当前调试的线程为指定ID的线程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Switching to thread 1 (Thread 0x7f8ef79ec740 (LWP 3994))]</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>打印堆栈信息: thread apply all bt</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hread 11 (Thread 0x7f8ef208f700 (LWP 4004)):</span><br><span class="line">#0  0x00007f8ef6f339d0 in __GI___nanosleep (</span><br><span class="line">    requested_time=requested_time@entry=0x7f8ef208eea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef208eea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">#1  0x00007f8ef6f338aa in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55</span><br><span class="line">#2  0x00005580971cdaa2 in thread_route (arg=0x0) at thread_demo.cpp:10</span><br><span class="line">#3  0x00007f8ef75d06db in start_thread (arg=0x7f8ef208f700)</span><br><span class="line">    at pthread_create.c:463</span><br><span class="line">#4  0x00007f8ef6f7088f in clone ()</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br><span class="line"></span><br><span class="line">Thread 10 (Thread 0x7f8ef2890700 (LWP 4003)):</span><br><span class="line">#0  0x00007f8ef6f339d0 in __GI___nanosleep (</span><br><span class="line">    requested_time=requested_time@entry=0x7f8ef288fea0, </span><br><span class="line">    remaining=remaining@entry=0x7f8ef288fea0)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/nanosleep.c:28</span><br><span class="line">#1  0x00007f8ef6f338aa in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55</span><br><span class="line">#2  0x00005580971cdaa2 in thread_route (arg=0x0) at thread_demo.cpp:10</span><br><span class="line">#3  0x00007f8ef75d06db in start_thread (arg=0x7f8ef2890700)</span><br><span class="line">    at pthread_create.c:463</span><br><span class="line">#4  0x00007f8ef6f7088f in clone ()</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>Thread apply ID1 ID2:让一个或者多个线程执行command命令</li>
<li>Set scheduler-locking off|on|step<ul>
<li>设置locking scheduler模式<ul>
<li>ON：只有当前线程运行</li>
<li>Off：所有线程都会运行</li>
<li>Step：当执行step操作时只有当前线程会运行，执行continue所有线程都会运行<ol start="7">
<li>ps aux | grep thread_demo:查看当前运行的经常</li>
<li>ps -aL | grep thread_demo:查看当前运行的轻量级进程</li>
<li>pstree -p 主线程ID:查看线程关系</li>
<li>查看线程栈结构: ps stack 线程ID</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void *thread_route(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    sleep(random());</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    pthread_t threadID[10];</span><br><span class="line">    cout&lt;&lt;&quot;pthread runing&quot;&lt;&lt;endl;</span><br><span class="line">    for(i = 0; i &lt; sizeof(threadID) / sizeof(threadID[0]); i++) &#123;</span><br><span class="line">        pthread_create(&amp;threadID[i], NULL, thread_route, NULL);</span><br><span class="line">    &#125;   </span><br><span class="line">    for(i = 0; i &lt; sizeof(threadID) / sizeof(threadID[0]); i++) &#123;</span><br><span class="line"></span><br><span class="line">        pthread_join(threadID[i], NULL);</span><br><span class="line">    &#125;   </span><br><span class="line">    cout&lt;&lt;&quot;pthread end&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/linux/多线程调试/" data-id="cjtu8agaf00020svczfx2j2zm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编译框架/cmake" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/编译框架/cmake/" class="article-date">
  <time datetime="2019-03-19T17:00:04.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编译框架/">编译框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/编译框架/cmake/">cmake</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/编译框架/cmake/" data-id="cjtu8agb9000x0svcod2zvgdi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SQL/SQL语句" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/10/SQL/SQL语句/" class="article-date">
  <time datetime="2019-03-10T08:06:36.000Z" itemprop="datePublished">2019-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SQL/">SQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/10/SQL/SQL语句/">SQL语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table>
<thead>
<tr>
<th>存储类</th>
<th>Describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>NULL值</td>
</tr>
<tr>
<td>INTEGER</td>
<td>带符号整数，size=1,2,3,4,6 or 8</td>
</tr>
<tr>
<td>REAL</td>
<td>浮点值,size=8的IEEE浮点数字</td>
</tr>
<tr>
<td>TEXT</td>
<td>文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>blob数据， 类型由输入存储</td>
</tr>
</tbody>
</table>
<h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE if not exists database_name.table_name(</span><br><span class="line">   column1 datatype  PRIMARY KEY(one or more columns),</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE database_name.table_name;</span><br></pre></td></tr></table></figure>
<h1 id="插入表"><a href="#插入表" class="headerlink" title="插入表"></a>插入表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME(column1, column2, ... columnN)</span><br><span class="line">VALUES (value1, value2, ... valueN)</span><br></pre></td></tr></table></figure>
<h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name;</span><br></pre></td></tr></table></figure>
<h1 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h1><p>可应用于SELCT、UPDATE、DELETE,用来过滤记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name</span><br><span class="line">WHERE[CONDITION | EXPRESSION];</span><br></pre></td></tr></table></figure>
<h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">set column1=value1, column2=value2...., columnN=valueN</span><br><span class="line">where[CONDITION];</span><br></pre></td></tr></table></figure>
<h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE[CONDITION];</span><br></pre></td></tr></table></figure>
<h1 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h1><p>LINK匹配通配符</p>
<ul>
<li>%：表示0、1或者多个数字或字符</li>
<li>_：表示单一的数字或字符</li>
</ul>
<p>such as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET column_list FROM table_name</span><br><span class="line">where column LIKE &apos;xxx%&apos;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Glob"><a href="#Glob" class="headerlink" title="Glob"></a>Glob</h1><p>Glob匹配通配符， 大小敏感</p>
<ul>
<li>*：表示0、1或者多个数字或字符</li>
<li>?： 表示单一的数字或字符</li>
</ul>
<h1 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h1><p>Limit限制SELECT 返回的数据量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cloumn1, column2 ...</span><br><span class="line">FROM table_name</span><br><span class="line">LIMIT [no of rows]</span><br><span class="line"></span><br><span class="line">such as:</span><br><span class="line">SELECT * FROM COMPANY LIMIT 3 OFFSET 2;</span><br></pre></td></tr></table></figure>
<h1 id="Order-By"><a href="#Order-By" class="headerlink" title="Order By"></a>Order By</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE condition]</span><br><span class="line">[ORDER BY column1, coulum2, ...][ASC|DESC];</span><br></pre></td></tr></table></figure>
<h1 id="Group-By"><a href="#Group-By" class="headerlink" title="Group By"></a>Group By</h1><p>SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。<br>在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE[conditions]</span><br><span class="line">GROUP BY column1, ....</span><br><span class="line">ORDER BY column1,....;</span><br></pre></td></tr></table></figure>
<h1 id="Having-子句"><a href="#Having-子句" class="headerlink" title="Having 子句"></a>Having 子句</h1><p>Having子句允许指定条件来过滤将出现在最终结果的分组<br>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br><span class="line"></span><br><span class="line">such as:</span><br><span class="line">SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2;</span><br></pre></td></tr></table></figure>
<h1 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h1><p>DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。</p>
<p>有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul>
<li>NOT NULL: 确保某列不能为NULL</li>
<li>DEFAULT: 当莫列没有指定值时， 为该列提供默认值</li>
<li>UNIQUE: 确保某列的所有值不同</li>
<li>PRIMARY Key: 为一标识数据库表的各行和数据</li>
<li>CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件</li>
</ul>
<h1 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h1><p>SQLite 的 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段</p>
<ul>
<li>交叉连接 - CROSS JOIN</li>
<li>内连接 - INNER JOIN</li>
<li>外连接 - OUTER JOIN</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/10/SQL/SQL语句/" data-id="cjtu8agak00040svc48qgtb8f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-other/getaddrinfo爬坑" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/21/other/getaddrinfo爬坑/" class="article-date">
  <time datetime="2019-02-21T14:49:41.000Z" itemprop="datePublished">2019-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/21/other/getaddrinfo爬坑/">getaddrinfo爬坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近发现了客户一个问题， LE程序自启动一直连接不上服务端， 重启程序后成功</p>
<p>查看日志， getaddrinfo一直打印Tempoary failed in name soluation</p>
<p>开机时由systemd拉起程序, 此时网络服务并没有初始化成功， 此时连接失败时符合预期的， 间隔一段时间后， 发现还一直报域名服务失败</p>
<ol>
<li>此时采用ping 服务器域名， 发现网络正常</li>
<li>编写demo, 手动执行发现可以正常获取域名</li>
</ol>
<p>一开始被getaddrinfo文档误导了,一开始也考虑过缓存的问题，但getaddrinfow文档显示为MT-safe， 就首先排除这个选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────┬───────────────┬────────────────────┐</span><br><span class="line">│Interface       │ Attribute     │ Value              │</span><br><span class="line">├────────────────┼───────────────┼────────────────────┤</span><br><span class="line">│getaddrinfo()   │ Thread safety │ MT-Safe env locale │</span><br><span class="line">├────────────────┼───────────────┼────────────────────┤</span><br><span class="line">│freeaddrinfo(), │ Thread safety │ MT-Safe            │</span><br><span class="line">│gai_strerror()  │               │                    │</span><br><span class="line">└────────────────┴───────────────┴────────────────────┘</span><br></pre></td></tr></table></figure>
<p>后期发现DNS做了一次缓存…….</p>
<p>在使用 getaddrinfo 函数的时候，实际会使用 glibc 的相关函数，glibc 在应用第一次域名解析的时候会触发 res_init() 函数的调用，res_init() 函数的作用是读取 /etc/resolv.conf 的内容, 如 nameserver 地址、负载均衡策略、重试次数、超时时间等，并将读取的这些数据放到 static 类型的 <em>res</em> 结构体中。</p>
<p>由于 Linux 的进程在使用 glibc 动态链接库全局静态变量的时候，都会在用户进程空间生成自己独立的变量副本（感兴趣的同学可以查看每个进程的 smaps 文件，glibc 在每个用户进程空间都有可读、可写的 segment），所以每个发起 DNS 解析的进程都具有独立的 <em>res</em> 结构体变量。</p>
<p>回到 salt-minio 这个具体案例，salt-minion 进程启动后发起第一次域名解析请求，该请求最后会调用底层的 res_query，第一次 res_query 会调用 res_init()，res_init() 初始化后，nameserver 地址被初始化到当前进程的 <em>res</em> 结构体中， 然而 res_init() 对于每个进程来说，只会执行一次。</p>
<p>运维同学在用户进程运行的时候修改掉 /etc/resolv.conf 中的配置，但修改配置后无法生效的根本原因就在此（因为用户进程空间的 _res 结构体中仍然存放的是老的 nameserver 配置）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The functions described below make queriesto and interpret the responses from Internet domain name servers.The API consists of a set of more modern, reentrant functions and an older set of nonreentrant functions that have been superseded. The traditional resolver interfaces such as res_init() and res_query() use some static (global) state stored in the _res structure, rendering these functions non-thread-safe. BIND 8.2 introduced a set of new interfaces res_ninit(), res_nquery(), and so on, which take a res_state as their first argument, so you can use a per-thread</span><br><span class="line"></span><br><span class="line">resolver state.The res_ninit() and res_init() functions read the configuration files (see resolv.conf(5)) to get the default domain name and name server address(es).If no server isgiven, the local host is tried. If no domain is given, that associated with thelocal host is used. It can be overridden with the environment variable LOCALDOMAIN. res_ninit() or res_init() is normally executed by the first call to one of the other functions.</span><br></pre></td></tr></table></figure>
<p>解决方法:</p>
<ol>
<li>用户进程直接调用底层的接口，并且定期调用 res_init() 以防止 /etc/resolov.conf 文件被修改而无法感知(有一定的实现成本)。</li>
<li>直接重启用户进程，使用户进程在做第一次域名解析的时候触发 res_init()</li>
<li>用户进程实现 DNS 的 client 全部功能</li>
<li>通过非常规手段修改用户进程空间的数据</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/21/other/getaddrinfo爬坑/" data-id="cjtu8agar000c0svcikohy3d2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-流媒体/rtmp-specification-1-0" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/27/流媒体/rtmp-specification-1-0/" class="article-date">
  <time datetime="2019-01-27T15:44:15.000Z" itemprop="datePublished">2019-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/流媒体/">流媒体</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/27/流媒体/rtmp-specification-1-0/">rtmp_specification_1.0</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//<a href="https://www.cnblogs.com/Kingfans/p/7083100.html" target="_blank" rel="noopener">https://www.cnblogs.com/Kingfans/p/7083100.html</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Adobe 公司的实时消息传输协议 (RTMP) 通过一个可靠地流传输提供了一个双向多通道消息服务，比如 TCP [RFC0793]，意图在通信端之间传递带有时间信息的视频、音频和数据消息流。实现通常对不同类型的消息分配不同的优先级，当运载能力有限时，这会影响等待流传输的消息的次序。本文档将对实时流传输协议 (Real Time Messaging Protocol) 的语法和操作进行描述。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li>Payload(有效载荷): 包含于一个数据包中的数据，例如音频采样或者压缩的视频数据</li>
<li>Package(数据包): 一个数据包由一个固定头和有效载荷数据构成。一些个底层协议可能会要求对数据包定义封装。</li>
<li>Port (端口):”传输协议用以区分开指定一台主机的不同目的地的一个抽象。TCP/IP 使用小的正整数对端口进行标识。” OSI 传输层使用的运输选择器 (TSEL) 相当于端口</li>
<li>Transport address (传输地址): 用以识别传输层端点的网络地址和端口的组合，例如一个 IP 地址和一个 TCP 端口。数据包由一个源传输地址传送到一个目的传输地址。</li>
<li>Message stream (消息流): 通信中消息流通的一个逻辑通道。</li>
<li>Message stream ID (消息流 ID)：每个消息有一个关联的 ID，使用 ID 可以识别出流通中的消息流<br>Multiplexing (合成)：将独立的音频/视频数据合成为一个连续的音频/视频流的加工，这样可以同时发送几个视频和音频。</li>
<li>DeMultiplexing (分解): Multiplexing 的逆向处理，将交叉的音频和视频数据还原成原始音频和视频数据的格式。</li>
<li>Remote Procedure Call (RPC 远程方法调用): 允许客户端或服务器调用对端的一个子程序或者程序的请求。</li>
<li>Metadata (元数据): 关于数据的一个描述。一个电影的 metadata 包括电影标题、持续时间、创建时间等等。</li>
<li>Application Instance (应用实例): 服务器上应用的实例，客户端可以连接这个实例并发送连接请求。</li>
<li>Action Message Format (AMF 动作消息格式协议): 一个用于序列化 ActionScript 对象图的紧凑的二进制格式。AMF 有两个版本：AMF 0 [AMF0] 和 AMF 3 [AMF3]。</li>
</ul>
<h1 id="字节序、对齐和时间格式"><a href="#字节序、对齐和时间格式" class="headerlink" title="字节序、对齐和时间格式"></a>字节序、对齐和时间格式</h1><p>所有整数型属性以网络字节顺序传输，字节 0 代表第一个字节，零位是一个单词或字段最常用的有效位。字节序通常是大端排序。关于传输顺序的更多细节描述参考 IP 协议[RFC0791]</p>
<p>RTMP 中的所有数据都是字节对准的；例如，一个十六位的属性可能会在一个奇字节偏移上。填充后，填充字节应该有零值。</p>
<p>RTMP 中的 Timestamps 以一个整数形式给出，表示一个未指明的时间点。典型地，每个流会以一个为 0 的 timestamp 起始，但这不是必须的，只要双端能够就时间点达成一致。注意这意味着任意不同流 (尤其是来自不同主机的) 的同步需要 RTMP 之外的机制。</p>
<p>因为 timestamp 的长度为 32 位，每隔 49 天 17 小时 2 分钟和 47.296 秒就要重来一次。因为允许流连续传输，有可能要多年，RTMP 应用在处理 timestamp 时应该使用序列码算法 [RFC1982]，并且能够处理无限循环。例如，一个应用假定所有相邻的 timestamp 都在 2^31 - 1 毫秒之内，因此 10000 在 4000000000 之后，而 3000000000 在 4000000000 之前。</p>
<p>timestamp 也可以使用无符整数定义，相对于前面的 timestamp。timestamp 的长度可能会是 24 位或者 32 位。</p>
<h1 id="RTMP块流"><a href="#RTMP块流" class="headerlink" title="RTMP块流"></a>RTMP块流</h1><p>实时消息传输协议的块流 (RTMP 块流)。 它为上层多媒体流协议提供合并和打包的服务。</p>
<p>RTMP使用实时消息传输协议时，它可以处理任何发送消息流的协议。每个消息包含timestamp和payload类型标识，RTMP 块流和 RTMP 一起适合各种音频-视频应用，从一对一和一对多直播到点播服务，到互动会议应用。</p>
<p>当使用可靠传输协议时，比如 TCP [RFC0793]，RTMP 块流能够对于多流提供所有消息可靠的 timestamp 有序端对端传输。RTMP 块流并不提供任何优先权或类似形式的控制，但是可以被上层协议用来提供这种优先级。例如，一个直播视频服务器可能会基于发送时间或者每个消息的确认时间丢弃一个传输缓慢的客户端的视频消息以确保及时获取其音频消息。</p>
<p>RTMP 块流包括其自身的带内协议控制信息，并且提供机制为上层协议植入用户控制消息。</p>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>可以被分割为块以支持组合的消息的格式取决于上层协议。消息格式必须包含以下创建块所需的字段</p>
<ul>
<li>Timestamp: message timestamp, 4Byte</li>
<li>Length: 消息的有效负载长度。如果不能省略掉消息头，那它也被包括进这个长度。这个字段占用了块头的三个字节。</li>
<li>Type Id：一些类型 ID 保留给协议控制消息使用。这些传播信息的消息由 RTMP 块流协议和上层协议共同处理。其他的所有类型 ID 可用于上层协议，它们被 RTMP 块流处理为不透明值。事实上，RTMP 块流中没有任何地方要把这些值当做类型使用；所有消息必须是同一类型，或者应用使用这一字段来区分同步跟踪，而不是类型。这一字段占用了块头的一个字节</li>
<li>Message Stream ID：message stream (消息流) ID 可以使任意值。合并到同一个块流的不同的消息流是根据各自的消息流 ID 进行分解。除此之外，对 RTMP 块流而言，这是一个不透明的值。这个字段以小端格式占用了块头的四个字节</li>
</ul>
<h2 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h2><p>一个 RTMP 连接以握手开始。RTMP 的握手不同于其他协议；RTMP 握手由三个固定长度的块组成，而不是像其他协议一样的带有报头的可变长度的块。</p>
<p>客户端 (发起连接请求的终端) 和服务器端各自发送相同的三块。便于演示，当发送自客户端时这些块被指定为 C0、C1 和 C2；当发送自服务器端时这些块分别被指定为 S0、S1 和 S2</p>
<h3 id="握手顺序"><a href="#握手顺序" class="headerlink" title="握手顺序"></a>握手顺序</h3><ul>
<li>握手以客户端发送C0和C1开始</li>
<li>客户端必须等到S1才能发送C2</li>
<li>客户端必须受到S2才能发送任何其他数据</li>
<li>服务端必须等待接收到C0才能发送S0、S1，也可以等待接收到C1再发送S0和S1.服务器端必须等待接收到 C1 才能发送 S2。服务器端必须等待接收到 C2 才能发送任何其他数据。</li>
</ul>
<h3 id="C0和S0的格式"><a href="#C0和S0的格式" class="headerlink" title="C0和S0的格式"></a>C0和S0的格式</h3><p>C0 和 S0 包都是一个单一的八位字节，以一个单独的八位整型域进行处理：</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C0_S0.png" alt=""></p>
<ul>
<li>version: 本文档中规范的版本号为 3。0、1、2 三个值是由早期其他产品使用的，是废弃值；4 - 31 被保留为 RTMP 协议的未来实现版本使用；32 - 255 不允许使用 (以区分开 RTMP 和其他常以一个可打印字符开始的文本协议)。无法识别客户端所请求版本号的服务器应该以版本 3 响应，(收到响应的) 客户端可以选择降低到版本 3，或者放弃握手。</li>
</ul>
<h3 id="C1和S1的格式"><a href="#C1和S1的格式" class="headerlink" title="C1和S1的格式"></a>C1和S1的格式</h3><p>C1 和 S1 数据包的长度都是 1536 字节，包含以下字段：</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C1_S1.png" alt=""></p>
<ul>
<li>time:包含一个timestamp,用于本终端发送的所有后续块的时间起点。这个值可以是 0，或者一些任意值。要同步多个块流，终端可以发送其他块流当前的 timestamp 的值</li>
<li>zero:must be 0</li>
<li>random data(1528 Byte): 这个字段可以包含任意值。终端需要区分出响应来自它发起的握手还是对端发起的握手，这个数据应该发送一些足够随机的数。这个不需要对随机数进行加密保护，也不需要动态值</li>
</ul>
<h3 id="C2和S2的格式"><a href="#C2和S2的格式" class="headerlink" title="C2和S2的格式"></a>C2和S2的格式</h3><p>C2 和 S2 数据包长度都是 1536 字节，包含有以下字段：<br><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C2_S2.png" alt=""></p>
<ul>
<li><p>time (四个字节)：这个字段必须包含终端在 S1 (给 C2) 或者 C1 (给 S2) 发的 timestamp。</p>
</li>
<li><p>time2 (四个字节)：这个字段必须包含终端先前发出数据包 (s1 或者 c1) timestamp。</p>
</li>
<li><p>random echo (1528 个字节)：这个字段必须包含终端发的 S1 (给 C2) 或者 S2 (给 C1) 的随机数。两端都可以一起使用 time 和 time2 字段再加当前 timestamp 以快速估算带宽和/或者连接延迟</p>
</li>
</ul>
<h3 id="握手示意图"><a href="#握手示意图" class="headerlink" title="握手示意图"></a>握手示意图</h3><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/hangshark.png" alt=""></p>
<ul>
<li>Uninitalized(未初始化)：协议的版本号在这个阶段被发送。客户端和服务器都是 uninitialized (未初始化) 状态。之后客户端在数据包 C0 中将协议版本号发出。如果服务器支持这个版本，它将在回应中发送 S0 和 S1。如果不支持呢，服务器会才去适当的行为进行响应。在 RTMP 协议中，这个行为就是终止连接。</li>
<li>Version Send(版本已发送): 在未初始化状态之后，客户端和服务器都进入 Version Sent (版本已发送) 状态。客户端会等待接收数据包 S1 而服务器在等待 C1。一旦拿到期待的包，客户端会发送数据包 C2 而服务器发送数据包 S2。(客户端和服务器各自的)状态随即变为 Ack Sent (确认已发送)</li>
<li>Ack Sent(确认)：客户端和服务器分别等待 S2 和 C2。</li>
<li>Handshake Done(握手结束)：客户端和服务器可以开始交换消息了。</li>
</ul>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>握手之后，连接开始对一个或多个块流进行合并。创建的每个块都有一个唯一ID对其进行关联。这个ID为chunk stream ID,这些块通过网络进行传输。传递时，每个块必须被完全发送才可以发送下一块。在接收端，这些块被根据块流 ID 被组装成消息。</p>
<p>分块允许上层协议将大的消息分解为更小的消息，例如，防止体积大的但优先级小的消息 (比如视频) 阻碍体积较小但优先级高的消息 (比如音频或者控制命令)。</p>
<p>分块也让我们能够使用较小开销发送小消息，因为块头包含包含在消息内部的信息压缩提示。</p>
<p>块的大小是可以配置的。它可以使用一个设置块大小的控制消息进行设置 (参考 5.4.1)。更大的块大小可以降低 CPU 开销，但在低带宽连接时因为它的大量的写入也会延迟其他内容的传递。更小的块不利于高比特率的流化。所以块的大小设置取决于具体情况。</p>
<h3 id="块格式"><a href="#块格式" class="headerlink" title="块格式"></a>块格式</h3><p>每个块包含一个头和数据体，块头包含三个部分</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_header.png" alt=""></p>
<ul>
<li>Basic Header(1-3Byte):这个字段对块流ID和块类型进行编码。块类型决定了消息头的编码格式，长度完全取决于块流 ID，因为块流 ID 是一个可变长度的字段</li>
<li>Message Header(0,3,7或者11个字节):这一字段对正在发送的消息 (不管是整个消息，还是只是一小部分) 的信息进行编码。这一字段的长度可以使用块头中定义的块类型进行决定</li>
<li>Extended Timestamp (扩展 timestamp，0 或 4 字节)：这一字段是否出现取决于块消息头中的 timestamp 或者 timestamp delta 字段</li>
<li>ChunkData(有效大小): 当前块的有效负载，相当于定义的最大块大小</li>
</ul>
<h4 id="块基本头"><a href="#块基本头" class="headerlink" title="块基本头"></a>块基本头</h4><p>块基本头对块流ID和块类型进行编码，字段可能或者有1,2或者3，取决于块流ID</p>
<p>一个RTMP实现应该使用能够容纳这个ID的最小容量进行表示</p>
<p>RTMP 协议最多支持 65597 个流，流 ID 范围 3 - 65599。ID 0、1、2 被保留。0 值表示二字节形式，并且 ID 范围 64 - 319 (第二个字节 + 64)。1 值表示三字节形式，并且 ID 范围为 64 - 65599 ((第三个字节) * 256 + 第二个字节 + 64)。3 - 63 范围内的值表示整个流 ID。带有 2 值的块流 ID 被保留，用于下层协议控制消息和命令。</p>
<p>块基本头中的 0 - 5 位 (最低有效) 代表块流 ID。<br>块流 ID 2 - 63 可以编进这一字段的一字节版本中。</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header1.jpg" alt=""></p>
<p>块流 ID 64 - 319 可以以二字节的形式编码在头中。ID 计算为 (第二个字节 + 64)</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header2.jpg" alt=""></p>
<p>块流 ID 64 - 65599 可以编码在这个字段的三字节版本中。ID 计算为 ((第三个字节) * 256 + (第二个字节) + 64)。</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header3.jpg" alt=""></p>
<ul>
<li>cs id (六位)：这一字段包含有块流 ID，值的范围是 2 - 63。值 0 和 1 用于指示这一字段是 2- 或者 3- 字节版本。</li>
<li>fmt (两个字节)：这一字段指示 ‘chunk message header’ 使用的四种格式之一。没中块类型的 ‘chunk message header’ 会在下一小节解释</li>
<li>cs id - 64 (8 或者 16 位)：这一字段包含了块流 ID 减掉 64 后的值。例如，ID 365 在 cs id 中会以一个 1 进行表示，和这里的一个 16 位 的 301 (cs id - 64)。</li>
<li>块流 ID 64 - 319 可以使用 2-byte 或者 3-byte 的形式在头中表示。</li>
</ul>
<h4 id="块消息头"><a href="#块消息头" class="headerlink" title="块消息头"></a>块消息头</h4><p>块消息头又四种不同的格式，由块基本头中的 “fmt” 字段进行选择。</p>
<p>一个 (RTMP) 实现应该为每个块消息头使用最紧凑的表示。</p>
<ul>
<li>type0</li>
</ul>
<p>类型0块头的长度为11字节，这已类型必须用在块流的起始位置，每当流回退的时候，例如充值<br><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type0.jpg" alt=""></p>
<p>timestamp(三个字节): 对于type-0块，当前消息的绝对timestamp在这边发送. 如果 timestamp 大于或者等于 16777215 (十六进制 0xFFFFFF)，这一字段必须是 16777215，表明有扩展 timestamp 字段来补充完整的 32 位 timestamp。否则的话，这一字段必须是整个的 timestamp。</p>
<p>-type1</p>
<p>类型 1 块头长为 7 个字节。不包含消息流 ID；这一块使用前一块一样的流 ID。可变长度消息的流 (例如，一些视频格式) 应该在第一块之后使用这一格式表示之后的每个新消息</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type1.jpg" alt=""></p>
<ul>
<li>type2 </li>
</ul>
<p>类型 2 块头长度为 3 个字节。既不包含流 ID 也不包含消息长度；这一块具有和前一块相同的流 ID 和消息长度。具有不变长度的消息 (例如，一些音频和数据格式) 应该在第一块之后使用这一格式表示之后的每个新消息。</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type2.jpg" alt=""></p>
<ul>
<li>type3</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/27/流媒体/rtmp-specification-1-0/" data-id="cjtu8agc8001m0svcr8ki9srv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-流媒体/nginx-rtmp" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/23/流媒体/nginx-rtmp/" class="article-date">
  <time datetime="2019-01-23T13:41:30.000Z" itemprop="datePublished">2019-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/流媒体/">流媒体</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/23/流媒体/nginx-rtmp/">nginx_rtmp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>git clone <a href="https://github.com/arut/nginx-rtmp-module.git" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module.git</a> </li>
<li>wget <a href="http://nginx.org/download/nginx-1.15.8.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.15.8.tar.gz</a></li>
<li>./configure –prefix=/usr/local/nginx  –add-module=../nginx-rtmp-module  –with-http_ssl_module    </li>
<li>nginx.conf <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    location /stat &#123;</span><br><span class="line">            rtmp_stat all;</span><br><span class="line">            rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">    &#125;</span><br><span class="line">    location /stat.xsl &#123;</span><br><span class="line">        root /home/cuijian/do/package/nginx-rtmp-module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp &#123;                #RTMP服务</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;  #//服务端口</span><br><span class="line">        chunk_size 4096;   #//数据传输块的大小</span><br><span class="line"></span><br><span class="line">        application live &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ffmpeg -threads 2 -re -fflags +genpts -stream_loop -1 -i test.264   -c:v copy -c:a aac -f flv rtmp://127.0.0.1:1935/live/test264</p>
<p>RTMP推流数据包</p>
<p><img src="/2019/01/23/流媒体/nginx-rtmp/rtmp_publish.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/23/流媒体/nginx-rtmp/" data-id="cjtu8agb7000u0svc9ccpzoxl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/用户态和内核态" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/07/linux/用户态和内核态/" class="article-date">
  <time datetime="2019-01-07T14:48:08.000Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/07/linux/用户态和内核态/">用户态和内核态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="用户态及内核态介绍"><a href="#用户态及内核态介绍" class="headerlink" title="用户态及内核态介绍"></a>用户态及内核态介绍</h1><p><img src="/2019/01/07/linux/用户态和内核态/Unix_Linux的体系架构.png" alt=""></p>
<p>从宏观上来看，Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。<em>内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境</em>。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>系统调用是操作系统的最小功能单位，这些系统调用根据不同的应用场景可以进行扩展和裁剪，现在各种版本的Unix实现都提供了不同数量的系统调用，如Linux的不同版本提供了240-260个系统调用，FreeBSD大约提供了320个（reference：UNIX环境高级编程）。我们可以把系统调用看成是一种不能再化简的操作（类似于原子操作，但是不同概念），有人把它比作一个汉字的一个“笔画”，而一个“汉字”就代表一个上层应用，我觉得这个比喻非常贴切。因此，有时候如果要实现一个完整的汉字（给某个变量分配内存空间），就必须调用很多的系统调用。如果从实现者（程序员）的角度来看，这势必会加重程序员的负担，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。库函数正是为了将程序员从复杂的细节中解脱出来而提出的一种有效方法。它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”。这样的一种组成方式极大增强了程序设计的灵活性，对于简单的操作，我们可以直接调用系统调用来访问资源，如“人”，对于复杂操作，我们借助于库函数来实现，如“仁”。显然，这样的库函数依据不同的标准也可以有不同的实现版本，如ISO C 标准库，POSIX标准库等。</p>
<p>　　Shell是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
<p>总结一下，用户态的应用程序可以通过三种方式来访问内核态的资源：<br>1) 系统调用<br>2) 库函数<br>3) Shell脚本</p>
<ul>
<li>向下控制硬件资源</li>
<li>向内管理操作系统资源<ul>
<li>进程的调度和管理</li>
<li>内存的管理</li>
<li>文件系统的管理</li>
<li>设备驱动</li>
<li>网络资源的管理</li>
</ul>
</li>
<li>向上则向应用程序提供系统调用的接口</li>
</ul>
<p>整个操作系统分为两层：用户态和内核态，这种分层的架构极大地提高了资源管理的可扩展性和灵活性，而且方便用户对资源的调用和集中式的管理，带来一定的安全性</p>
<p><img src="/2019/01/07/linux/用户态和内核态/kernal_framework.jpg" alt=""></p>
<h1 id="用户态及内核态的切换"><a href="#用户态及内核态的切换" class="headerlink" title="用户态及内核态的切换"></a>用户态及内核态的切换</h1><p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。</p>
<p><img src="/2019/01/07/linux/用户态和内核态/mode_change.gif" alt=""></p>
<p>从用户态到内核态的切换:</p>
<ol>
<li>系统调用</li>
<li>异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li>
<li>外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li>
</ol>
<p>系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">Linux探秘之用户态与内核态</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/07/linux/用户态和内核态/" data-id="cjtu8agao00080svcvn183w7f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-other/指针数组和数组指针" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/07/other/指针数组和数组指针/" class="article-date">
  <time datetime="2019-01-07T14:17:19.000Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/07/other/指针数组和数组指针/">指针数组和数组指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><ul>
<li>int (*p)[n], 其中()优先级高于[]，故p是一个指针， 指向一维的数组，数组长度是n,p的步长也是n,也就是说执行p+1时，p要跨过n个整型数据的长度。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如要将二维数组赋给一指针，应这样赋值：</span><br><span class="line">int a[3][4];</span><br><span class="line">int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。</span><br><span class="line"> p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span><br><span class="line"> p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span><br></pre></td></tr></table></figure>
<h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><ul>
<li>int <em>p[n];[]优先级高于</em>，故先于p组成数组， int*说明是整形指针数组它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素</li>
</ul>
<h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><ul>
<li>指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。</li>
<li>数组指针：首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4 个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。</li>
</ul>
<p><img src="/2019/01/07/other/指针数组和数组指针/指针数组和数组指针-内存表示.jpg" alt=""><br><img src="/2019/01/07/other/指针数组和数组指针/指针数组和数组指针-内存表示2.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/07/other/指针数组和数组指针/" data-id="cjtu8agb1000m0svcckm5kccv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/流媒体/">流媒体</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编译框架/">编译框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/29/C++/指针详解/">指针详解</a>
          </li>
        
          <li>
            <a href="/2019/03/29/linux/多进程线程通信同步总结/">多进程线程通信同步总结</a>
          </li>
        
          <li>
            <a href="/2019/03/20/linux/多线程调试/">多线程调试</a>
          </li>
        
          <li>
            <a href="/2019/03/20/编译框架/cmake/">cmake</a>
          </li>
        
          <li>
            <a href="/2019/03/10/SQL/SQL语句/">SQL语句</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Jian.Cui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>