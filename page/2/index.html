<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>CuijianSa.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="CuijianSa.github.io">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="CuijianSa.github.io">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CuijianSa.github.io">
  
    <link rel="alternate" href="/atom.xml" title="CuijianSa.github.io" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CuijianSa.github.io</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Olin&#39;s blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SQL/SQL语句" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/10/SQL/SQL语句/" class="article-date">
  <time datetime="2019-03-10T08:06:36.000Z" itemprop="datePublished">2019-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SQL/">SQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/10/SQL/SQL语句/">SQL语句</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table>
<thead>
<tr>
<th>存储类</th>
<th>Describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>NULL值</td>
</tr>
<tr>
<td>INTEGER</td>
<td>带符号整数，size=1,2,3,4,6 or 8</td>
</tr>
<tr>
<td>REAL</td>
<td>浮点值,size=8的IEEE浮点数字</td>
</tr>
<tr>
<td>TEXT</td>
<td>文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>blob数据， 类型由输入存储</td>
</tr>
</tbody>
</table>
<h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE if not exists database_name.table_name(</span><br><span class="line">   column1 datatype  PRIMARY KEY(one or more columns),</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE database_name.table_name;</span><br></pre></td></tr></table></figure>
<h1 id="插入表"><a href="#插入表" class="headerlink" title="插入表"></a>插入表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME(column1, column2, ... columnN)</span><br><span class="line">VALUES (value1, value2, ... valueN)</span><br></pre></td></tr></table></figure>
<h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name;</span><br></pre></td></tr></table></figure>
<h1 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h1><p>可应用于SELCT、UPDATE、DELETE,用来过滤记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, columnN FROM table_name</span><br><span class="line">WHERE[CONDITION | EXPRESSION];</span><br></pre></td></tr></table></figure>
<h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">set column1=value1, column2=value2...., columnN=valueN</span><br><span class="line">where[CONDITION];</span><br></pre></td></tr></table></figure>
<h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE[CONDITION];</span><br></pre></td></tr></table></figure>
<h1 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h1><p>LINK匹配通配符</p>
<ul>
<li>%：表示0、1或者多个数字或字符</li>
<li>_：表示单一的数字或字符</li>
</ul>
<p>such as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET column_list FROM table_name</span><br><span class="line">where column LIKE &apos;xxx%&apos;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Glob"><a href="#Glob" class="headerlink" title="Glob"></a>Glob</h1><p>Glob匹配通配符， 大小敏感</p>
<ul>
<li>*：表示0、1或者多个数字或字符</li>
<li>?： 表示单一的数字或字符</li>
</ul>
<h1 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h1><p>Limit限制SELECT 返回的数据量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cloumn1, column2 ...</span><br><span class="line">FROM table_name</span><br><span class="line">LIMIT [no of rows]</span><br><span class="line"></span><br><span class="line">such as:</span><br><span class="line">SELECT * FROM COMPANY LIMIT 3 OFFSET 2;</span><br></pre></td></tr></table></figure>
<h1 id="Order-By"><a href="#Order-By" class="headerlink" title="Order By"></a>Order By</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE condition]</span><br><span class="line">[ORDER BY column1, coulum2, ...][ASC|DESC];</span><br></pre></td></tr></table></figure>
<h1 id="Group-By"><a href="#Group-By" class="headerlink" title="Group By"></a>Group By</h1><p>SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。<br>在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column-list </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE[conditions]</span><br><span class="line">GROUP BY column1, ....</span><br><span class="line">ORDER BY column1,....;</span><br></pre></td></tr></table></figure>
<h1 id="Having-子句"><a href="#Having-子句" class="headerlink" title="Having 子句"></a>Having 子句</h1><p>Having子句允许指定条件来过滤将出现在最终结果的分组<br>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br><span class="line"></span><br><span class="line">such as:</span><br><span class="line">SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2;</span><br></pre></td></tr></table></figure>
<h1 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h1><p>DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。</p>
<p>有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul>
<li>NOT NULL: 确保某列不能为NULL</li>
<li>DEFAULT: 当莫列没有指定值时， 为该列提供默认值</li>
<li>UNIQUE: 确保某列的所有值不同</li>
<li>PRIMARY Key: 为一标识数据库表的各行和数据</li>
<li>CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件</li>
</ul>
<h1 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h1><p>SQLite 的 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段</p>
<ul>
<li>交叉连接 - CROSS JOIN</li>
<li>内连接 - INNER JOIN</li>
<li>外连接 - OUTER JOIN</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/10/SQL/SQL语句/" data-id="cjxc06q3r0005r0vci35yrh0d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-other/getaddrinfo爬坑" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/21/other/getaddrinfo爬坑/" class="article-date">
  <time datetime="2019-02-21T14:49:41.000Z" itemprop="datePublished">2019-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/21/other/getaddrinfo爬坑/">getaddrinfo爬坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近发现了客户一个问题， LE程序自启动一直连接不上服务端， 重启程序后成功</p>
<p>查看日志， getaddrinfo一直打印Tempoary failed in name soluation</p>
<p>开机时由systemd拉起程序, 此时网络服务并没有初始化成功， 此时连接失败时符合预期的， 间隔一段时间后， 发现还一直报域名服务失败</p>
<ol>
<li>此时采用ping 服务器域名， 发现网络正常</li>
<li>编写demo, 手动执行发现可以正常获取域名</li>
</ol>
<p>一开始被getaddrinfo文档误导了,一开始也考虑过缓存的问题，但getaddrinfow文档显示为MT-safe， 就首先排除这个选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────┬───────────────┬────────────────────┐</span><br><span class="line">│Interface       │ Attribute     │ Value              │</span><br><span class="line">├────────────────┼───────────────┼────────────────────┤</span><br><span class="line">│getaddrinfo()   │ Thread safety │ MT-Safe env locale │</span><br><span class="line">├────────────────┼───────────────┼────────────────────┤</span><br><span class="line">│freeaddrinfo(), │ Thread safety │ MT-Safe            │</span><br><span class="line">│gai_strerror()  │               │                    │</span><br><span class="line">└────────────────┴───────────────┴────────────────────┘</span><br></pre></td></tr></table></figure>
<p>后期发现DNS做了一次缓存…….</p>
<p>在使用 getaddrinfo 函数的时候，实际会使用 glibc 的相关函数，glibc 在应用第一次域名解析的时候会触发 res_init() 函数的调用，res_init() 函数的作用是读取 /etc/resolv.conf 的内容, 如 nameserver 地址、负载均衡策略、重试次数、超时时间等，并将读取的这些数据放到 static 类型的 <em>res</em> 结构体中。</p>
<p>由于 Linux 的进程在使用 glibc 动态链接库全局静态变量的时候，都会在用户进程空间生成自己独立的变量副本（感兴趣的同学可以查看每个进程的 smaps 文件，glibc 在每个用户进程空间都有可读、可写的 segment），所以每个发起 DNS 解析的进程都具有独立的 <em>res</em> 结构体变量。</p>
<p>回到 salt-minio 这个具体案例，salt-minion 进程启动后发起第一次域名解析请求，该请求最后会调用底层的 res_query，第一次 res_query 会调用 res_init()，res_init() 初始化后，nameserver 地址被初始化到当前进程的 <em>res</em> 结构体中， 然而 res_init() 对于每个进程来说，只会执行一次。</p>
<p>运维同学在用户进程运行的时候修改掉 /etc/resolv.conf 中的配置，但修改配置后无法生效的根本原因就在此（因为用户进程空间的 _res 结构体中仍然存放的是老的 nameserver 配置）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The functions described below make queriesto and interpret the responses from Internet domain name servers.The API consists of a set of more modern, reentrant functions and an older set of nonreentrant functions that have been superseded. The traditional resolver interfaces such as res_init() and res_query() use some static (global) state stored in the _res structure, rendering these functions non-thread-safe. BIND 8.2 introduced a set of new interfaces res_ninit(), res_nquery(), and so on, which take a res_state as their first argument, so you can use a per-thread</span><br><span class="line"></span><br><span class="line">resolver state.The res_ninit() and res_init() functions read the configuration files (see resolv.conf(5)) to get the default domain name and name server address(es).If no server isgiven, the local host is tried. If no domain is given, that associated with thelocal host is used. It can be overridden with the environment variable LOCALDOMAIN. res_ninit() or res_init() is normally executed by the first call to one of the other functions.</span><br></pre></td></tr></table></figure>
<p>解决方法:</p>
<ol>
<li>用户进程直接调用底层的接口，并且定期调用 res_init() 以防止 /etc/resolov.conf 文件被修改而无法感知(有一定的实现成本)。</li>
<li>直接重启用户进程，使用户进程在做第一次域名解析的时候触发 res_init()</li>
<li>用户进程实现 DNS 的 client 全部功能</li>
<li>通过非常规手段修改用户进程空间的数据</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/21/other/getaddrinfo爬坑/" data-id="cjxc06q4l000qr0vcv5gqd4q8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-流媒体/rtmp-specification-1-0" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/27/流媒体/rtmp-specification-1-0/" class="article-date">
  <time datetime="2019-01-27T15:44:15.000Z" itemprop="datePublished">2019-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/流媒体/">流媒体</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/27/流媒体/rtmp-specification-1-0/">rtmp_specification_1.0</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//<a href="https://www.cnblogs.com/Kingfans/p/7083100.html" target="_blank" rel="noopener">https://www.cnblogs.com/Kingfans/p/7083100.html</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Adobe 公司的实时消息传输协议 (RTMP) 通过一个可靠地流传输提供了一个双向多通道消息服务，比如 TCP [RFC0793]，意图在通信端之间传递带有时间信息的视频、音频和数据消息流。实现通常对不同类型的消息分配不同的优先级，当运载能力有限时，这会影响等待流传输的消息的次序。本文档将对实时流传输协议 (Real Time Messaging Protocol) 的语法和操作进行描述。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li>Payload(有效载荷): 包含于一个数据包中的数据，例如音频采样或者压缩的视频数据</li>
<li>Package(数据包): 一个数据包由一个固定头和有效载荷数据构成。一些个底层协议可能会要求对数据包定义封装。</li>
<li>Port (端口):”传输协议用以区分开指定一台主机的不同目的地的一个抽象。TCP/IP 使用小的正整数对端口进行标识。” OSI 传输层使用的运输选择器 (TSEL) 相当于端口</li>
<li>Transport address (传输地址): 用以识别传输层端点的网络地址和端口的组合，例如一个 IP 地址和一个 TCP 端口。数据包由一个源传输地址传送到一个目的传输地址。</li>
<li>Message stream (消息流): 通信中消息流通的一个逻辑通道。</li>
<li>Message stream ID (消息流 ID)：每个消息有一个关联的 ID，使用 ID 可以识别出流通中的消息流<br>Multiplexing (合成)：将独立的音频/视频数据合成为一个连续的音频/视频流的加工，这样可以同时发送几个视频和音频。</li>
<li>DeMultiplexing (分解): Multiplexing 的逆向处理，将交叉的音频和视频数据还原成原始音频和视频数据的格式。</li>
<li>Remote Procedure Call (RPC 远程方法调用): 允许客户端或服务器调用对端的一个子程序或者程序的请求。</li>
<li>Metadata (元数据): 关于数据的一个描述。一个电影的 metadata 包括电影标题、持续时间、创建时间等等。</li>
<li>Application Instance (应用实例): 服务器上应用的实例，客户端可以连接这个实例并发送连接请求。</li>
<li>Action Message Format (AMF 动作消息格式协议): 一个用于序列化 ActionScript 对象图的紧凑的二进制格式。AMF 有两个版本：AMF 0 [AMF0] 和 AMF 3 [AMF3]。</li>
</ul>
<h1 id="字节序、对齐和时间格式"><a href="#字节序、对齐和时间格式" class="headerlink" title="字节序、对齐和时间格式"></a>字节序、对齐和时间格式</h1><p>所有整数型属性以网络字节顺序传输，字节 0 代表第一个字节，零位是一个单词或字段最常用的有效位。字节序通常是大端排序。关于传输顺序的更多细节描述参考 IP 协议[RFC0791]</p>
<p>RTMP 中的所有数据都是字节对准的；例如，一个十六位的属性可能会在一个奇字节偏移上。填充后，填充字节应该有零值。</p>
<p>RTMP 中的 Timestamps 以一个整数形式给出，表示一个未指明的时间点。典型地，每个流会以一个为 0 的 timestamp 起始，但这不是必须的，只要双端能够就时间点达成一致。注意这意味着任意不同流 (尤其是来自不同主机的) 的同步需要 RTMP 之外的机制。</p>
<p>因为 timestamp 的长度为 32 位，每隔 49 天 17 小时 2 分钟和 47.296 秒就要重来一次。因为允许流连续传输，有可能要多年，RTMP 应用在处理 timestamp 时应该使用序列码算法 [RFC1982]，并且能够处理无限循环。例如，一个应用假定所有相邻的 timestamp 都在 2^31 - 1 毫秒之内，因此 10000 在 4000000000 之后，而 3000000000 在 4000000000 之前。</p>
<p>timestamp 也可以使用无符整数定义，相对于前面的 timestamp。timestamp 的长度可能会是 24 位或者 32 位。</p>
<h1 id="RTMP块流"><a href="#RTMP块流" class="headerlink" title="RTMP块流"></a>RTMP块流</h1><p>实时消息传输协议的块流 (RTMP 块流)。 它为上层多媒体流协议提供合并和打包的服务。</p>
<p>RTMP使用实时消息传输协议时，它可以处理任何发送消息流的协议。每个消息包含timestamp和payload类型标识，RTMP 块流和 RTMP 一起适合各种音频-视频应用，从一对一和一对多直播到点播服务，到互动会议应用。</p>
<p>当使用可靠传输协议时，比如 TCP [RFC0793]，RTMP 块流能够对于多流提供所有消息可靠的 timestamp 有序端对端传输。RTMP 块流并不提供任何优先权或类似形式的控制，但是可以被上层协议用来提供这种优先级。例如，一个直播视频服务器可能会基于发送时间或者每个消息的确认时间丢弃一个传输缓慢的客户端的视频消息以确保及时获取其音频消息。</p>
<p>RTMP 块流包括其自身的带内协议控制信息，并且提供机制为上层协议植入用户控制消息。</p>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>可以被分割为块以支持组合的消息的格式取决于上层协议。消息格式必须包含以下创建块所需的字段</p>
<ul>
<li>Timestamp: message timestamp, 4Byte</li>
<li>Length: 消息的有效负载长度。如果不能省略掉消息头，那它也被包括进这个长度。这个字段占用了块头的三个字节。</li>
<li>Type Id：一些类型 ID 保留给协议控制消息使用。这些传播信息的消息由 RTMP 块流协议和上层协议共同处理。其他的所有类型 ID 可用于上层协议，它们被 RTMP 块流处理为不透明值。事实上，RTMP 块流中没有任何地方要把这些值当做类型使用；所有消息必须是同一类型，或者应用使用这一字段来区分同步跟踪，而不是类型。这一字段占用了块头的一个字节</li>
<li>Message Stream ID：message stream (消息流) ID 可以使任意值。合并到同一个块流的不同的消息流是根据各自的消息流 ID 进行分解。除此之外，对 RTMP 块流而言，这是一个不透明的值。这个字段以小端格式占用了块头的四个字节</li>
</ul>
<h2 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h2><p>一个 RTMP 连接以握手开始。RTMP 的握手不同于其他协议；RTMP 握手由三个固定长度的块组成，而不是像其他协议一样的带有报头的可变长度的块。</p>
<p>客户端 (发起连接请求的终端) 和服务器端各自发送相同的三块。便于演示，当发送自客户端时这些块被指定为 C0、C1 和 C2；当发送自服务器端时这些块分别被指定为 S0、S1 和 S2</p>
<h3 id="握手顺序"><a href="#握手顺序" class="headerlink" title="握手顺序"></a>握手顺序</h3><ul>
<li>握手以客户端发送C0和C1开始</li>
<li>客户端必须等到S1才能发送C2</li>
<li>客户端必须受到S2才能发送任何其他数据</li>
<li>服务端必须等待接收到C0才能发送S0、S1，也可以等待接收到C1再发送S0和S1.服务器端必须等待接收到 C1 才能发送 S2。服务器端必须等待接收到 C2 才能发送任何其他数据。</li>
</ul>
<h3 id="C0和S0的格式"><a href="#C0和S0的格式" class="headerlink" title="C0和S0的格式"></a>C0和S0的格式</h3><p>C0 和 S0 包都是一个单一的八位字节，以一个单独的八位整型域进行处理：</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C0_S0.png" alt=""></p>
<ul>
<li>version: 本文档中规范的版本号为 3。0、1、2 三个值是由早期其他产品使用的，是废弃值；4 - 31 被保留为 RTMP 协议的未来实现版本使用；32 - 255 不允许使用 (以区分开 RTMP 和其他常以一个可打印字符开始的文本协议)。无法识别客户端所请求版本号的服务器应该以版本 3 响应，(收到响应的) 客户端可以选择降低到版本 3，或者放弃握手。</li>
</ul>
<h3 id="C1和S1的格式"><a href="#C1和S1的格式" class="headerlink" title="C1和S1的格式"></a>C1和S1的格式</h3><p>C1 和 S1 数据包的长度都是 1536 字节，包含以下字段：</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C1_S1.png" alt=""></p>
<ul>
<li>time:包含一个timestamp,用于本终端发送的所有后续块的时间起点。这个值可以是 0，或者一些任意值。要同步多个块流，终端可以发送其他块流当前的 timestamp 的值</li>
<li>zero:must be 0</li>
<li>random data(1528 Byte): 这个字段可以包含任意值。终端需要区分出响应来自它发起的握手还是对端发起的握手，这个数据应该发送一些足够随机的数。这个不需要对随机数进行加密保护，也不需要动态值</li>
</ul>
<h3 id="C2和S2的格式"><a href="#C2和S2的格式" class="headerlink" title="C2和S2的格式"></a>C2和S2的格式</h3><p>C2 和 S2 数据包长度都是 1536 字节，包含有以下字段：<br><img src="/2019/01/27/流媒体/rtmp-specification-1-0/C2_S2.png" alt=""></p>
<ul>
<li><p>time (四个字节)：这个字段必须包含终端在 S1 (给 C2) 或者 C1 (给 S2) 发的 timestamp。</p>
</li>
<li><p>time2 (四个字节)：这个字段必须包含终端先前发出数据包 (s1 或者 c1) timestamp。</p>
</li>
<li><p>random echo (1528 个字节)：这个字段必须包含终端发的 S1 (给 C2) 或者 S2 (给 C1) 的随机数。两端都可以一起使用 time 和 time2 字段再加当前 timestamp 以快速估算带宽和/或者连接延迟</p>
</li>
</ul>
<h3 id="握手示意图"><a href="#握手示意图" class="headerlink" title="握手示意图"></a>握手示意图</h3><p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/hangshark.png" alt=""></p>
<ul>
<li>Uninitalized(未初始化)：协议的版本号在这个阶段被发送。客户端和服务器都是 uninitialized (未初始化) 状态。之后客户端在数据包 C0 中将协议版本号发出。如果服务器支持这个版本，它将在回应中发送 S0 和 S1。如果不支持呢，服务器会才去适当的行为进行响应。在 RTMP 协议中，这个行为就是终止连接。</li>
<li>Version Send(版本已发送): 在未初始化状态之后，客户端和服务器都进入 Version Sent (版本已发送) 状态。客户端会等待接收数据包 S1 而服务器在等待 C1。一旦拿到期待的包，客户端会发送数据包 C2 而服务器发送数据包 S2。(客户端和服务器各自的)状态随即变为 Ack Sent (确认已发送)</li>
<li>Ack Sent(确认)：客户端和服务器分别等待 S2 和 C2。</li>
<li>Handshake Done(握手结束)：客户端和服务器可以开始交换消息了。</li>
</ul>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>握手之后，连接开始对一个或多个块流进行合并。创建的每个块都有一个唯一ID对其进行关联。这个ID为chunk stream ID,这些块通过网络进行传输。传递时，每个块必须被完全发送才可以发送下一块。在接收端，这些块被根据块流 ID 被组装成消息。</p>
<p>分块允许上层协议将大的消息分解为更小的消息，例如，防止体积大的但优先级小的消息 (比如视频) 阻碍体积较小但优先级高的消息 (比如音频或者控制命令)。</p>
<p>分块也让我们能够使用较小开销发送小消息，因为块头包含包含在消息内部的信息压缩提示。</p>
<p>块的大小是可以配置的。它可以使用一个设置块大小的控制消息进行设置 (参考 5.4.1)。更大的块大小可以降低 CPU 开销，但在低带宽连接时因为它的大量的写入也会延迟其他内容的传递。更小的块不利于高比特率的流化。所以块的大小设置取决于具体情况。</p>
<h3 id="块格式"><a href="#块格式" class="headerlink" title="块格式"></a>块格式</h3><p>每个块包含一个头和数据体，块头包含三个部分</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_header.png" alt=""></p>
<ul>
<li>Basic Header(1-3Byte):这个字段对块流ID和块类型进行编码。块类型决定了消息头的编码格式，长度完全取决于块流 ID，因为块流 ID 是一个可变长度的字段</li>
<li>Message Header(0,3,7或者11个字节):这一字段对正在发送的消息 (不管是整个消息，还是只是一小部分) 的信息进行编码。这一字段的长度可以使用块头中定义的块类型进行决定</li>
<li>Extended Timestamp (扩展 timestamp，0 或 4 字节)：这一字段是否出现取决于块消息头中的 timestamp 或者 timestamp delta 字段</li>
<li>ChunkData(有效大小): 当前块的有效负载，相当于定义的最大块大小</li>
</ul>
<h4 id="块基本头"><a href="#块基本头" class="headerlink" title="块基本头"></a>块基本头</h4><p>块基本头对块流ID和块类型进行编码，字段可能或者有1,2或者3，取决于块流ID</p>
<p>一个RTMP实现应该使用能够容纳这个ID的最小容量进行表示</p>
<p>RTMP 协议最多支持 65597 个流，流 ID 范围 3 - 65599。ID 0、1、2 被保留。0 值表示二字节形式，并且 ID 范围 64 - 319 (第二个字节 + 64)。1 值表示三字节形式，并且 ID 范围为 64 - 65599 ((第三个字节) * 256 + 第二个字节 + 64)。3 - 63 范围内的值表示整个流 ID。带有 2 值的块流 ID 被保留，用于下层协议控制消息和命令。</p>
<p>块基本头中的 0 - 5 位 (最低有效) 代表块流 ID。<br>块流 ID 2 - 63 可以编进这一字段的一字节版本中。</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header1.jpg" alt=""></p>
<p>块流 ID 64 - 319 可以以二字节的形式编码在头中。ID 计算为 (第二个字节 + 64)</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header2.jpg" alt=""></p>
<p>块流 ID 64 - 65599 可以编码在这个字段的三字节版本中。ID 计算为 ((第三个字节) * 256 + (第二个字节) + 64)。</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_basic_header3.jpg" alt=""></p>
<ul>
<li>cs id (六位)：这一字段包含有块流 ID，值的范围是 2 - 63。值 0 和 1 用于指示这一字段是 2- 或者 3- 字节版本。</li>
<li>fmt (两个字节)：这一字段指示 ‘chunk message header’ 使用的四种格式之一。没中块类型的 ‘chunk message header’ 会在下一小节解释</li>
<li>cs id - 64 (8 或者 16 位)：这一字段包含了块流 ID 减掉 64 后的值。例如，ID 365 在 cs id 中会以一个 1 进行表示，和这里的一个 16 位 的 301 (cs id - 64)。</li>
<li>块流 ID 64 - 319 可以使用 2-byte 或者 3-byte 的形式在头中表示。</li>
</ul>
<h4 id="块消息头"><a href="#块消息头" class="headerlink" title="块消息头"></a>块消息头</h4><p>块消息头又四种不同的格式，由块基本头中的 “fmt” 字段进行选择。</p>
<p>一个 (RTMP) 实现应该为每个块消息头使用最紧凑的表示。</p>
<ul>
<li>type0</li>
</ul>
<p>类型0块头的长度为11字节，这已类型必须用在块流的起始位置，每当流回退的时候，例如充值<br><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type0.jpg" alt=""></p>
<p>timestamp(三个字节): 对于type-0块，当前消息的绝对timestamp在这边发送. 如果 timestamp 大于或者等于 16777215 (十六进制 0xFFFFFF)，这一字段必须是 16777215，表明有扩展 timestamp 字段来补充完整的 32 位 timestamp。否则的话，这一字段必须是整个的 timestamp。</p>
<p>-type1</p>
<p>类型 1 块头长为 7 个字节。不包含消息流 ID；这一块使用前一块一样的流 ID。可变长度消息的流 (例如，一些视频格式) 应该在第一块之后使用这一格式表示之后的每个新消息</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type1.jpg" alt=""></p>
<ul>
<li>type2 </li>
</ul>
<p>类型 2 块头长度为 3 个字节。既不包含流 ID 也不包含消息长度；这一块具有和前一块相同的流 ID 和消息长度。具有不变长度的消息 (例如，一些音频和数据格式) 应该在第一块之后使用这一格式表示之后的每个新消息。</p>
<p><img src="/2019/01/27/流媒体/rtmp-specification-1-0/chunk_message_header_type2.jpg" alt=""></p>
<ul>
<li>type3</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/27/流媒体/rtmp-specification-1-0/" data-id="cjxc06q5j001vr0vcsnrsdrgp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-流媒体/nginx-rtmp" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/23/流媒体/nginx-rtmp/" class="article-date">
  <time datetime="2019-01-23T13:41:30.000Z" itemprop="datePublished">2019-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/流媒体/">流媒体</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/23/流媒体/nginx-rtmp/">nginx_rtmp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>git clone <a href="https://github.com/arut/nginx-rtmp-module.git" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module.git</a> </li>
<li>wget <a href="http://nginx.org/download/nginx-1.15.8.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.15.8.tar.gz</a></li>
<li>./configure –prefix=/usr/local/nginx  –add-module=../nginx-rtmp-module  –with-http_ssl_module    </li>
<li>nginx.conf <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    location /stat &#123;</span><br><span class="line">            rtmp_stat all;</span><br><span class="line">            rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">    &#125;</span><br><span class="line">    location /stat.xsl &#123;</span><br><span class="line">        root /home/cuijian/do/package/nginx-rtmp-module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp &#123;                #RTMP服务</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;  #//服务端口</span><br><span class="line">        chunk_size 4096;   #//数据传输块的大小</span><br><span class="line"></span><br><span class="line">        application live &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ffmpeg -threads 2 -re -fflags +genpts -stream_loop -1 -i test.264   -c:v copy -c:a aac -f flv rtmp://127.0.0.1:1935/live/test264</p>
<p>RTMP推流数据包</p>
<p><img src="/2019/01/23/流媒体/nginx-rtmp/rtmp_publish.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/23/流媒体/nginx-rtmp/" data-id="cjxc06q4u0018r0vc2s04rjbo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/用户态和内核态" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/07/linux/用户态和内核态/" class="article-date">
  <time datetime="2019-01-07T14:48:08.000Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/07/linux/用户态和内核态/">用户态和内核态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="用户态及内核态介绍"><a href="#用户态及内核态介绍" class="headerlink" title="用户态及内核态介绍"></a>用户态及内核态介绍</h1><p><img src="/2019/01/07/linux/用户态和内核态/Unix_Linux的体系架构.png" alt=""></p>
<p>从宏观上来看，Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。<em>内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境</em>。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>系统调用是操作系统的最小功能单位，这些系统调用根据不同的应用场景可以进行扩展和裁剪，现在各种版本的Unix实现都提供了不同数量的系统调用，如Linux的不同版本提供了240-260个系统调用，FreeBSD大约提供了320个（reference：UNIX环境高级编程）。我们可以把系统调用看成是一种不能再化简的操作（类似于原子操作，但是不同概念），有人把它比作一个汉字的一个“笔画”，而一个“汉字”就代表一个上层应用，我觉得这个比喻非常贴切。因此，有时候如果要实现一个完整的汉字（给某个变量分配内存空间），就必须调用很多的系统调用。如果从实现者（程序员）的角度来看，这势必会加重程序员的负担，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。库函数正是为了将程序员从复杂的细节中解脱出来而提出的一种有效方法。它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”。这样的一种组成方式极大增强了程序设计的灵活性，对于简单的操作，我们可以直接调用系统调用来访问资源，如“人”，对于复杂操作，我们借助于库函数来实现，如“仁”。显然，这样的库函数依据不同的标准也可以有不同的实现版本，如ISO C 标准库，POSIX标准库等。</p>
<p>　　Shell是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
<p>总结一下，用户态的应用程序可以通过三种方式来访问内核态的资源：<br>1) 系统调用<br>2) 库函数<br>3) Shell脚本</p>
<ul>
<li>向下控制硬件资源</li>
<li>向内管理操作系统资源<ul>
<li>进程的调度和管理</li>
<li>内存的管理</li>
<li>文件系统的管理</li>
<li>设备驱动</li>
<li>网络资源的管理</li>
</ul>
</li>
<li>向上则向应用程序提供系统调用的接口</li>
</ul>
<p>整个操作系统分为两层：用户态和内核态，这种分层的架构极大地提高了资源管理的可扩展性和灵活性，而且方便用户对资源的调用和集中式的管理，带来一定的安全性</p>
<p><img src="/2019/01/07/linux/用户态和内核态/kernal_framework.jpg" alt=""></p>
<h1 id="用户态及内核态的切换"><a href="#用户态及内核态的切换" class="headerlink" title="用户态及内核态的切换"></a>用户态及内核态的切换</h1><p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。</p>
<p><img src="/2019/01/07/linux/用户态和内核态/mode_change.gif" alt=""></p>
<p>从用户态到内核态的切换:</p>
<ol>
<li>系统调用</li>
<li>异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li>
<li>外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li>
</ol>
<p>系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">Linux探秘之用户态与内核态</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/07/linux/用户态和内核态/" data-id="cjxc06q42000er0vc7dmk6b25" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-other/指针数组和数组指针" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/07/other/指针数组和数组指针/" class="article-date">
  <time datetime="2019-01-07T14:17:19.000Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/07/other/指针数组和数组指针/">指针数组和数组指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><ul>
<li>int (*p)[n], 其中()优先级高于[]，故p是一个指针， 指向一维的数组，数组长度是n,p的步长也是n,也就是说执行p+1时，p要跨过n个整型数据的长度。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如要将二维数组赋给一指针，应这样赋值：</span><br><span class="line">int a[3][4];</span><br><span class="line">int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。</span><br><span class="line"> p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span><br><span class="line"> p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span><br></pre></td></tr></table></figure>
<h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><ul>
<li>int <em>p[n];[]优先级高于</em>，故先于p组成数组， int*说明是整形指针数组它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素</li>
</ul>
<h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><ul>
<li>指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。</li>
<li>数组指针：首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4 个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。</li>
</ul>
<p><img src="/2019/01/07/other/指针数组和数组指针/指针数组和数组指针-内存表示.jpg" alt=""><br><img src="/2019/01/07/other/指针数组和数组指针/指针数组和数组指针-内存表示2.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/07/other/指针数组和数组指针/" data-id="cjxc06q4n000vr0vcn14m5l2r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-other/函数指针和指针函数" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/07/other/函数指针和指针函数/" class="article-date">
  <time datetime="2019-01-07T14:11:46.000Z" itemprop="datePublished">2019-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/07/other/函数指针和指针函数/">函数指针和指针函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h1><p>返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。 </p>
<p>声明格式为：类型标识符 *函数名(参数表)</p>
<p>例如:<br>int *fun(int x,int y);</p>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p>
<p>声明格式：类型说明符 (*函数名) (参数) </p>
<p>int (*fun)(int x,int y);</p>
<p>函数指针是需要把一个函数的地址赋值给它，有两种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure></p>
<p>调用函数指针的方式也有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure></p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="定义不同"><a href="#定义不同" class="headerlink" title="定义不同"></a>定义不同</h2><ul>
<li>指针函数本质是一个函数，其返回值为指针。 </li>
<li>函数指针本质是一个指针，其指向一个函数。</li>
</ul>
<h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><ul>
<li>指针函数：int* fun(int x,int y); </li>
<li>函数指针：int (*fun)(int x,int y); </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/07/other/函数指针和指针函数/" data-id="cjxc06q4j000or0vct1t3qsud" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-流媒体/live555分析-startStream" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/05/流媒体/live555分析-startStream/" class="article-date">
  <time datetime="2019-01-05T15:58:51.000Z" itemprop="datePublished">2019-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/流媒体/">流媒体</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/05/流媒体/live555分析-startStream/">live555分析-startStream</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/05/流媒体/live555分析-startStream/" data-id="cjxc06q4q0010r0vc1e2zdhpo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux/mount" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/04/linux/mount/" class="article-date">
  <time datetime="2019-01-04T15:20:55.000Z" itemprop="datePublished">2019-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/04/linux/mount/">mount</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="peer-group"><a href="#peer-group" class="headerlink" title="peer group"></a>peer group</h2><p>peer group就是一个或多个挂载点的集合，他们之间可以共享挂载信息。目前在下面两种情况下会使两个挂载点属于同一个peer group（前提条件是挂载点的propagation type是shared）</p>
<ul>
<li><p>利用mount –bind命令，将会使源和目的挂载点属于同一个peer group，当然前提条件是‘源’必须要是一个挂载点。</p>
</li>
<li><p>当创建新的mount namespace时，新namespace会拷贝一份老namespace的挂载点信息，于是新的和老的namespace里面的相同挂载点就会属于同一个peer group</p>
</li>
</ul>
<h2 id="propagation-type"><a href="#propagation-type" class="headerlink" title="propagation type"></a>propagation type</h2><p>每个挂载点都有一个propagation type标志, 由它来决定当一个挂载点的下面创建和移除挂载点的时候，是否会传播到属于相同peer group的其他挂载点下去，也即同一个peer group里的其他的挂载点下面是不是也会创建和移除相应的挂载点.现在有4种不同类型的propagation type：</p>
<ul>
<li><p>MS_SHARED: 从名字就可以看出，挂载信息会在同一个peer group的不同挂载点之间共享传播. 当一个挂载点下面添加或者删除挂载点的时候，同一个peer group里的其他挂载点下面也会挂载和卸载同样的挂载点</p>
</li>
<li><p>MS_PRIVATE: 跟上面的刚好相反，挂载信息根本就不共享，也即private的挂载点不会属于任何peer group</p>
</li>
<li><p>MS_SLAVE: 跟名字一样，信息的传播是单向的，在同一个peer group里面，master的挂载点下面发生变化的时候，slave的挂载点下面也跟着变化，但反之则不然，slave下发生变化的时候不会通知master，master不会发生变化。</p>
</li>
<li><p>MS_UNBINDABLE: 这个和MS_PRIVATE相同，只是这种类型的挂载点不能作为bind mount的源，主要用来防止递归嵌套情况的出现</p>
</li>
</ul>
<p>最近做自包含就由这个问题， 当把根目录下/dev /sys使用mount –rbind 到当前目录下， 卸载目录时出现Device Busy， 发现系统进程占用了当前挂载点下/sys …, 导致目录一直被占用</p>
<p>解决方法</p>
<ul>
<li>使用umount -l ,  lazy可卸载当前挂载点, 但加上-l选项时出现/usr/…/cgroup也被卸载了…；原因如下，原先mount默认使用MS_SHARED，umount -l 挂载点会将挂载点下所有的挂载节点清除， 而；原因如下，原先mount默认使用MS_SHARED 则会共享挂载信息， 导致根目录下系节点也被卸载， mount 加上–make-slave时解决。猜测加上MS_SLAVE时， 源目录挂载消息可以通过内核消息传递给挂载点， 而SLAVE挂载点挂载信息则会被内核屏蔽。故虚拟化环境应当推荐使用MS_SLAVE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-l, --lazy</span><br><span class="line">             Lazy unmount.  Detach the filesystem from the file hierarchy</span><br><span class="line">             now, and clean up all references to this filesystem as soon as</span><br><span class="line">             it is not busy anymore.</span><br><span class="line"></span><br><span class="line">             A system reboot would be expected in near future if you&apos;re</span><br><span class="line">             going to use this option for network filesystem or local</span><br><span class="line">             filesystem with submounts.  The recommended use-case for</span><br><span class="line">             umount -l is to prevent hangs on shutdown due to an</span><br><span class="line">             unreachable network share where a normal umount will hang due</span><br><span class="line">             to a downed server or a network partition. Remounts of the</span><br><span class="line">             share will not be possible.</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/04/linux/mount/" data-id="cjxc06q3w0008r0vcaew2t3li" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-流媒体/H264/h264分析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/27/流媒体/H264/h264分析/" class="article-date">
  <time datetime="2018-12-27T15:35:04.000Z" itemprop="datePublished">2018-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/流媒体/">流媒体</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/27/流媒体/H264/h264分析/">h264分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="IBP帧"><a href="#IBP帧" class="headerlink" title="IBP帧"></a>IBP帧</h2><p><strong>I:关键帧</strong><br>一帧画面的完整保留，解码时只需本帧解码即可</p>
<ul>
<li>全帧压缩编码真能，将全帧图像信息进行JPEG压缩编码及传输</li>
<li>解码仅用I帧即可重构完整图像</li>
<li>描述了图像背景和运动主体详情</li>
<li>I帧不需参考其他画面生成</li>
<li>是P帧和B帧的草考帧</li>
<li>是帧组GOP的基础帧(第一帧),在一组中只有一个I帧</li>
<li>I帧不需考虑运动矢量</li>
<li>I帧所占的数据信息量较大</li>
</ul>
<p><strong>P：前向预测编码帧</strong><br>表示此帧和上一I帧的差别，解码时需要用之前缓存的图像叠加上本帧定义的差别，生成最终画面</p>
<ul>
<li>I帧后相隔1~2帧的编码帧</li>
<li>采用运动补偿的方法传送它与前面的I帧或者P帧的差值及运动矢量</li>
<li>解码必须将I帧中的预测值与预测误差求和才能重构完整的P帧图像</li>
<li>P帧属于前向预测的帧建编码，只参考其前后的B帧的参考帧</li>
<li>P是参考帧，可能造成解码错误的扩散</li>
<li>差值传送，压缩比较高</li>
</ul>
<p><strong>B: 预测与重构</strong><br>以前面的I或P和后面的P帧作为参考，找出B帧某点的预测值和两个运动矢量，并取预测差值和运动矢量传送。</p>
<ul>
<li>B帧由前面的I、P帧或者后面的P帧来进行预测的</li>
<li>传送的是它与前面的I或者P帧和后面的P帧之间的预测误差及运动矢量</li>
<li>双向预测编码帧</li>
<li>压缩比最高，只反映参考帧间运动主题的变化情况</li>
<li>非参考帧， 不会造成编码错误扩散</li>
</ul>
<h2 id="压缩方法"><a href="#压缩方法" class="headerlink" title="压缩方法"></a>压缩方法</h2><ol>
<li>分组: 将几帧分为一组(GOP,一个序列),为防止运动变化，帧数不宜取多</li>
<li>定义帧: 将每组内各帧图像定义为三种类型,I、B、P帧帧</li>
<li>预测帧: 以I帧为基础帧，以I帧预测P帧，再由I、P帧预测B帧</li>
<li>数据传输: 以最后的I帧和预测的差值信息进行存储和传输</li>
</ol>
<p><strong>帧内压缩</strong>也为空间压缩，当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻相邻帧之间的冗余信息，实际和静态图像压缩相似，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示</p>
<p><strong>帧间压缩</strong>,相邻几帧数据有较大的相关性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比，通过比较本帧和相邻帧之间的差异，仅记录本帧和其他相邻帧之间的差值，可以大大减少数据量</p>
<h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><p>在每个图像中，若干个宏块(一个编码图像被分为若干个16X16 Y、8 X 8 Cb、 8 X 8 Cr)被排列成片(I、B、P或者其他片)的形式。</p>
<p>I片包含I宏块、P片可包含P和I宏块而B片可包含B和I宏块</p>
<p>P宏块使用前面已编码图像作为参考图像进行帧内预测</p>
<p>B宏块使用双向的参考图像进行帧内预测</p>
<p><strong>H264</strong>结构中，一个视频图像编码厚度额数据叫做一帧，由多个片(slice)组成，一个片由一个或者多个块(MB)组成，宏块作为H264编码的基本单位</p>
<ul>
<li>SODB 数据比特串-&gt; 最原始的编码数据(VCL)</li>
<li>RBSP 原始字节序列载荷-&gt; 在SODB后加结尾比特（一个bit’1’，若干比特’0’字节对齐)</li>
<li>EBSP 拓展字节序列载荷-&gt; 在RBSP后加上仿校验字节0x03（在NALU加到Annexb上时，需在每组NALU前加StartCodePrefix,如果该NALU对应的slice为一帧的开始则用4字节标示，0x00 00 00 01，否则三字节0x00 00 01）。为了使NALU主体重不与开始吗冲突时，每遇到两字节连续为0，则插入一个字节的0x03,解码时将0x03去掉</li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>- </th>
</tr>
</thead>
<tbody>
<tr>
<td>VCL（video coding layer)</td>
<td>视频编码层，对应核心算法引擎，块宏及片语法级别的敌营，最终输出编码完的数据SODB</td>
</tr>
<tr>
<td>NAL (network abstraction layer)</td>
<td>网络提取层，定义片及以上语法级别，独立片解码，起始码唯一保证，SEI及流格式编码数据传送，NAL层将SODB打包成RBSP然后加上NAL头， 组成一个NALU</td>
</tr>
</tbody>
</table>
<h3 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h3><pre><code>--------------------------------------------------------
|NAL header | RBSP |NAL header | RBSP |NAL header | RBSP | ...
-------------------------------------------------------- 
</code></pre><p>其中NAL header（1byte)</p>
<pre><code>|forbidden_bit(1bit)|nal_reference_bit(2bit)|nal_unit_type(5bit)|
</code></pre><ul>
<li>forbiddent_bit: 禁止位，初始为0,当网络发现NAL单元有比特错误时可设置该比特为1，以便接收方纠错或丢掉该单元。</li>
<li>nal_reference_bit：nal重要性指示，标志该NAL单元的重要性，值越大，越重要，解码器在解码处理不过来的时候，可以丢掉重要性为0的NALU</li>
<li>nal_unit_type:</li>
</ul>
<table>
<thead>
<tr>
<th>nal_unit_type</th>
<th>type</th>
<th>nal_reference_bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>未使用</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>非IDR的片</td>
<td>此片属于参考帧，则不等于0不属于参考帧，则等与0</td>
</tr>
<tr>
<td>2</td>
<td>片数据A分区</td>
<td>同上</td>
</tr>
<tr>
<td>3</td>
<td>片数据B分区</td>
<td>同上</td>
</tr>
<tr>
<td>4</td>
<td>片数据C分区</td>
<td>同上</td>
</tr>
<tr>
<td>5</td>
<td>IDR图像的片</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>补充增强信息单元（SEI）</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>序列参数集</td>
<td>非0</td>
</tr>
<tr>
<td>8</td>
<td>图像参数集</td>
<td>非0</td>
</tr>
<tr>
<td>9</td>
<td>分界符</td>
<td>0</td>
</tr>
<tr>
<td>10</td>
<td>序列结束</td>
<td>0</td>
</tr>
<tr>
<td>11</td>
<td>码流结束</td>
<td>0</td>
</tr>
<tr>
<td>12</td>
<td>填充</td>
<td>0</td>
</tr>
<tr>
<td>13..23</td>
<td>保留</td>
<td>0</td>
</tr>
<tr>
<td>24..31</td>
<td>不保留</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="RBSP"><a href="#RBSP" class="headerlink" title="RBSP"></a>RBSP</h3><p>RBSP数据是下表中的一种</p>
<table>
<thead>
<tr>
<th>RBSP类型</th>
<th>所写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数集</td>
<td>PS</td>
<td>序列的全局信息，如图像尺寸，视频格式等</td>
</tr>
<tr>
<td>增强信息</td>
<td>SEI</td>
<td>视频序列解码的增强信息</td>
</tr>
<tr>
<td>图像界定符</td>
<td>PD</td>
<td>视频图像的边界</td>
</tr>
<tr>
<td>编码片</td>
<td>SLICE</td>
<td>编码片的头信息和数据</td>
</tr>
<tr>
<td>数据分割</td>
<td>DP</td>
<td>片层的数据，用于错误恢复解码</td>
</tr>
<tr>
<td>序列结束符</td>
<td></td>
<td>表明一个序列的结束，下一个图像为IDR图像</td>
</tr>
<tr>
<td>流结束符</td>
<td></td>
<td>表明该流中已没有图像</td>
</tr>
<tr>
<td>填充数据</td>
<td></td>
<td>亚元数据，用于填充字节</td>
</tr>
</tbody>
</table>
<p>参数集:包括序列参数集 SPS  和图像参数集 PPS</p>
<p><strong>SPS</strong> 包含的是针对一连续编码视频序列的参数，如标识符<br>seq_parameter_set_id、帧数及 POC 的约束、参考帧数目、解码图像尺寸和帧场编码模式选择标识等等。</p>
<p><strong>PPS</strong>对应的是一个序列中某一幅图像或者某几幅图像，<br>其参数如标识符 pic_parameter_set_id、可选的 seq_parameter_set_id、熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系数调整标识等等。</p>
<p>数据分割：组成片的编码数据存放在 3 个独立的 DP（数据分割，A、B、C）中，各自包含一个编码片的子集。</p>
<p>分割Ａ包含片头和片中每个宏块头数据。</p>
<p>分割Ｂ包含帧内和 SI 片宏块的编码残差数据。</p>
<p>分割 C包含帧间宏块的编码残差数据。</p>
<p>每个分割可放在独立的 NAL 单元并独立传输。</p>
<h3 id="NAL的开始和结束"><a href="#NAL的开始和结束" class="headerlink" title="NAL的开始和结束"></a>NAL的开始和结束</h3><p>编码器将每个NAL各自独立、完整地放入一个分组，因为分组都有头部，解码器可以方便地检测出NAL的分界，并依次取出NAL进行解码。<br>每个NAL前有一个起始码 0x00 00 01（或者0x00 00 00 01），解码器检测每个起始码，作为一个NAL的起始标识，当检测到下一个起始码时，当前NAL结束。</p>
<p>同时H.264规定，当检测到0x000000时，也可以表征当前NAL的结束。那么NAL中数据出现0x000001或0x000000时怎么办？H.264引入了防止竞争机制，如果编码器检测到NAL数据存在0x000001或0x000000时，编码器会在最后个字节前插入一个新的字节0x03，这样：</p>
<p>0x000000－&gt;0x00000300<br>0x000001－&gt;0x00000301<br>0x000002－&gt;0x00000302<br>0x000003－&gt;0x00000303<br>解码器检测到0x000003时，把03抛弃，恢复原始数据（脱壳操作）。解码器在解码时，首先逐个字节读取NAL的数据，统计NAL的长度，然后再开始解码。</p>
<h3 id="NALU的顺序要求"><a href="#NALU的顺序要求" class="headerlink" title="NALU的顺序要求"></a>NALU的顺序要求</h3><ol>
<li><p>序列参数集NAL单元<br>必须在传送所有以此参数集为参考的其他NAL单元之前传送，不过允许这些NAL单元中间出现重复的序列参数集NAL单元。<br>所谓重复的详细解释为：序列参数集NAL单元都有其专门的标识，如果两个序列参数集NAL单元的标识相同，就可以认为后一个只不过是前一个的拷贝，而非新的序列参数集</p>
</li>
<li><p>图像参数集NAL单元<br>必须在所有以此参数集为参考的其他NAL单元之前传送，不过允许这些NAL单元中间出现重复的图像参数集NAL单元，这一点与上述的序列参数集NAL单元是相同的</p>
</li>
<li><p>不同基本编码图像中的片段（slice）单元和数据划分片段（data partition）单元在顺序上不可以相互交叉，即不允许属于某一基本编码图像的一系列片段（slice）单元和数据划分片段（data partition）单元中忽然出现另一个基本编码图像的片段（slice）单元片段和数据划分片段（data partition）单元。</p>
</li>
<li><p>参考图像的影响：如果一幅图像以另一幅图像为参考，则属于前者的所有片段（slice）单元和数据划分片段（data partition）单元必须在属于后者的片段和数据划分片段之后，无论是基本编码图像还是冗余编码图像都必须遵守这个规则。</p>
</li>
<li><p>基本编码图像的所有片段（slice）单元和数据划分片段（data partition）单元必须在属于相应冗余编码图像的片段（slice）单元和数据划分片段（data partition）单元之前。</p>
</li>
<li><p>如果数据流中出现了连续的无参考基本编码图像，则图像序号小的在前面。</p>
</li>
<li><p>如果arbitrary_slice_order_allowed_flag置为1，一个基本编码图像中的片段（slice）单元和数据划分片段（data partition）单元的顺序是任意的，如果arbitrary_slice_order_allowed_flag置为零，则要按照片段中第一个宏块的位置来确定片段的顺序，若使用数据划分，则A类数据划分片段在B类数据划分片段之前，B类数据划分片段在C类数据划分片段之前，而且对应不同片段的数据划分片段不能相互交叉，也不能与没有数据划分的片段相互交叉。</p>
</li>
<li><p>如果存在SEI（补充增强信息）单元的话，它必须在它所对应的基本编码图像的片段（slice）单元和数据划分片段（data partition）单元之前，并同时必须紧接在上一个基本编码图像的所有片段（slice）单元和数据划分片段（data partition）单元后边。假如SEI属于多个基本编码图像，其顺序仅以第一个基本编码图像为参照。</p>
</li>
<li><p>如果存在图像分割符的话，它必须在所有SEI 单元、基本编码图像的所有片段slice）单元和数据划分片段（data partition）单元之前，并且紧接着上一个基本编码图像那些NAL单元。</p>
</li>
<li><p>如果存在序列结束符，且序列结束符后还有图像，则该图像必须是IDR（即时解码器刷新）图像。序列结束符的位置应当在属于这个IDR图像的分割符、SEI 单元等数据之前，且紧接着前面那些图像的NAL单元。如果序列结束符后没有图像了，那么它的就在比特流中所有图像数据之后。</p>
</li>
<li><p>流结束符在比特流中的最后</p>
</li>
</ol>
<h3 id="H264元素分层结构"><a href="#H264元素分层结构" class="headerlink" title="H264元素分层结构"></a>H264元素分层结构</h3><p>H.264编码器输出的Bit流中，每个Bit都隶属于某个句法元素。句法元素被组织成有层次的结构，分别描述各个层次的信息。<br><img src="/2018/12/27/流媒体/H264/h264分析/h264_bits.gif" alt=""></p>
<p>句法元素被组织成序列、图像、片、宏块和子宏块5个层次，这样的结构中，每一层的头部和它的数据部分形成管理与被管理的强依赖关系，头部的句法元素是该层数据的核心，而一旦头部丢失，数据部分的信息几乎不可能再被正确解码出来，尤其在序列层及图像层。<br><img src="/2018/12/27/流媒体/H264/h264分析/h264_layers.gif" alt=""></p>
<p>在 H.264 中，分层结构最大的不同是取消了序列层和图像层，并将原本属于序列和图像头部的大部分句法元素游离出来形成序列和图像两级参数集，其余的部分则放入片层。<br>参数集是一个独立的数据单位，不依赖于参数集外的其他句法元素。一个参数集不对应某一个特定的图像或序列，同一序列参数集可以被多个图像参数集引用，同理，同一个图像参数集也可以被多个图像引用。只在编码器认为需要更新参数集的内容时，才会发出新的参数集。<br>复杂通信中的码流中可能出现的数据单位：<br><img src="/2018/12/27/流媒体/H264/h264分析/h264_layers2.gif" alt=""></p>
<p>IDR: 在H.264中，图像以序列为单位进行组织。一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。      IDR 图像一定是 I 图像，但 I 图像不一定是 IDR 图像。I帧之后的图像有可能会使用I帧之前的图像做运动参考。</p>
<p><img src="/2018/12/27/流媒体/H264/h264分析/h264_stream.jpg" alt=""></p>
<p>参考</p>
<blockquote>
<p><a href="http://www.360doc.com/content/14/0813/15/12697_401555631.shtml" title="H264编码原理和IBP帧" target="_blank" rel="noopener">H264编码原理和IBP帧</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/yibu_refresh/article/details/52829643" title="视频格式封装——H264" target="_blank" rel="noopener">视频格式封装——H264</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/27/流媒体/H264/h264分析/" data-id="cjxc06q650027r0vck5kdm344" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/流媒体/">流媒体</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编译框架/">编译框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/26/linux/linux应用程序加载/">linux应用程序加载</a>
          </li>
        
          <li>
            <a href="/2019/06/05/网络/TCP三次握手+四次挥手/">TCP三次握手+四次挥手</a>
          </li>
        
          <li>
            <a href="/2019/05/07/SQL/mongodb/">mongodb</a>
          </li>
        
          <li>
            <a href="/2019/04/08/网络/epoll框架/">epoll框架</a>
          </li>
        
          <li>
            <a href="/2019/04/04/编译框架/cmake-基本命令/">cmake-基本命令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Jian.Cui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>